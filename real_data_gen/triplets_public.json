{
    "0": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "1": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "2": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "3": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "4": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "5": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "6": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "7": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "8": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "9": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "10": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "11": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "12": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "13": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "14": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine().toLowerCase(); switch (inputLine) { case \"exit\": { return new Exit(0) ; } case \"u\": { return new Undo(0); } case \"w\": { return new Move.Up(0); } case \"a\": { return new Move.Left(0); } case \"s\": { return new Move.Down(0); } case \"d\": { return new Move.Right(0); } case \"h\": { return new Move.Left(1); } case \"j\": { return new Move.Down(1); } case \"k\": { return new Move.Up(1); } case \"l\": { return new Move.Right(1); } default: { return new InvalidInput(0, \"Invalid Input\"); } } // TODO }",
        "label": "P"
    },
    "15": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public void move(Position from, Position to) { // TODO Position newPosition = new Position(to.x(),to.y()); Position currentPosition = new Position(from.x(),from.y()); if (this.map.gameBoardMap.get(currentPosition) instanceof Box) { currentGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); currentPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); } else { //id:position this.map.playerPositionMap.replace(((Player) this.map.gameBoardMap.get(currentPosition)).getId(),newPosition); //all position of all player } this.map.putEntity(newPosition,this.map.getEntity(currentPosition)); this.map.putEntity(currentPosition,new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "16": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public void move(Position from, Position to) { // TODO Position newPosition = new Position(to.x(),to.y()); Position currentPosition = new Position(from.x(),from.y()); if (this.map.gameBoardMap.get(currentPosition) instanceof Box) { currentGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); currentPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); } else { //id:position this.map.playerPositionMap.replace(((Player) this.map.gameBoardMap.get(currentPosition)).getId(),newPosition); //all position of all player } this.map.putEntity(newPosition,this.map.getEntity(currentPosition)); this.map.putEntity(currentPosition,new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.map.playerPositionMap.get(id); }",
        "label": "P"
    },
    "17": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public void move(Position from, Position to) { // TODO Position newPosition = new Position(to.x(),to.y()); Position currentPosition = new Position(from.x(),from.y()); if (this.map.gameBoardMap.get(currentPosition) instanceof Box) { currentGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); currentPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); } else { //id:position this.map.playerPositionMap.replace(((Player) this.map.gameBoardMap.get(currentPosition)).getId(),newPosition); //all position of all player } this.map.putEntity(newPosition,this.map.getEntity(currentPosition)); this.map.putEntity(currentPosition,new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.map.playerPositionMap.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "18": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public Optional<Integer> getUndoQuota() { // TODO return this.map.getUndoLimit(); }",
        "label": "P"
    },
    "19": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set allPlayerPosition = new HashSet(); for (int id : this.map.playerPositionMap.keySet()) { allPlayerPosition.add(this.map.playerPositionMap.get(id)); } return allPlayerPosition; }",
        "label": "P"
    },
    "20": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public void move(Position from, Position to) { // TODO Position newPosition = new Position(to.x(),to.y()); Position currentPosition = new Position(from.x(),from.y()); if (this.map.gameBoardMap.get(currentPosition) instanceof Box) { currentGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); currentPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); } else { //id:position this.map.playerPositionMap.replace(((Player) this.map.gameBoardMap.get(currentPosition)).getId(),newPosition); //all position of all player } this.map.putEntity(newPosition,this.map.getEntity(currentPosition)); this.map.putEntity(currentPosition,new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO this.playerCheckPoint.add(this.currentPlayerPosition); this.checkPoint.add(this.currentGameBoard); } public void undo() { // TODO if (this.map.undoLimit >0 || this.map.undoLimit == -1) { if (this.checkPoint.size() == 0) { this.map.playerPositionMap = this.getCurrentPlayerPosition(this.initialAllPlayerPosition); this.map.gameBoardMap = this.getCurrentGameBoard(this.initialGameBoard); } else { if (this.map.undoLimit != -1) { this.map.undoLimit -=1; } this.map.gameBoardMap = this.getCurrentGameBoard(this.checkPoint.get(checkPoint.size()-1)); this.map.playerPositionMap = this.getCurrentPlayerPosition(this.playerCheckPoint.get(this.playerCheckPoint.size()-1)); this.checkPoint.remove(checkPoint.size()-1); this.playerCheckPoint.remove(this.playerCheckPoint.size()-1); } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO return this.map.playerPositionMap.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return this.map.getUndoLimit(); }",
        "label": "P"
    },
    "21": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size()>2) { throw new NotImplementedException(); } } public void run() { // TODO this.renderingEngine.message(\"Sokoban game is ready.\"); boolean exit = false; while (!(this.shouldStop())) { this.renderingEngine.render(this.state); this.renderingEngine.message(\"\"); String undolimit = this.state.getUndoQuota().toString(); undolimit = undolimit.substring(9,undolimit.length()-1); this.renderingEngine.message(\"Undo Quota: \" + undolimit); this.renderingEngine.message(\">>>\"); Action tempAction = this.inputEngine.fetchAction(); ActionResult tempActionResult = this.processAction(tempAction); if (tempActionResult instanceof ActionResult.Failed) { this.renderingEngine.message(((ActionResult.Failed) tempActionResult).getReason()); } if (tempAction instanceof Exit) { exit = true; } } this.renderingEngine.render(this.state); this.renderingEngine.message(\"\"); this.renderingEngine.message(\"Game exits.\"); if (!exit) { this.renderingEngine.message(\"You win.\"); } }",
        "label": "P"
    },
    "22": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size()>2) { throw new NotImplementedException(); } }",
        "label": "P"
    },
    "23": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO this.outputSteam.println(content); // Hint: System.out is also a PrintStream. }",
        "label": "P"
    },
    "24": {
        "dataset": "COMP 3021",
        "project": "kcwongbn",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public GameState(@NotNull GameMap map) { // TODO this.map = map; this.initialAllPlayerPosition = this.getCurrentPlayerPosition(this.map.playerPositionMap); this.initialGameBoard = this.getCurrentGameBoard(this.map.gameBoardMap); this.map.undoLimit = this.getUndoQuota().get(); }",
        "label": "P"
    },
    "25": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; } public int getMaxHeight() { // TODO return height; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undoLimit); }",
        "label": "P"
    },
    "26": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "27": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "28": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "29": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "30": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "31": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "32": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "33": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; }",
        "label": "P"
    },
    "34": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; }",
        "label": "P"
    },
    "35": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "36": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "37": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "38": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "39": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO int id = -1; int playerOne = 0; int playerTwo = 1; String lowerCaseInput = inputLine.toLowerCase(); return switch (lowerCaseInput) { case \"A\" -> new Move.Left(playerOne); case \"W\" -> new Move.Up(playerOne); case \"S\" -> new Move.Down(playerOne); case \"D\" -> new Move.Right(playerOne); case \"H\" -> new Move.Left(playerTwo); case \"J\" -> new Move.Down(playerTwo); case \"K\" -> new Move.Up(playerTwo); case \"L\" -> new Move.Right(playerTwo); case \"U\" -> new Undo(id); case EXIT_COMMAND_TEXT -> new Exit(id); default -> new InvalidInput(id, INVALID_INPUT_MESSAGE); }; }",
        "label": "P"
    },
    "40": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public void move(Position from, Position to) { // TODO Entity move = getEntity(from); mapEntity.put(from, new Empty()); mapEntity.put(to, move); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "41": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public void move(Position from, Position to) { // TODO Entity move = getEntity(from); mapEntity.put(from, new Empty()); mapEntity.put(to, move); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getValue() instanceof Player) { if (((Player) entry.getValue()).getId() == id) { return entry.getKey(); } } } return null; }",
        "label": "P"
    },
    "42": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public void move(Position from, Position to) { // TODO Entity move = getEntity(from); mapEntity.put(from, new Empty()); mapEntity.put(to, move); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getValue() instanceof Player) { if (((Player) entry.getValue()).getId() == id) { return entry.getKey(); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "43": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public Optional<Integer> getUndoQuota() { // TODO if (!map.getUndoLimit().equals(-1)) { return undoQuota; } else { return Optional.empty(); } }",
        "label": "P"
    },
    "44": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> playerPositions = new HashSet<>(); for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getValue() instanceof Player) { playerPositions.add(entry.getKey()); } } return playerPositions; }",
        "label": "P"
    },
    "45": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public void move(Position from, Position to) { // TODO Entity move = getEntity(from); mapEntity.put(from, new Empty()); mapEntity.put(to, move); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO moveHistory.add(new HashMap<>(mapEntity)); } public void undo() { // TODO if (moveHistory.size() > 1) { moveHistory.pop(); if (!undoQuota.isEmpty()) { undoQuota = Optional.of(undoQuota.get() - 1); } } mapEntity = new HashMap<>(moveHistory.peek()); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getValue() instanceof Player) { if (((Player) entry.getValue()).getId() == id) { return entry.getKey(); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapEntity.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (!map.getUndoLimit().equals(-1)) { return undoQuota; } else { return Optional.empty(); } }",
        "label": "P"
    },
    "46": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(INVALID_INPUT_MESSAGE); } } public void run() { // TODO renderingEngine.message(GAME_READY_MESSAGE); renderingEngine.render(state); while (!shouldStop()) { String quotaText; if (state.getUndoQuota().isEmpty()) { quotaText = UNDO_QUOTA_UNLIMITED; } else { quotaText = String.valueOf(state.getUndoQuota().get()); } String formatedQuotaText = String.format(UNDO_QUOTA_TEMPLATE, quotaText); renderingEngine.message(formatedQuotaText); renderingEngine.message(\"Input(Player1:W/A/S/D, Player2:H/J/K/L):\"); Action action = inputEngine.fetchAction(); ActionResult result = processAction(action); if(result instanceof ActionResult.Failed){ renderingEngine.message(((ActionResult.Failed) result).getReason()); } renderingEngine.render(state); } renderingEngine.message(GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(WIN_MESSAGE); } }",
        "label": "P"
    },
    "47": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "48": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "49": {
        "dataset": "COMP 3021",
        "project": "cyngaz",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.getUndoLimit(); mapEntity = new HashMap<>(map.mapEntity()); undoQuota = map.getUndoLimit(); moveHistory.add(new HashMap<>(mapEntity)); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "50": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODOx return this.maxWidth; } public int getMaxHeight() { // TODOx return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODOx // assumed non-null return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "51": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "52": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "53": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "54": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "55": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "56": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODOx: test return this.grid[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "57": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODOx: test return this.grid[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "58": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODOx return this.maxHeight; }",
        "label": "P"
    },
    "59": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODOx return this.maxWidth; }",
        "label": "P"
    },
    "60": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO : use in isWin return originalMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; <br> * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODOx: test return this.grid[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "61": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODOx: test return this.grid[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "62": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODOx: test return this.grid[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "63": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODOx: test return this.grid[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "64": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); if (inputLine == null) { return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); } // TODO check playerid // String[] inputs = inputLine.split(\"\\\\s+\"); // https://www.geeksforgeeks.org/string-in-switch-case-in-java/ switch (inputLine.toLowerCase()){ case StringResources.EXIT_COMMAND_TEXT: // better place elsewhere? System.out.println(StringResources.GAME_EXIT_MESSAGE); return new Exit(0); case \"u\": return new Undo(0); case \"a\": return new Move.Left(0); case \"s\": return new Move.Down(0); case \"w\": return new Move.Up(0); case \"d\": return new Move.Right(0); case \"h\": return new Move.Left(1); case \"j\": return new Move.Down(1); case \"k\": return new Move.Up(1); case \"l\": return new Move.Right(1); default: return new InvalidInput(0,\"Invalid Input.\"); } }",
        "label": "P"
    },
    "65": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public void move(Position from, Position to) { // TODOx: test Entity entFrom = this.grid[from.y()][from.x()]; this.grid[to.y()][to.x()] = entFrom; this.grid[from.y()][from.x()] = new Empty(); if (entFrom instanceof Player){ int pid = ((Player) entFrom).getId(); int ix = playersChar.indexOf((char) ('A'+pid)); playersPos.set(ix, to); } else if (entFrom instanceof Box) { int pid = ((Box) entFrom).getPlayerId(); int ix = boxesChar.indexOf((char) ('a'+pid)); boxesPos.set(ix, to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "66": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public void move(Position from, Position to) { // TODOx: test Entity entFrom = this.grid[from.y()][from.x()]; this.grid[to.y()][to.x()] = entFrom; this.grid[from.y()][from.x()] = new Empty(); if (entFrom instanceof Player){ int pid = ((Player) entFrom).getId(); int ix = playersChar.indexOf((char) ('A'+pid)); playersPos.set(ix, to); } else if (entFrom instanceof Box) { int pid = ((Box) entFrom).getPlayerId(); int ix = boxesChar.indexOf((char) ('a'+pid)); boxesPos.set(ix, to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODOx for (int i=0; i<this.playersChar.size(); i++){ char pc = playersChar.get(i); if ((pc - 'A') == id){ return playersPos.get(i); } } // int maxh = this.originalMap.getMaxHeight(); // int maxw = this.originalMap.getMaxWidth(); // for (int i = 0; i < maxh; i++) { // for (int j = 0; j < maxw; j++) { // Position pos = new Position(j,i); // Entity ent = getEntity(pos); // if (ent instanceof Player){ // Player pla = (Player) ent; // if (pla.getId() == id) { // return pos; // } // } // } // } return null; }",
        "label": "P"
    },
    "67": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public void move(Position from, Position to) { // TODOx: test Entity entFrom = this.grid[from.y()][from.x()]; this.grid[to.y()][to.x()] = entFrom; this.grid[from.y()][from.x()] = new Empty(); if (entFrom instanceof Player){ int pid = ((Player) entFrom).getId(); int ix = playersChar.indexOf((char) ('A'+pid)); playersPos.set(ix, to); } else if (entFrom instanceof Box) { int pid = ((Box) entFrom).getPlayerId(); int ix = boxesChar.indexOf((char) ('a'+pid)); boxesPos.set(ix, to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODOx for (int i=0; i<this.playersChar.size(); i++){ char pc = playersChar.get(i); if ((pc - 'A') == id){ return playersPos.get(i); } } // int maxh = this.originalMap.getMaxHeight(); // int maxw = this.originalMap.getMaxWidth(); // for (int i = 0; i < maxh; i++) { // for (int j = 0; j < maxw; j++) { // Position pos = new Position(j,i); // Entity ent = getEntity(pos); // if (ent instanceof Player){ // Player pla = (Player) ent; // if (pla.getId() == id) { // return pos; // } // } // } // } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODOx: test return this.grid[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "68": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public Optional<Integer> getUndoQuota() { // TODOx check optional // return undo quota if > -1, else return Optional.empty() return this.undoQuota.filter(x -> x > -1); }",
        "label": "P"
    },
    "69": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODOx check Set<Position> allPlaPos = new HashSet<>(); for (int i=0; i<playersPos.size(); i++){ allPlaPos.add(playersPos.get(i)); } return allPlaPos; }",
        "label": "P"
    },
    "70": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public void move(Position from, Position to) { // TODOx: test Entity entFrom = this.grid[from.y()][from.x()]; this.grid[to.y()][to.x()] = entFrom; this.grid[from.y()][from.x()] = new Empty(); if (entFrom instanceof Player){ int pid = ((Player) entFrom).getId(); int ix = playersChar.indexOf((char) ('A'+pid)); playersPos.set(ix, to); } else if (entFrom instanceof Box) { int pid = ((Box) entFrom).getPlayerId(); int ix = boxesChar.indexOf((char) ('a'+pid)); boxesPos.set(ix, to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO int maxh = this.originalMap.getMaxHeight(); int maxw = this.originalMap.getMaxWidth(); Entity[][] savegrid = new Entity[maxh][maxw]; for (int i = 0; i < maxh; i++) { for (int j = 0; j < maxw; j++) { Entity ent = this.getEntity(new Position(j, i)); if (this.grid[i][j] instanceof Box){ Box box = (Box) ent; savegrid[i][j] = new Box(box.getPlayerId()); } else if (this.grid[i][j] instanceof Player){ Player pla = (Player) ent; savegrid[i][j] = new Box(pla.getId()); } else if (this.grid[i][j] instanceof Wall) { savegrid[i][j] = new Wall(); } else if (this.grid[i][j] instanceof Empty) { savegrid[i][j] = new Empty(); } } } List<Position> saveplaPos = new ArrayList<>(); for (Position p:playersPos){ saveplaPos.add(new Position(p.x(), p.y())); } List<Position> saveboxPos = new ArrayList<>(); for (Position p:boxesPos){ saveboxPos.add(new Position(p.x(), p.y())); } System.out.println(\"checkpoint\"); System.out.println(this.cpState.size()); this.cpState.push(savegrid); this.plaPosState.push(saveplaPos); this.boxesPosState.push(saveboxPos); System.out.println(this.cpState.size()); } public void undo() { // TODO if (this.undoQuota.get() < 1){ System.out.println(\"run out of quota\"); return; } if (this.cpState.empty()){ System.out.println(\"no prev cp\"); return; } System.out.println(\"undoing\"); this.undoQuota = Optional.of(undoQuota.get() - 1); System.out.println(this.getPlayerPositionById(0)); this.grid = (Entity [][]) this.cpState.pop(); this.playersPos = this.plaPosState.pop(); this.boxesPos = this.boxesPosState.pop(); System.out.println(this.getPlayerPositionById(0)); return; } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODOx for (int i=0; i<this.playersChar.size(); i++){ char pc = playersChar.get(i); if ((pc - 'A') == id){ return playersPos.get(i); } } // int maxh = this.originalMap.getMaxHeight(); // int maxw = this.originalMap.getMaxWidth(); // for (int i = 0; i < maxh; i++) { // for (int j = 0; j < maxw; j++) { // Position pos = new Position(j,i); // Entity ent = getEntity(pos); // if (ent instanceof Player){ // Player pla = (Player) ent; // if (pla.getId() == id) { // return pos; // } // } // } // } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODOx: test return this.grid[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODOx check optional // return undo quota if > -1, else return Optional.empty() return this.undoQuota.filter(x -> x > -1); }",
        "label": "F"
    },
    "71": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players int numPlayers = gameState.getAllPlayerPositions().size(); this.state = gameState; // throw new NotImplementedException(); } public void run() { // TODO // check isWin // check userinput if (this.state.isWin()){ return; } this.renderingEngine.render(this.state); }",
        "label": "F"
    },
    "72": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players int numPlayers = gameState.getAllPlayerPositions().size(); this.state = gameState; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "73": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODOx // Hint: System.out is also a PrintStream. outputSteam.print(content+System.lineSeparator()); }",
        "label": "P"
    },
    "74": {
        "dataset": "COMP 3021",
        "project": "owidjaja",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.grid = map.grid; this.undoQuota = map.getUndoLimit(); this.playersChar = new ArrayList<>(); this.playersPos = new ArrayList<>(); // deep copy so that originalMap properties not changed for (int i=0; i<map.playersChar.size(); i++){ this.playersChar.add(map.playersChar.get(i)); this.playersPos.add(map.playersPos.get(i)); } this.boxesChar = new ArrayList<>(); this.boxesPos = new ArrayList<>(); for (int i=0; i<map.boxesChar.size(); i++){ this.boxesChar.add(map.boxesChar.get(i)); this.boxesPos.add(map.boxesPos.get(i)); } this.cpCount = 0; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "75": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO return height; //throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undonumber); //throw new NotImplementedException(); }",
        "label": "F"
    },
    "76": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "F"
    },
    "77": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "78": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "F"
    },
    "79": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "F"
    },
    "80": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "F"
    },
    "81": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curmap.getEntity(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "F"
    },
    "82": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curmap.getEntity(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "F"
    },
    "83": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; //throw new NotImplementedException(); }",
        "label": "F"
    },
    "84": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; // throw new NotImplementedException(); }",
        "label": "F"
    },
    "85": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return curmap.getDestinations(); //throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curmap.getEntity(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "F"
    },
    "86": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curmap.getEntity(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "F"
    },
    "87": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curmap.getEntity(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "F"
    },
    "88": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curmap.getEntity(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "F"
    },
    "89": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO switch (inputLine){ case \"Exit\", \"exit\": return new Exit(0); case \"W\": return new Move.Up(0); case \"A\": return new Move.Left(0); case \"S\": return new Move.Down(0); case \"D\": return new Move.Right(0); case \"H\": return new Move.Left(1); case \"J\": return new Move.Down(1); case \"K\": return new Move.Up(1); case \"L\": return new Move.Right(1); case \"U\", \"u\", \"undo\": return new Undo(0); default: return new InvalidInput(0,\"Invalid input\"); } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "90": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "F"
    },
    "91": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO throw new NotImplementedException(); }",
        "label": "F"
    },
    "92": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curmap.getEntity(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "F"
    },
    "93": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO if (undoquota == -1) { return Optional.empty(); } else return Optional.of(undoquota); // throw new NotImplementedException(); }",
        "label": "F"
    },
    "94": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO throw new NotImplementedException(); }",
        "label": "F"
    },
    "95": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO throw new NotImplementedException(); } public void undo() { // TODO throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curmap.getEntity(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (undoquota == -1) { return Optional.empty(); } else return Optional.of(undoquota); // throw new NotImplementedException(); }",
        "label": "F"
    },
    "96": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players numplayer = gameState.getAllPlayerPositions().size(); // throw new NotImplementedException(); } public void run() { // TODO renderingEngine.render(state); inputEngine.fetchAction(); }",
        "label": "F"
    },
    "97": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players numplayer = gameState.getAllPlayerPositions().size(); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "98": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. System.out.println(content); //throw new NotImplementedException(); }",
        "label": "F"
    },
    "99": {
        "dataset": "COMP 3021",
        "project": "thsze",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO curmap = map; undoquota = map.getUndoLimit().get(); //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "F"
    },
    "100": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "101": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "102": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "103": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "104": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "105": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "106": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "107": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "108": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "109": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "110": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "111": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "112": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "113": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "114": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO if(inputLine.equalsIgnoreCase(\"Exit\")) return new Exit(0); if(inputLine.equalsIgnoreCase(\"U\")) return new Undo(0); Action result = switch (inputLine){ case \"A\", \"a\" -> new Move.Left(0); case \"S\", \"s\" -> new Move.Down(0); case \"W\", \"w\" -> new Move.Up(0); case \"D\", \"d\" -> new Move.Right(0); case \"H\", \"h\" -> new Move.Left(1); case \"J\", \"j\" -> new Move.Down(1); case \"K\", \"k\" -> new Move.Up(1); case \"L\", \"l\" -> new Move.Right(1); default -> new InvalidInput(0, \"Invalid Input.\"); }; return result; }",
        "label": "P"
    },
    "115": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public void move(Position from, Position to) { // TODO var fromT = this.gameMap.getEntity(from); this.gameMap.putEntity(to,fromT); this.gameMap.putEntity(from,new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "116": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public void move(Position from, Position to) { // TODO var fromT = this.gameMap.getEntity(from); this.gameMap.putEntity(to,fromT); this.gameMap.putEntity(from,new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO char player = (char)(id + (int)('A')); for(int j = 0; j < this.gameMap.getMaxHeight(); ++j){ for(int i = 0; i < this.gameMap.getMaxWidth(); ++i){ if(this.gameMap.Map[j].charAt(i) == player) return Position.of(i, j); } } return null; }",
        "label": "P"
    },
    "117": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public void move(Position from, Position to) { // TODO var fromT = this.gameMap.getEntity(from); this.gameMap.putEntity(to,fromT); this.gameMap.putEntity(from,new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO char player = (char)(id + (int)('A')); for(int j = 0; j < this.gameMap.getMaxHeight(); ++j){ for(int i = 0; i < this.gameMap.getMaxWidth(); ++i){ if(this.gameMap.Map[j].charAt(i) == player) return Position.of(i, j); } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "118": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public Optional<Integer> getUndoQuota() { // TODO return Optional.of(undoQuota); }",
        "label": "P"
    },
    "119": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Integer> players = this.gameMap.getPlayerIds(); Set<Position> PlayerPos = new HashSet<>(); for(Integer p : players){ PlayerPos.add(this.getPlayerPositionById(p)); } return PlayerPos; }",
        "label": "P"
    },
    "120": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public void move(Position from, Position to) { // TODO var fromT = this.gameMap.getEntity(from); this.gameMap.putEntity(to,fromT); this.gameMap.putEntity(from,new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO this.history = new GameState(this); } public void undo() { // TODO if(this.history != null){ if(undoQuota != -1)undoQuota --; this.gameMap = this.history.gameMap; this.history = this.history.history; } else { this.gameMap.Map = GameMap.OriginMap.clone(); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO char player = (char)(id + (int)('A')); for(int j = 0; j < this.gameMap.getMaxHeight(); ++j){ for(int i = 0; i < this.gameMap.getMaxWidth(); ++i){ if(this.gameMap.Map[j].charAt(i) == player) return Position.of(i, j); } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return Optional.of(undoQuota); }",
        "label": "F"
    },
    "121": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players int Numplayers = gameState.getAllPlayerPositions().size(); if(Numplayers > 2) throw new IllegalArgumentException(); } public void run() { // TODO this.renderingEngine.message(\"Sokoban game is ready.\"); this.renderingEngine.render(this.state); if(this.state.getUndoQuota().isPresent())this.renderingEngine.message(\"Undo Quota: \" + (this.state.getUndoQuota().get() == -1 ? \"unlimited\":this.state.getUndoQuota().get())); while(this.shouldStop() == false){ var result = this.processAction(this.inputEngine.fetchAction()); switch(result){ case ActionResult.Success ignored: break; case ActionResult.Failed failed_: System.out.println(failed_.getReason()); break; } this.renderingEngine.render(this.state); if(this.state.getUndoQuota().isPresent())this.renderingEngine.message(\"Undo Quota: \" + (this.state.getUndoQuota().get() == -1 ? \"unlimited\":this.state.getUndoQuota().get())); } }",
        "label": "P"
    },
    "122": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players int Numplayers = gameState.getAllPlayerPositions().size(); if(Numplayers > 2) throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "123": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "124": {
        "dataset": "COMP 3021",
        "project": "hwangem",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.getUndoLimit().get(); history = null; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "125": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO return height; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO Optional<Integer> undoLimit = Optional.of(undo); return undoLimit; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "126": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "127": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "128": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "129": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "130": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "131": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return originalMap.entityArr[position.y()][position.x()]; // String[] splited = originalMap.map.lines().toArray(String[]::new); //// System.out.print(map); // System.out.print(splited[position.y()+1].charAt(position.x())); // int checkchar = (int) splited[position.y()+1].charAt(position.x()); // // if(checkchar<91&&checkchar>64){ // return new Player(checkchar-65); //// System.out.print(checkchar); // } // if(checkchar<123&&checkchar>96){ // return new Box(checkchar-97); //// System.out.print(checkchar); // } // if(checkchar==46){ // return new Empty(); // } // if(checkchar==35){ // return new Wall(); // } // return new Empty(); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "132": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return originalMap.entityArr[position.y()][position.x()]; // String[] splited = originalMap.map.lines().toArray(String[]::new); //// System.out.print(map); // System.out.print(splited[position.y()+1].charAt(position.x())); // int checkchar = (int) splited[position.y()+1].charAt(position.x()); // // if(checkchar<91&&checkchar>64){ // return new Player(checkchar-65); //// System.out.print(checkchar); // } // if(checkchar<123&&checkchar>96){ // return new Box(checkchar-97); //// System.out.print(checkchar); // } // if(checkchar==46){ // return new Empty(); // } // if(checkchar==35){ // return new Wall(); // } // return new Empty(); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "133": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "134": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "135": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return originalMap.getDestinations(); // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return originalMap.entityArr[position.y()][position.x()]; // String[] splited = originalMap.map.lines().toArray(String[]::new); //// System.out.print(map); // System.out.print(splited[position.y()+1].charAt(position.x())); // int checkchar = (int) splited[position.y()+1].charAt(position.x()); // // if(checkchar<91&&checkchar>64){ // return new Player(checkchar-65); //// System.out.print(checkchar); // } // if(checkchar<123&&checkchar>96){ // return new Box(checkchar-97); //// System.out.print(checkchar); // } // if(checkchar==46){ // return new Empty(); // } // if(checkchar==35){ // return new Wall(); // } // return new Empty(); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "136": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return originalMap.entityArr[position.y()][position.x()]; // String[] splited = originalMap.map.lines().toArray(String[]::new); //// System.out.print(map); // System.out.print(splited[position.y()+1].charAt(position.x())); // int checkchar = (int) splited[position.y()+1].charAt(position.x()); // // if(checkchar<91&&checkchar>64){ // return new Player(checkchar-65); //// System.out.print(checkchar); // } // if(checkchar<123&&checkchar>96){ // return new Box(checkchar-97); //// System.out.print(checkchar); // } // if(checkchar==46){ // return new Empty(); // } // if(checkchar==35){ // return new Wall(); // } // return new Empty(); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "137": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return originalMap.entityArr[position.y()][position.x()]; // String[] splited = originalMap.map.lines().toArray(String[]::new); //// System.out.print(map); // System.out.print(splited[position.y()+1].charAt(position.x())); // int checkchar = (int) splited[position.y()+1].charAt(position.x()); // // if(checkchar<91&&checkchar>64){ // return new Player(checkchar-65); //// System.out.print(checkchar); // } // if(checkchar<123&&checkchar>96){ // return new Box(checkchar-97); //// System.out.print(checkchar); // } // if(checkchar==46){ // return new Empty(); // } // if(checkchar==35){ // return new Wall(); // } // return new Empty(); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "138": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return originalMap.entityArr[position.y()][position.x()]; // String[] splited = originalMap.map.lines().toArray(String[]::new); //// System.out.print(map); // System.out.print(splited[position.y()+1].charAt(position.x())); // int checkchar = (int) splited[position.y()+1].charAt(position.x()); // // if(checkchar<91&&checkchar>64){ // return new Player(checkchar-65); //// System.out.print(checkchar); // } // if(checkchar<123&&checkchar>96){ // return new Box(checkchar-97); //// System.out.print(checkchar); // } // if(checkchar==46){ // return new Empty(); // } // if(checkchar==35){ // return new Wall(); // } // return new Empty(); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "139": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO System.out.print(inputLine); if (inputLine.equals(\"A\")||inputLine.equals('a')) return new Move.Left(0); if (inputLine.equals(\"D\")||inputLine.equals('d')) return new Move.Right(0); if (inputLine.equals(\"W\")||inputLine.equals('w')) return new Move.Up(0); if (inputLine.equals(\"S\")||inputLine.equals('s')) return new Move.Down(0); if (inputLine.equals(\"H\")||inputLine.equals('h')) return new Move.Left(1); if (inputLine.equals(\"L\")||inputLine.equals('l')) return new Move.Right(1); if (inputLine.equals(\"K\")||inputLine.equals('k')) return new Move.Up(1); if (inputLine.equals(\"J\")||inputLine.equals('j')) return new Move.Down(1); if (inputLine.equals(\"U\")||inputLine.equals('u')) return new Undo(1); if (inputLine.equals(\"exit\")||inputLine.equals(\"EXIT\")) return new Exit(1); // System.out.print(\"error\"); return new InvalidInput(0,INVALID_INPUT_MESSAGE); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "140": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO originalMap.entityArr[to.y()][to.x()]=originalMap.getEntity(from); originalMap.entityArr[from.y()][from.x()]=new Empty(); // Entity moving = originalMap.getEntity(from); originalMap.putEntity(to,moving); // System.out.print(\"111new map:\"); // System.out.print(originalMap.map); GameMap tempMap = originalMap; tempMap.putEntity(from,new Empty()); // System.out.print(\"222new map:\"); // System.out.print(tempMap.map); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "141": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO originalMap.entityArr[to.y()][to.x()]=originalMap.getEntity(from); originalMap.entityArr[from.y()][from.x()]=new Empty(); // Entity moving = originalMap.getEntity(from); originalMap.putEntity(to,moving); // System.out.print(\"111new map:\"); // System.out.print(originalMap.map); GameMap tempMap = originalMap; tempMap.putEntity(from,new Empty()); // System.out.print(\"222new map:\"); // System.out.print(tempMap.map); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i=1; i<originalMap.height;i++){ for(int j=0; j<originalMap.width; j++){ if (originalMap.entityArr[i][j] instanceof Player){ if (((Player) originalMap.entityArr[i][j]).getId()==id){ return new Position(j,i); } } } } // String[] splited = originalMap.map.lines().toArray(String[]::new); // System.out.print(splited.length); // int undoLimit = Integer.parseInt(splited[0]); // int height = splited.length-1; // int width = splited[1].length(); // // for (int i=1; i<height; i++){ // for(int j=0; j<width; j++){ // int checkchar = (int) splited[i].charAt(j); // if(checkchar==(id+65)){ // return new Position(j,i-1); // } // // } // } throw new NotImplementedException(); }",
        "label": "P"
    },
    "142": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO originalMap.entityArr[to.y()][to.x()]=originalMap.getEntity(from); originalMap.entityArr[from.y()][from.x()]=new Empty(); // Entity moving = originalMap.getEntity(from); originalMap.putEntity(to,moving); // System.out.print(\"111new map:\"); // System.out.print(originalMap.map); GameMap tempMap = originalMap; tempMap.putEntity(from,new Empty()); // System.out.print(\"222new map:\"); // System.out.print(tempMap.map); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i=1; i<originalMap.height;i++){ for(int j=0; j<originalMap.width; j++){ if (originalMap.entityArr[i][j] instanceof Player){ if (((Player) originalMap.entityArr[i][j]).getId()==id){ return new Position(j,i); } } } } // String[] splited = originalMap.map.lines().toArray(String[]::new); // System.out.print(splited.length); // int undoLimit = Integer.parseInt(splited[0]); // int height = splited.length-1; // int width = splited[1].length(); // // for (int i=1; i<height; i++){ // for(int j=0; j<width; j++){ // int checkchar = (int) splited[i].charAt(j); // if(checkchar==(id+65)){ // return new Position(j,i-1); // } // // } // } throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return originalMap.entityArr[position.y()][position.x()]; // String[] splited = originalMap.map.lines().toArray(String[]::new); //// System.out.print(map); // System.out.print(splited[position.y()+1].charAt(position.x())); // int checkchar = (int) splited[position.y()+1].charAt(position.x()); // // if(checkchar<91&&checkchar>64){ // return new Player(checkchar-65); //// System.out.print(checkchar); // } // if(checkchar<123&&checkchar>96){ // return new Box(checkchar-97); //// System.out.print(checkchar); // } // if(checkchar==46){ // return new Empty(); // } // if(checkchar==35){ // return new Wall(); // } // return new Empty(); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "143": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO Optional<Integer> undo = Optional.of(undoLeft); if (undoLeft==-1) return Optional.empty(); return undo; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "144": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO String[] splited = originalMap.map.lines().toArray(String[]::new); System.out.print(splited.length); int undoLimit = Integer.parseInt(splited[0]); int height = splited.length-1; int width = splited[1].length(); Set<Position> playerPosition = new HashSet<Position>(); for (int i=1; i<height; i++){ for(int j=0; j<width; j++){ if (originalMap.entityArr[i][j] instanceof Player){ playerPosition.add(new Position(j,i)); } // int checkchar = (int) splited[i].charAt(j); // if(checkchar<91&&checkchar>64){ // playerPosition.add(new Position(j,i-1)); // } } } return playerPosition; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "145": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO originalMap.entityArr[to.y()][to.x()]=originalMap.getEntity(from); originalMap.entityArr[from.y()][from.x()]=new Empty(); // Entity moving = originalMap.getEntity(from); originalMap.putEntity(to,moving); // System.out.print(\"111new map:\"); // System.out.print(originalMap.map); GameMap tempMap = originalMap; tempMap.putEntity(from,new Empty()); // System.out.print(\"222new map:\"); // System.out.print(tempMap.map); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO Entity[][] temp = new Entity[originalMap.height][originalMap.width]; System.out.print(originalMap.height+\"\"); for (int i=0; i<originalMap.height; i++){ for(int j=0; j<originalMap.width; j++){ temp[i][j]=originalMap.entityArr[i][j]; } } history.add(temp); // System.out.print(\"history: \"+ history); // throw new NotImplementedException(); } public void undo() { // TODO int historyNum = history.size(); // System.out.print(\"historysize: \"+ historyNum); // if(history.get(0).equals(history.get(1)))System.out.print(\"equalssss\"); // else System.out.print(\"notequal\"); // System.out.print(\"old history: \"+ originalMap.entityArr); for (int i=0; i<4; i++){ for (int j=0; j<6; j++){ System.out.print(history.get(0)[i][j]); } System.out.print(System.lineSeparator()); } originalMap.entityArr=history.get(historyNum-2); // System.out.print(\"new history: \"+ originalMap.entityArr); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(1)[i][j]); // } // System.out.print(System.lineSeparator()); // } undoLeft-=1; // throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i=1; i<originalMap.height;i++){ for(int j=0; j<originalMap.width; j++){ if (originalMap.entityArr[i][j] instanceof Player){ if (((Player) originalMap.entityArr[i][j]).getId()==id){ return new Position(j,i); } } } } // String[] splited = originalMap.map.lines().toArray(String[]::new); // System.out.print(splited.length); // int undoLimit = Integer.parseInt(splited[0]); // int height = splited.length-1; // int width = splited[1].length(); // // for (int i=1; i<height; i++){ // for(int j=0; j<width; j++){ // int checkchar = (int) splited[i].charAt(j); // if(checkchar==(id+65)){ // return new Position(j,i-1); // } // // } // } throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return originalMap.entityArr[position.y()][position.x()]; // String[] splited = originalMap.map.lines().toArray(String[]::new); //// System.out.print(map); // System.out.print(splited[position.y()+1].charAt(position.x())); // int checkchar = (int) splited[position.y()+1].charAt(position.x()); // // if(checkchar<91&&checkchar>64){ // return new Player(checkchar-65); //// System.out.print(checkchar); // } // if(checkchar<123&&checkchar>96){ // return new Box(checkchar-97); //// System.out.print(checkchar); // } // if(checkchar==46){ // return new Empty(); // } // if(checkchar==35){ // return new Wall(); // } // return new Empty(); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO Optional<Integer> undo = Optional.of(undoLeft); if (undoLeft==-1) return Optional.empty(); return undo; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "146": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new NotImplementedException(); } public void run() { // TODO while (!shouldStop()){ renderingEngine.render(this.state); inputEngine.fetchAction(); } // throw new NotImplementedException(); }",
        "label": "F"
    },
    "147": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new NotImplementedException(); }",
        "label": "P"
    },
    "148": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. System.out.print(outputSteam); System.out.printf(content); outputSteam.append(content); outputSteam.append(System.lineSeparator()); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "149": {
        "dataset": "COMP 3021",
        "project": "yclamam",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = map; undoLeft=map.undo; // history = new ArrayList<Entity[][]>(); Entity[][] temp = new Entity[map.height][map.width]; System.out.print(map.height+\"\"); for (int i=0; i<map.height; i++){ for(int j=0; j<map.width; j++){ temp[i][j]=map.entityArr[i][j]; } } history.add(temp); // System.out.print(\"originalmap:\"+temp); // for (int i=0; i<4; i++){ // for (int j=0; j<6; j++){ // System.out.print(history.get(0)[i][j]); // } // System.out.print(System.lineSeparator()); // } // throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "150": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; //throw new NotImplementedException(); } public int getMaxHeight() { // TODO return this.maxHeight; //throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); //Optional.ofNullable(Integer.valueOf(this.undoLimit)); //potential problem //throw new NotImplementedException(); }",
        "label": "P"
    },
    "151": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "152": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "153": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "154": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "155": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "156": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(currentMap.get(position.y()).length() <= position.x()){return null;}; switch(currentMap.get(position.y()).charAt(position.x())) { case '#': // code block return new Wall(); //break; case '.': // code block return new Empty(); //break; case '@': // code block return new Empty();//this.mapArrayList.get(position.y()).charAt(position.x())) //break; case ' ': return null; default: if(Character.isUpperCase(currentMap.get(position.y()).charAt(position.x()))) {return new Player((int)(currentMap.get(position.y()).charAt(position.x()) - 'A'));} else if (Character.isLowerCase(currentMap.get(position.y()).charAt(position.x()))) { return new Box((int)(currentMap.get(position.y()).charAt(position.x()) - 'a')); } }; return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "157": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(currentMap.get(position.y()).length() <= position.x()){return null;}; switch(currentMap.get(position.y()).charAt(position.x())) { case '#': // code block return new Wall(); //break; case '.': // code block return new Empty(); //break; case '@': // code block return new Empty();//this.mapArrayList.get(position.y()).charAt(position.x())) //break; case ' ': return null; default: if(Character.isUpperCase(currentMap.get(position.y()).charAt(position.x()))) {return new Player((int)(currentMap.get(position.y()).charAt(position.x()) - 'A'));} else if (Character.isLowerCase(currentMap.get(position.y()).charAt(position.x()))) { return new Box((int)(currentMap.get(position.y()).charAt(position.x()) - 'a')); } }; return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "158": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "159": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "160": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO //return this.map.destination; return this.map.getDestinations(); //throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(currentMap.get(position.y()).length() <= position.x()){return null;}; switch(currentMap.get(position.y()).charAt(position.x())) { case '#': // code block return new Wall(); //break; case '.': // code block return new Empty(); //break; case '@': // code block return new Empty();//this.mapArrayList.get(position.y()).charAt(position.x())) //break; case ' ': return null; default: if(Character.isUpperCase(currentMap.get(position.y()).charAt(position.x()))) {return new Player((int)(currentMap.get(position.y()).charAt(position.x()) - 'A'));} else if (Character.isLowerCase(currentMap.get(position.y()).charAt(position.x()))) { return new Box((int)(currentMap.get(position.y()).charAt(position.x()) - 'a')); } }; return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "161": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(currentMap.get(position.y()).length() <= position.x()){return null;}; switch(currentMap.get(position.y()).charAt(position.x())) { case '#': // code block return new Wall(); //break; case '.': // code block return new Empty(); //break; case '@': // code block return new Empty();//this.mapArrayList.get(position.y()).charAt(position.x())) //break; case ' ': return null; default: if(Character.isUpperCase(currentMap.get(position.y()).charAt(position.x()))) {return new Player((int)(currentMap.get(position.y()).charAt(position.x()) - 'A'));} else if (Character.isLowerCase(currentMap.get(position.y()).charAt(position.x()))) { return new Box((int)(currentMap.get(position.y()).charAt(position.x()) - 'a')); } }; return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "162": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(currentMap.get(position.y()).length() <= position.x()){return null;}; switch(currentMap.get(position.y()).charAt(position.x())) { case '#': // code block return new Wall(); //break; case '.': // code block return new Empty(); //break; case '@': // code block return new Empty();//this.mapArrayList.get(position.y()).charAt(position.x())) //break; case ' ': return null; default: if(Character.isUpperCase(currentMap.get(position.y()).charAt(position.x()))) {return new Player((int)(currentMap.get(position.y()).charAt(position.x()) - 'A'));} else if (Character.isLowerCase(currentMap.get(position.y()).charAt(position.x()))) { return new Box((int)(currentMap.get(position.y()).charAt(position.x()) - 'a')); } }; return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "163": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(currentMap.get(position.y()).length() <= position.x()){return null;}; switch(currentMap.get(position.y()).charAt(position.x())) { case '#': // code block return new Wall(); //break; case '.': // code block return new Empty(); //break; case '@': // code block return new Empty();//this.mapArrayList.get(position.y()).charAt(position.x())) //break; case ' ': return null; default: if(Character.isUpperCase(currentMap.get(position.y()).charAt(position.x()))) {return new Player((int)(currentMap.get(position.y()).charAt(position.x()) - 'A'));} else if (Character.isLowerCase(currentMap.get(position.y()).charAt(position.x()))) { return new Box((int)(currentMap.get(position.y()).charAt(position.x()) - 'a')); } }; return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "164": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO switch (inputLine.toLowerCase()){ case \"w\":return new Move.Up(0); case \"a\":return new Move.Left(0); case \"s\":return new Move.Down(0); case \"d\":return new Move.Right(0); case \"h\":return new Move.Left(0); case \"j\":return new Move.Down(0); case \"k\":return new Move.Up(0); case \"l\":return new Move.Right(0); case \"u\":return new Undo(0); case \"exit\": return new Exit(0); } return null; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "165": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO if(Character.isLowerCase(currentMap.get(from.y()).charAt(from.x()))) { //this.checkpointMap = new ArrayList<>(this.currentMap); historyCheckPoints.add(new ArrayList<>(this.currentMap)); //System.out.println(\"I reached here, stored checkpoint =\"); //for (int i=0; i< historyCheckPoints.get(0);i++) //System.out.println(historyCheckPoints.get(0)); }; char objToBeMoved = this.currentMap.get(from.y()).charAt(from.x()); char[] tempString = currentMap.get(from.y()).toCharArray();//for horizontal char[] tempStringFrom = currentMap.get(from.y()).toCharArray(); // for vertical char[] tempStringTo = currentMap.get(to.y()).toCharArray(); if(from.y() == to.y()) //horizontal movement { tempString[to.x()] = objToBeMoved; tempString[from.x()]= '.'; this.currentMap.set(from.y(), String.valueOf(tempString)); } else if (from.y() != to.y()) { tempStringTo[from.x()] = objToBeMoved; tempStringFrom[from.x()] = '.'; this.currentMap.set(from.y(), String.valueOf(tempStringFrom)); this.currentMap.set(to.y(), String.valueOf(tempStringTo)); } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "166": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO if(Character.isLowerCase(currentMap.get(from.y()).charAt(from.x()))) { //this.checkpointMap = new ArrayList<>(this.currentMap); historyCheckPoints.add(new ArrayList<>(this.currentMap)); //System.out.println(\"I reached here, stored checkpoint =\"); //for (int i=0; i< historyCheckPoints.get(0);i++) //System.out.println(historyCheckPoints.get(0)); }; char objToBeMoved = this.currentMap.get(from.y()).charAt(from.x()); char[] tempString = currentMap.get(from.y()).toCharArray();//for horizontal char[] tempStringFrom = currentMap.get(from.y()).toCharArray(); // for vertical char[] tempStringTo = currentMap.get(to.y()).toCharArray(); if(from.y() == to.y()) //horizontal movement { tempString[to.x()] = objToBeMoved; tempString[from.x()]= '.'; this.currentMap.set(from.y(), String.valueOf(tempString)); } else if (from.y() != to.y()) { tempStringTo[from.x()] = objToBeMoved; tempStringFrom[from.x()] = '.'; this.currentMap.set(from.y(), String.valueOf(tempStringFrom)); this.currentMap.set(to.y(), String.valueOf(tempStringTo)); } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i=0; i<currentMap.size();i++) {//System.out.println(currentMap.get(i)); for(int j=0; j<currentMap.get(i).length();j++) { if( Character.isUpperCase(currentMap.get(i).charAt(j)) && (int)(currentMap.get(i).charAt(j) - 'A') == id ) { return new Position(j,i); }; }; }; return null; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "167": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO if(Character.isLowerCase(currentMap.get(from.y()).charAt(from.x()))) { //this.checkpointMap = new ArrayList<>(this.currentMap); historyCheckPoints.add(new ArrayList<>(this.currentMap)); //System.out.println(\"I reached here, stored checkpoint =\"); //for (int i=0; i< historyCheckPoints.get(0);i++) //System.out.println(historyCheckPoints.get(0)); }; char objToBeMoved = this.currentMap.get(from.y()).charAt(from.x()); char[] tempString = currentMap.get(from.y()).toCharArray();//for horizontal char[] tempStringFrom = currentMap.get(from.y()).toCharArray(); // for vertical char[] tempStringTo = currentMap.get(to.y()).toCharArray(); if(from.y() == to.y()) //horizontal movement { tempString[to.x()] = objToBeMoved; tempString[from.x()]= '.'; this.currentMap.set(from.y(), String.valueOf(tempString)); } else if (from.y() != to.y()) { tempStringTo[from.x()] = objToBeMoved; tempStringFrom[from.x()] = '.'; this.currentMap.set(from.y(), String.valueOf(tempStringFrom)); this.currentMap.set(to.y(), String.valueOf(tempStringTo)); } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i=0; i<currentMap.size();i++) {//System.out.println(currentMap.get(i)); for(int j=0; j<currentMap.get(i).length();j++) { if( Character.isUpperCase(currentMap.get(i).charAt(j)) && (int)(currentMap.get(i).charAt(j) - 'A') == id ) { return new Position(j,i); }; }; }; return null; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(currentMap.get(position.y()).length() <= position.x()){return null;}; switch(currentMap.get(position.y()).charAt(position.x())) { case '#': // code block return new Wall(); //break; case '.': // code block return new Empty(); //break; case '@': // code block return new Empty();//this.mapArrayList.get(position.y()).charAt(position.x())) //break; case ' ': return null; default: if(Character.isUpperCase(currentMap.get(position.y()).charAt(position.x()))) {return new Player((int)(currentMap.get(position.y()).charAt(position.x()) - 'A'));} else if (Character.isLowerCase(currentMap.get(position.y()).charAt(position.x()))) { return new Box((int)(currentMap.get(position.y()).charAt(position.x()) - 'a')); } }; return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "168": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO return Optional.of(this.remainingUndos); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "169": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> PlayerPositions = new HashSet<>(); for (int i=0; i<currentMap.size();i++) { for(int j=0; j<currentMap.get(i).length();j++) { if( Character.isUpperCase(currentMap.get(i).charAt(j)) ) { PlayerPositions.add(new Position(j,i)); }; }; }; return PlayerPositions; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "170": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO if(Character.isLowerCase(currentMap.get(from.y()).charAt(from.x()))) { //this.checkpointMap = new ArrayList<>(this.currentMap); historyCheckPoints.add(new ArrayList<>(this.currentMap)); //System.out.println(\"I reached here, stored checkpoint =\"); //for (int i=0; i< historyCheckPoints.get(0);i++) //System.out.println(historyCheckPoints.get(0)); }; char objToBeMoved = this.currentMap.get(from.y()).charAt(from.x()); char[] tempString = currentMap.get(from.y()).toCharArray();//for horizontal char[] tempStringFrom = currentMap.get(from.y()).toCharArray(); // for vertical char[] tempStringTo = currentMap.get(to.y()).toCharArray(); if(from.y() == to.y()) //horizontal movement { tempString[to.x()] = objToBeMoved; tempString[from.x()]= '.'; this.currentMap.set(from.y(), String.valueOf(tempString)); } else if (from.y() != to.y()) { tempStringTo[from.x()] = objToBeMoved; tempStringFrom[from.x()] = '.'; this.currentMap.set(from.y(), String.valueOf(tempStringFrom)); this.currentMap.set(to.y(), String.valueOf(tempStringTo)); } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO //this.checkpointMap = new ArrayList<>(this.currentMap); //throw new NotImplementedException(); } public void undo() { // TODO if(historyCheckPoints.size()!=0) { //this.currentMap = new ArrayList<>(this.checkpointMap);//this.checkpointMap; //System.out.println(historyCheckPoints.get(0)); this.currentMap = new ArrayList<>(historyCheckPoints.get(historyCheckPoints.size()-1)); this.remainingUndos -= 1; //System.out.println(historyCheckPoints.get(0)); historyCheckPoints.remove(historyCheckPoints.size()-1); } else if (historyCheckPoints.size() == 0) { this.currentMap = new ArrayList<>(this.map.mapArrayList); //System.out.println(\"hiiiiiiiii\"); //this.remainingUndos-=1; } //throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i=0; i<currentMap.size();i++) {//System.out.println(currentMap.get(i)); for(int j=0; j<currentMap.get(i).length();j++) { if( Character.isUpperCase(currentMap.get(i).charAt(j)) && (int)(currentMap.get(i).charAt(j) - 'A') == id ) { return new Position(j,i); }; }; }; return null; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(currentMap.get(position.y()).length() <= position.x()){return null;}; switch(currentMap.get(position.y()).charAt(position.x())) { case '#': // code block return new Wall(); //break; case '.': // code block return new Empty(); //break; case '@': // code block return new Empty();//this.mapArrayList.get(position.y()).charAt(position.x())) //break; case ' ': return null; default: if(Character.isUpperCase(currentMap.get(position.y()).charAt(position.x()))) {return new Player((int)(currentMap.get(position.y()).charAt(position.x()) - 'A'));} else if (Character.isLowerCase(currentMap.get(position.y()).charAt(position.x()))) { return new Box((int)(currentMap.get(position.y()).charAt(position.x()) - 'a')); } }; return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return Optional.of(this.remainingUndos); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "171": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if(gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); }; // Check the number of players //throw new NotImplementedException(); } public void run() { // TODO //int round =1; //boolean afterfirstround = false; renderingEngine.message(\"Sokoban game is ready.\"); //renderingEngine.render(this.state); //inputEngine.r Action temp =null; while (shouldStop()!= true) //this.state.isWin()!=true { renderingEngine.render(this.state); String stringQuota = String.valueOf(this.state.getUndoQuota()); stringQuota = stringQuota.replace(\"Optional[\",\"\"); stringQuota = stringQuota.replace(\"]\",\"\"); renderingEngine.message(\"Undo Quota: \"+ stringQuota);//\"Undo Quota: \"+String.valueOf(this.state.getUndoQuota()) renderingEngine.message(\">>>\"); temp = this.inputEngine.fetchAction(); //renderingEngine.render(state); // ActionResult actionResult = this.processAction(temp); //renderingEngine.render(state); // if(actionResult instanceof ActionResult.Success){continue;} else if (actionResult instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) actionResult).getReason()); } // // if(temp instanceof Exit){break;} //if(round ==3){break;}; //round += 1; }; renderingEngine.render(state); if(this.state.isWin()){ renderingEngine.message(\"Game exits.\"); renderingEngine.message(\"You win.\");} else {renderingEngine.message(\"Game exits.\");}; }",
        "label": "P"
    },
    "172": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if(gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); }; // Check the number of players //throw new NotImplementedException(); }",
        "label": "P"
    },
    "173": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO this.outputSteam.println(content); // Hint: System.out is also a PrintStream. //throw new NotImplementedException(); }",
        "label": "P"
    },
    "174": {
        "dataset": "COMP 3021",
        "project": "cowongab",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.currentMap = new ArrayList<>(map.mapArrayList); this.remainingUndos = map.undoLimit; this.checkpointMap = new ArrayList<>(currentMap); //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "175": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO System.out.println(\"getMaxWidth\"); return maxwidth; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO System.out.println(\"getMaxHeight\"); return maxheigth; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO System.out.println(\"getUndoLimit\"); // return undolimit; return Optional.of(undolimit); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "176": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "177": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "178": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "179": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "180": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "181": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "182": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "183": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO System.out.println(\"getMaxHeight\"); return maxheigth; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "184": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO System.out.println(\"getMaxWidth\"); return maxwidth; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "185": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.gameMap.getDestinations(); // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "186": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "187": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "188": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "189": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. System.out.println(\"type your input: \"); final var inputLine = terminalScanner.nextLine(); System.out.println(\"terminal\"); System.out.println(inputLine); if (inputLine.equals(\"exit\")){ // what is the initiator value return new Exit(0); } else if (inputLine.equals(\"A\")){ return new Move.Left(0); } else if (inputLine.equals(\"S\")){ return new Move.Down(0); } else if (inputLine.equals(\"W\")){ return new Move.Up(0); } else if (inputLine.equals(\"D\")){ return new Move.Right(0); } else if (inputLine.equals(\"H\")){ return new Move.Left(1); } else if (inputLine.equals(\"J\")){ return new Move.Down(1); } else if (inputLine.equals(\"K\")){ return new Move.Up(1); } else if (inputLine.equals(\"L\")){ return new Move.Right(1); } else if (inputLine.equals(\"U\")){ return new Undo(0); } // TODO throw new NotImplementedException(); }",
        "label": "P"
    },
    "190": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // this.checkpoint(); System.out.println(\"move\"); System.out.println(gameMap.getEntity(from)); System.out.print(to.x()); System.out.println(to.y()); GameMap.mapArray[to.y()][to.x()]=this.gameMap.getEntity(from); GameMap.mapArray[from.y()][from.x()]=new Empty(); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "191": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // this.checkpoint(); System.out.println(\"move\"); System.out.println(gameMap.getEntity(from)); System.out.print(to.x()); System.out.println(to.y()); GameMap.mapArray[to.y()][to.x()]=this.gameMap.getEntity(from); GameMap.mapArray[from.y()][from.x()]=new Empty(); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO Entity [][] arrayMap = this.gameMap.getArrayMap(); for ( int row =0; row <this.gameMap.getMaxHeight(); row ++ ){ for (int col = 0 ; col < this.gameMap.getMaxWidth(); col ++){ if (arrayMap[row][col] instanceof Player ){ Player currPlayer=(Player)arrayMap[row][col]; if (currPlayer.getId() == id){ return new Position(col, row); } } } } return new Position(0, 0); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "192": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // this.checkpoint(); System.out.println(\"move\"); System.out.println(gameMap.getEntity(from)); System.out.print(to.x()); System.out.println(to.y()); GameMap.mapArray[to.y()][to.x()]=this.gameMap.getEntity(from); GameMap.mapArray[from.y()][from.x()]=new Empty(); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO Entity [][] arrayMap = this.gameMap.getArrayMap(); for ( int row =0; row <this.gameMap.getMaxHeight(); row ++ ){ for (int col = 0 ; col < this.gameMap.getMaxWidth(); col ++){ if (arrayMap[row][col] instanceof Player ){ Player currPlayer=(Player)arrayMap[row][col]; if (currPlayer.getId() == id){ return new Position(col, row); } } } } return new Position(0, 0); // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "193": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO // Optional<Integer> undoLimit = Optional.of(undolimit); return Optional.of(undoQuota); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "194": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> allPlayer = new HashSet<> (); for (int i = 0; i < 26; i++){ if (GameMap.players[i]) allPlayer.add(this.getPlayerPositionById(i)); } return allPlayer; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "195": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // this.checkpoint(); System.out.println(\"move\"); System.out.println(gameMap.getEntity(from)); System.out.print(to.x()); System.out.println(to.y()); GameMap.mapArray[to.y()][to.x()]=this.gameMap.getEntity(from); GameMap.mapArray[from.y()][from.x()]=new Empty(); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO History curr = new History(undoQuota); this.gameMap.historyArray.add(curr); // throw new NotImplementedException(); } public void undo() { // TODO undoQuota --; System.out.println(\"undo\"); System.out.println(GameMap.mapArray[3][1]); History last_history; if (this.gameMap.historyArray.size()==0){ for (int i = 0; i < GameMap.mapArray.length; i ++ ){ for (int j = 0; j < GameMap.mapArray[0].length ; j ++){ GameMap.original_mapArray [i][j] = GameMap.mapArray[i][j]; } } } if (this.gameMap.historyArray.size() ==1){ System.out.println(\"revert to original map\"); for (int i = 0; i < GameMap.mapArray.length; i ++ ){ for (int j = 0; j < GameMap.mapArray[0].length ; j ++){ GameMap.mapArray[i][j] = GameMap.original_mapArray [i][j]; } } } else{ last_history = this.gameMap.historyArray.get(this.gameMap.historyArray.size()-2); Entity [][] lastEntity = last_history.arrayMap(); for (int i = 0; i < GameMap.mapArray.length; i ++ ){ for (int j = 0; j < GameMap.mapArray[0].length ; j ++){ GameMap.mapArray[i][j] = lastEntity [i][j]; } } } this.gameMap.historyArray.remove(this.gameMap.historyArray.size()-1); System.out.println(\"undo\"); // throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO Entity [][] arrayMap = this.gameMap.getArrayMap(); for ( int row =0; row <this.gameMap.getMaxHeight(); row ++ ){ for (int col = 0 ; col < this.gameMap.getMaxWidth(); col ++){ if (arrayMap[row][col] instanceof Player ){ Player currPlayer=(Player)arrayMap[row][col]; if (currPlayer.getId() == id){ return new Position(col, row); } } } } return new Position(0, 0); // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.gameMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO // Optional<Integer> undoLimit = Optional.of(undolimit); return Optional.of(undoQuota); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "196": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO System.out.println(\"construct\"); int count =0; for (int i = 0; i < GameMap.mapArray.length; i ++ ){ for (int j = 0; j < GameMap.mapArray[0].length ; j ++){ if (GameMap.mapArray[i][j] instanceof Player){ count++; if (count >= 3){ throw new IllegalArgumentException(); } } } } // Check the number of players } public void run() { // TODO //while ! stop, render, input engine while(!shouldStop()){ renderingEngine.render(this.state); System.out.println(this.state); processAction(inputEngine.fetchAction()); System.out.println(\"end\"); } // throw new NotImplementedException(); }",
        "label": "F"
    },
    "197": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO System.out.println(\"construct\"); int count =0; for (int i = 0; i < GameMap.mapArray.length; i ++ ){ for (int j = 0; j < GameMap.mapArray[0].length ; j ++){ if (GameMap.mapArray[i][j] instanceof Player){ count++; if (count >= 3){ throw new IllegalArgumentException(); } } } } // Check the number of players }",
        "label": "P"
    },
    "198": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO outputSteam.println(content); // Hint: System.out is also a PrintStream. // throw new NotImplementedException(); }",
        "label": "P"
    },
    "199": {
        "dataset": "COMP 3021",
        "project": "wychowac",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; undoQuota = map.undolimit; // throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "200": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO Optional<Integer> undoNum = Optional.of(this.undoLimit); return undoNum; }",
        "label": "P"
    },
    "201": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "202": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "203": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "204": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "205": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "206": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public ArrayList<ArrayList<Entity>> getEntityLocations() { return this.entityLocations; } public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "207": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public ArrayList<ArrayList<Entity>> getEntityLocations() { return this.entityLocations; } public int getId() { return id; }",
        "label": "P"
    },
    "208": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "209": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "210": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public ArrayList<ArrayList<Entity>> getEntityLocations() { return this.entityLocations; }",
        "label": "P"
    },
    "211": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public ArrayList<ArrayList<Entity>> getEntityLocations() { return this.entityLocations; }",
        "label": "P"
    },
    "212": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public ArrayList<ArrayList<Entity>> getEntityLocations() { return this.entityLocations; }",
        "label": "P"
    },
    "213": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public ArrayList<ArrayList<Entity>> getEntityLocations() { return this.entityLocations; }",
        "label": "P"
    },
    "214": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO String lowerCaseInputLine = inputLine.toLowerCase(); if(lowerCaseInputLine.equals(\"exit\")) { return new Exit(-1); } if(inputLine.length() > 1 || inputLine.length() <= 0) return new InvalidInput(-1,\"Invalid Input.\"); char letter = lowerCaseInputLine.charAt(0); if(letter == 'a') return new Move.Left(0); else if(letter == 's') return new Move.Down(0); else if(letter == 'w') return new Move.Up(0); else if(letter == 'd') return new Move.Right(0); else if(letter == 'h') return new Move.Left(1); else if(letter == 'j') return new Move.Down(1); else if(letter == 'k') return new Move.Up(1); else if(letter == 'l') return new Move.Right(1); else if(letter == 'u') return new Undo(-1); else return new InvalidInput(-1,\"Invalid Input\"); }",
        "label": "P"
    },
    "215": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public void move(Position from, Position to) { // TODO Entity fromEntity = this.getEntity(from); entityLocations.get(to.y()).set(to.x(),fromEntity); entityLocations.get(from.y()).set(from.x(),new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "216": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public void move(Position from, Position to) { // TODO Entity fromEntity = this.getEntity(from); entityLocations.get(to.y()).set(to.x(),fromEntity); entityLocations.get(from.y()).set(from.x(),new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int y = 0; y < entityLocations.size(); y++) { for(int x = 0; x < entityLocations.get(y).size(); x++) { Entity e = entityLocations.get(y).get(x); if(e instanceof Player){ Player player = (Player) e; if(player.getId() == id) return Position.of(x,y); } } } return null; }",
        "label": "P"
    },
    "217": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public void move(Position from, Position to) { // TODO Entity fromEntity = this.getEntity(from); entityLocations.get(to.y()).set(to.x(),fromEntity); entityLocations.get(from.y()).set(from.x(),new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int y = 0; y < entityLocations.size(); y++) { for(int x = 0; x < entityLocations.get(y).size(); x++) { Entity e = entityLocations.get(y).get(x); if(e instanceof Player){ Player player = (Player) e; if(player.getId() == id) return Position.of(x,y); } } } return null; } public ArrayList<ArrayList<Entity>> getEntityLocations() { return this.entityLocations; }",
        "label": "P"
    },
    "218": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public Optional<Integer> getUndoQuota() { // TODO if(undoQuota.equals(Optional.of(-1))) return Optional.empty(); else return undoQuota; }",
        "label": "P"
    },
    "219": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> playerList = new HashSet<Position>(); for(int y = 0; y < entityLocations.size(); y++) { for(int x = 0; x < entityLocations.get(y).size(); x++) { Entity e = entityLocations.get(y).get(x); if(e instanceof Player) { playerList.add(Position.of(x,y)); } } } return playerList; }",
        "label": "P"
    },
    "220": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public void move(Position from, Position to) { // TODO Entity fromEntity = this.getEntity(from); entityLocations.get(to.y()).set(to.x(),fromEntity); entityLocations.get(from.y()).set(from.x(),new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO this.moveHistory.add(this.cloneEntityLocations(this.entityLocations)); } public void undo() { // TODO if(moveHistory.size() == 0){ this.entityLocations = this.cloneEntityLocations(map.entityLocations); } else if(moveHistory.size() == 1) { this.entityLocations = this.cloneEntityLocations(map.entityLocations); //conduct arithmetic on the undoQuota (if necessary) if(undoQuota.isPresent()){ int newUndoQuota = this.undoQuota.get(); newUndoQuota--; this.undoQuota = Optional.of(newUndoQuota); } } else{ //conduct arithmetic on the undoQuota (if necessary) if(undoQuota.isPresent()){ int newUndoQuota = this.undoQuota.get(); newUndoQuota--; this.undoQuota = Optional.of(newUndoQuota); } //revert the gamestate to the latest snapchat this.entityLocations = this.cloneEntityLocations(moveHistory.get(moveHistory.size()-2)); //remove the last snapshot from the moveHistory moveHistory.remove(moveHistory.size()-1); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for(int y = 0; y < entityLocations.size(); y++) { for(int x = 0; x < entityLocations.get(y).size(); x++) { Entity e = entityLocations.get(y).get(x); if(e instanceof Player){ Player player = (Player) e; if(player.getId() == id) return Position.of(x,y); } } } return null; } public ArrayList<ArrayList<Entity>> getEntityLocations() { return this.entityLocations; } public Optional<Integer> getUndoQuota() { // TODO if(undoQuota.equals(Optional.of(-1))) return Optional.empty(); else return undoQuota; }",
        "label": "P"
    },
    "221": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } } public void run() { // TODO renderingEngine.render(state); String quotaMessage = \"\"; if(state.getUndoQuota().equals(Optional.empty())) quotaMessage = \"Undo Quota: Infinity\"; else if(state.getUndoQuota().isPresent() && state.getUndoQuota().get() >= 0) quotaMessage = \"Undo Quota: \" + state.getUndoQuota().get(); else quotaMessage = \"Undo Quota: 0\"; renderingEngine.message(quotaMessage); renderingEngine.message(\">>>\"); while(!shouldStop()) { quotaMessage = \"\"; if(state.getUndoQuota().equals(Optional.empty())) quotaMessage = \"Undo Quota: Infinity\"; else if(state.getUndoQuota().isPresent() && state.getUndoQuota().get() >= 0) quotaMessage = \"Undo Quota: \" + state.getUndoQuota().get(); else quotaMessage = \"Undo Quota: 0\"; renderingEngine.message(quotaMessage); renderingEngine.message(\">>>\"); } }",
        "label": "P"
    },
    "222": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "223": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. String str = content.concat(System.lineSeparator()); this.outputSteam.print(str); }",
        "label": "P"
    },
    "224": {
        "dataset": "COMP 3021",
        "project": "kwwongbw",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.entityLocations = cloneEntityLocations(map.entityLocations); this.undoQuota = map.getUndoLimit(); this.moveHistory = new ArrayList<ArrayList<ArrayList<Entity>>>(); //this.currentPlayerLocation = new ArrayList<Player>(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { final var builder = new StringBuilder(); for (int y = 0; y < state.getEntityLocations().size(); y++) { for (int x = 0; x < state.getEntityLocations().get(y).size(); x++) { final var entity = state.getEntity(Position.of(x, y)); String charToPrint = \"\"; // TODO switch(entity) { case Wall ignored: charToPrint = \"#\"; break; case Box b: charToPrint = Character.toString((char)('a' + b.getPlayerId())); break; case Player p: charToPrint = Character.toString((char)('A' + p.getId())); break; case Empty ignored: charToPrint = \".\"; for(Position position: state.getDestinations()){ if(position.x() == x && position.y() == y) { charToPrint = \"@\"; break; } } break; case null: charToPrint = \" \"; break; } builder.append(charToPrint); } builder.append('\\n'); } outputSteam.print(builder); }",
        "label": "P"
    },
    "225": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; } public int getMaxHeight() { // TODO return maxHeight; } public Optional<Integer> getUndoLimit() { // TODO if(undoLimit >= 0){ return Optional.of(undoLimit); } else{ return Optional.empty(); } }",
        "label": "P"
    },
    "226": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "227": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "228": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "229": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "230": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "231": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entitiesMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "232": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entitiesMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "233": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; }",
        "label": "P"
    },
    "234": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; }",
        "label": "P"
    },
    "235": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entitiesMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "236": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entitiesMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "237": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entitiesMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "238": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entitiesMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "239": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. String inputLine = terminalScanner.nextLine().toLowerCase(); // TODO Action result = switch (inputLine) { case \"w\" -> new Move.Up(0); case \"a\" -> new Move.Left(0); case \"s\" -> new Move.Down(0); case \"d\" -> new Move.Right(0); case \"h\" -> new Move.Left(1); case \"j\" -> new Move.Down(1); case \"k\" -> new Move.Up(1); case \"l\" -> new Move.Right(1); case \"u\" -> new Undo(0); case \"exit\" -> new Exit(0); default -> new InvalidInput(0,\"Invalid Input.\"); }; return result; }",
        "label": "P"
    },
    "240": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public void move(Position from, Position to) { // TODO if(entitiesMap[from.y()][from.x()] instanceof Box){ //need to change boxPosition when move box if(!boxPosition.remove(from)){ throw new RuntimeException(); } boxPosition.add(to); } else if(entitiesMap[from.y()][from.x()] instanceof Player){ //change playerPosition when move player playerPosition.replace(((Player)entitiesMap[from.y()][from.x()]).getId(), to); } entitiesMap[to.y()][to.x()] = entitiesMap[from.y()][from.x()]; entitiesMap[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "241": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public void move(Position from, Position to) { // TODO if(entitiesMap[from.y()][from.x()] instanceof Box){ //need to change boxPosition when move box if(!boxPosition.remove(from)){ throw new RuntimeException(); } boxPosition.add(to); } else if(entitiesMap[from.y()][from.x()] instanceof Player){ //change playerPosition when move player playerPosition.replace(((Player)entitiesMap[from.y()][from.x()]).getId(), to); } entitiesMap[to.y()][to.x()] = entitiesMap[from.y()][from.x()]; entitiesMap[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return playerPosition.get(id); }",
        "label": "P"
    },
    "242": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public void move(Position from, Position to) { // TODO if(entitiesMap[from.y()][from.x()] instanceof Box){ //need to change boxPosition when move box if(!boxPosition.remove(from)){ throw new RuntimeException(); } boxPosition.add(to); } else if(entitiesMap[from.y()][from.x()] instanceof Player){ //change playerPosition when move player playerPosition.replace(((Player)entitiesMap[from.y()][from.x()]).getId(), to); } entitiesMap[to.y()][to.x()] = entitiesMap[from.y()][from.x()]; entitiesMap[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return playerPosition.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entitiesMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "243": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public Optional<Integer> getUndoQuota() { // TODO return undoQuota; }",
        "label": "P"
    },
    "244": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> temp = new HashSet<Position>(); temp.addAll(playerPosition.values()); return temp; }",
        "label": "P"
    },
    "245": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public void move(Position from, Position to) { // TODO if(entitiesMap[from.y()][from.x()] instanceof Box){ //need to change boxPosition when move box if(!boxPosition.remove(from)){ throw new RuntimeException(); } boxPosition.add(to); } else if(entitiesMap[from.y()][from.x()] instanceof Player){ //change playerPosition when move player playerPosition.replace(((Player)entitiesMap[from.y()][from.x()]).getId(), to); } entitiesMap[to.y()][to.x()] = entitiesMap[from.y()][from.x()]; entitiesMap[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO moveHistory.push(new CheckPointData(entitiesMap,boxPosition,playerPosition)); } public void undo() { // TODO if(!moveHistory.empty()){ if(undoQuota.isPresent()){ undoQuota = Optional.of(undoQuota.get()-1); } moveHistory.pop(); //remove the last checkpoint record } if(!(moveHistory.empty())){ entitiesMap = moveHistory.peek().getEntitiesMap(); //restore data from the top element of the stack boxPosition = moveHistory.peek().getBoxPosition(); playerPosition = moveHistory.peek().getPlayerPosition(); } else{ CheckPointData initialRecord = new CheckPointData(gameMap.getMap(),gameMap.getBoxPosition(), gameMap.getPlayerPosition()); entitiesMap = initialRecord.getEntitiesMap(); //restore data from initial status boxPosition = initialRecord.getBoxPosition(); playerPosition = initialRecord.getPlayerPosition(); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO return playerPosition.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entitiesMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return undoQuota; }",
        "label": "P"
    },
    "246": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } } public void run() { // TODO renderingEngine.message(\"Sokoban game is ready.\"); while(!shouldStop()) { renderingEngine.render(state); renderingEngine.message(\"\"); if(state.getUndoQuota().isEmpty()){ renderingEngine.message(\"Unlimited\"); } else{ renderingEngine.message(\"Undo Quota: \" + String.valueOf(state.getUndoQuota().get())); } Action action = inputEngine.fetchAction(); ActionResult result = processAction(action); if(result instanceof ActionResult.Failed f){ renderingEngine.message(f.getReason()); } else{ renderingEngine.message(\"\"); } } renderingEngine.render(state); renderingEngine.message(\"\"); renderingEngine.message(\"Game exits.\"); if(state.isWin()){ renderingEngine.message(\"You win.\"); } }",
        "label": "P"
    },
    "247": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "248": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "249": {
        "dataset": "COMP 3021",
        "project": "tckwanac",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.entitiesMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int i = 0; i < map.getMaxHeight(); i++){ this.entitiesMap[i] = map.getMap()[i].clone(); } this.boxPosition = new HashSet<Position>(map.getBoxPosition()); this.playerPosition = new HashMap<Integer,Position>(map.getPlayerPosition()); this.moveHistory = new Stack<CheckPointData>(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "250": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO return height; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO if (undoLimit==-1) return Optional.empty(); return Optional.of(undoLimit); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "251": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "252": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "253": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "254": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "255": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "256": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x()>=width || position.y()>=height) return null; return entityArr[position.y()][position.x()]; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "257": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x()>=width || position.y()>=height) return null; return entityArr[position.y()][position.x()]; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "258": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "259": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "260": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x()>=width || position.y()>=height) return null; return entityArr[position.y()][position.x()]; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "261": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x()>=width || position.y()>=height) return null; return entityArr[position.y()][position.x()]; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "262": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x()>=width || position.y()>=height) return null; return entityArr[position.y()][position.x()]; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "263": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x()>=width || position.y()>=height) return null; return entityArr[position.y()][position.x()]; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "264": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); if (inputLine.toLowerCase().equals(\"exit\")) return new Exit(-1); if (inputLine.length()==1) { if (\"wasd\".indexOf(inputLine.toLowerCase())!=-1){ switch (inputLine.toLowerCase().charAt(0)) { case 'w': return new Move.Up(0); case 'a': return new Move.Left(0); case 's': return new Move.Down(0); default: return new Move.Right(0); } } else if ((\"hjkl\".indexOf(inputLine.toLowerCase())!=-1)) { switch (inputLine.toLowerCase().charAt(0)) { case 'k': return new Move.Up(1); case 'h': return new Move.Left(1); case 'j': return new Move.Down(1); default: return new Move.Right(1); } } else if (inputLine.toLowerCase().equals(\"u\")) return new Undo(-1); } return new InvalidInput(-1,INVALID_INPUT_MESSAGE); // TODO // throw new NotImplementedException(); }",
        "label": "P"
    },
    "265": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity e=entityArr[from.y()][from.x()]; entityArr[to.y()][to.x()]=e; entityArr[from.y()][from.x()]=new Empty(); if (e instanceof Player o) players.put(o.getId(), Position.of(to.x(),to.y())); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "266": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity e=entityArr[from.y()][from.x()]; entityArr[to.y()][to.x()]=e; entityArr[from.y()][from.x()]=new Empty(); if (e instanceof Player o) players.put(o.getId(), Position.of(to.x(),to.y())); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if (players.get(id)!=null) return Position.of(players.get(id).x(),players.get(id).y()); return null; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "267": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity e=entityArr[from.y()][from.x()]; entityArr[to.y()][to.x()]=e; entityArr[from.y()][from.x()]=new Empty(); if (e instanceof Player o) players.put(o.getId(), Position.of(to.x(),to.y())); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if (players.get(id)!=null) return Position.of(players.get(id).x(),players.get(id).y()); return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x()>=width || position.y()>=height) return null; return entityArr[position.y()][position.x()]; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "268": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); }// public Optional<Integer> getUndoQuota(){ // return undoQuota; // }",
        "label": "P"
    },
    "269": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> pos=new HashSet<Position>(); for (var i: players.values()){ pos.add(Position.of(i.x(),i.y())); } return pos; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "270": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity e=entityArr[from.y()][from.x()]; entityArr[to.y()][to.x()]=e; entityArr[from.y()][from.x()]=new Empty(); if (e instanceof Player o) players.put(o.getId(), Position.of(to.x(),to.y())); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO history.push(new Checkpoint(entityArr,players)); // throw new NotImplementedException(); } public void undo() { if (undoQuota.isPresent() && undoQuota.get()<=0) return; if (!history.isEmpty()) { history.pop(); if (undoQuota.isPresent()) undoQuota=Optional.of(undoQuota.get()-1); } if (!history.isEmpty()) { Checkpoint c = history.peek(); entityArr = c.getEntityArr(); players=c.getPlayerMap(); } else{ entityArr=map.getEntityArr(); players=map.getPlayerMap(); } // TODO // throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO if (players.get(id)!=null) return Position.of(players.get(id).x(),players.get(id).y()); return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x()>=width || position.y()>=height) return null; return entityArr[position.y()][position.x()]; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}// public Optional<Integer> getUndoQuota(){ // return undoQuota; // }",
        "label": "P"
    },
    "271": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if (gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); // Check the number of players // throw new NotImplementedException(); } public void run() { renderingEngine.message(GAME_READY_MESSAGE); renderingEngine.render(state); while (!shouldStop()){ if (state.getUndoQuota().isEmpty()) renderingEngine.message(UNDO_QUOTA_UNLIMITED); else renderingEngine.message(String.format(UNDO_QUOTA_TEMPLATE,state.getUndoQuota().get())); renderingEngine.message(\">>>\"); Action input=inputEngine.fetchAction(); ActionResult result=processAction(input); if (result instanceof ActionResult.Failed f) renderingEngine.message(f.getReason()); renderingEngine.render(state); } renderingEngine.message(GAME_EXIT_MESSAGE); if (state.isWin()) renderingEngine.message(WIN_MESSAGE); // TODO // throw new NotImplementedException(); }",
        "label": "P"
    },
    "272": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if (gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); // Check the number of players // throw new NotImplementedException(); }",
        "label": "P"
    },
    "273": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.print(content+System.lineSeparator()); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "274": {
        "dataset": "COMP 3021",
        "project": "ythau",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; history=new Stack<Checkpoint>(); undoQuota=map.getUndoLimit(); this.players=map.getPlayerMap(); // this.boxes=map.getBoxMap(); this.entityArr=map.getEntityArr(); width=map.getMaxWidth(); height=map.getMaxHeight(); // throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "275": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; } public int getMaxHeight() { // TODO return height; } public Optional<Integer> getUndoLimit() { // TODO Optional<Integer> undo = Optional.of(undoLimit); return undo; }",
        "label": "P"
    },
    "276": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "277": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "278": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "279": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "280": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "281": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "282": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "283": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; }",
        "label": "P"
    },
    "284": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; }",
        "label": "P"
    },
    "285": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "286": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "287": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "288": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "289": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. //TODO final var inputLine = terminalScanner.nextLine(); switch (inputLine) { case StringResources.EXIT_COMMAND_TEXT: return new Exit(0); case \"u\",\"U\": return new Undo(0); case \"W\",\"w\": return new Move.Up(0); case \"A\",\"a\": return new Move.Left(0); case \"S\", \"s\": return new Move.Down(0); case \"D\",\"d\": return new Move.Right(0); case \"H\",\"h\": return new Move.Left(1); case \"J\", \"j\": return new Move.Down(1); case \"K\",\"k\": return new Move.Up(1); case \"L\",\"l\": return new Move.Right(1); default: return new InvalidInput(0,\"Invalid Input.\"); } }",
        "label": "P"
    },
    "290": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public void move(Position from, Position to) { // TODO Entity original = getEntity(from); //System.out.println(original.getClass().getName()); Entity dest = getEntity(to); if (original == null || dest == null) { throw new ShouldNotReachException(); } if (original instanceof Box) { gameMap.removeBox(((Box) original).getPlayerId(),from); } if (gameMap.getMap()[from.x()][from.y()] == '@') { //prevent move the dest gameMap.getMap()[from.x()][from.y()] = '.'; } if (gameMap.getMap()[to.x()][to.y()] == '@') { gameMap.getMap()[to.x()][to.y()] = '.'; } //System.out.println(dest.getClass().getName()); gameMap.putEntity(to, original); gameMap.putEntity(from, dest); //gameMap.printMap(); if (getDestinations().contains(from) && gameMap.getMap()[from.x()][from.y()] == '.') { //add back the '@' gameMap.getMap()[from.x()][from.y()] = '@'; } if(getDestinations().contains(to) && gameMap.getMap()[to.x()][to.y()] == '.') { gameMap.getMap()[to.x()][to.y()] = '@'; } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "291": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public void move(Position from, Position to) { // TODO Entity original = getEntity(from); //System.out.println(original.getClass().getName()); Entity dest = getEntity(to); if (original == null || dest == null) { throw new ShouldNotReachException(); } if (original instanceof Box) { gameMap.removeBox(((Box) original).getPlayerId(),from); } if (gameMap.getMap()[from.x()][from.y()] == '@') { //prevent move the dest gameMap.getMap()[from.x()][from.y()] = '.'; } if (gameMap.getMap()[to.x()][to.y()] == '@') { gameMap.getMap()[to.x()][to.y()] = '.'; } //System.out.println(dest.getClass().getName()); gameMap.putEntity(to, original); gameMap.putEntity(from, dest); //gameMap.printMap(); if (getDestinations().contains(from) && gameMap.getMap()[from.x()][from.y()] == '.') { //add back the '@' gameMap.getMap()[from.x()][from.y()] = '@'; } if(getDestinations().contains(to) && gameMap.getMap()[to.x()][to.y()] == '.') { gameMap.getMap()[to.x()][to.y()] = '@'; } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return gameMap.getPlayerPosition(id); }",
        "label": "P"
    },
    "292": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public void move(Position from, Position to) { // TODO Entity original = getEntity(from); //System.out.println(original.getClass().getName()); Entity dest = getEntity(to); if (original == null || dest == null) { throw new ShouldNotReachException(); } if (original instanceof Box) { gameMap.removeBox(((Box) original).getPlayerId(),from); } if (gameMap.getMap()[from.x()][from.y()] == '@') { //prevent move the dest gameMap.getMap()[from.x()][from.y()] = '.'; } if (gameMap.getMap()[to.x()][to.y()] == '@') { gameMap.getMap()[to.x()][to.y()] = '.'; } //System.out.println(dest.getClass().getName()); gameMap.putEntity(to, original); gameMap.putEntity(from, dest); //gameMap.printMap(); if (getDestinations().contains(from) && gameMap.getMap()[from.x()][from.y()] == '.') { //add back the '@' gameMap.getMap()[from.x()][from.y()] = '@'; } if(getDestinations().contains(to) && gameMap.getMap()[to.x()][to.y()] == '.') { gameMap.getMap()[to.x()][to.y()] = '@'; } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return gameMap.getPlayerPosition(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "293": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public Optional<Integer> getUndoQuota() { // TODO return gameMap.getUndoLimit(); }",
        "label": "P"
    },
    "294": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Integer> playerIDs = gameMap.getPlayerIds(); Set<Position> allPlayerPosition = new HashSet<Position>(); allPlayerPosition.clear(); for (var i: playerIDs) { allPlayerPosition.add(getPlayerPositionById(i)); } return allPlayerPosition; }",
        "label": "P"
    },
    "295": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public void move(Position from, Position to) { // TODO Entity original = getEntity(from); //System.out.println(original.getClass().getName()); Entity dest = getEntity(to); if (original == null || dest == null) { throw new ShouldNotReachException(); } if (original instanceof Box) { gameMap.removeBox(((Box) original).getPlayerId(),from); } if (gameMap.getMap()[from.x()][from.y()] == '@') { //prevent move the dest gameMap.getMap()[from.x()][from.y()] = '.'; } if (gameMap.getMap()[to.x()][to.y()] == '@') { gameMap.getMap()[to.x()][to.y()] = '.'; } //System.out.println(dest.getClass().getName()); gameMap.putEntity(to, original); gameMap.putEntity(from, dest); //gameMap.printMap(); if (getDestinations().contains(from) && gameMap.getMap()[from.x()][from.y()] == '.') { //add back the '@' gameMap.getMap()[from.x()][from.y()] = '@'; } if(getDestinations().contains(to) && gameMap.getMap()[to.x()][to.y()] == '.') { gameMap.getMap()[to.x()][to.y()] = '@'; } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO char[][] mapCopy = new char[gameMap.getMaxWidth()][gameMap.getMaxHeight()]; for (int i = 0; i < gameMap.getMaxWidth(); i++) { mapCopy[i] = gameMap.getMap()[i].clone(); } undoCheckpoint.add(mapCopy); List<Set<Position>> boxCopy = new ArrayList<Set<Position>>(); for (var i: gameMap.getBoxList()) { boxCopy.add(new HashSet<Position>()); boxCopy.get(boxCopy.size() - 1).addAll(i); } boxCheckpoint.add(boxCopy); playerCheckpoint.add(gameMap.getPlayersPosition().clone()); //gameMap.printMap(undoCheckpoint.get(0)); } public void undo() { // TODO int undoNum = getUndoQuota().orElse(0); int lastUndoIndex = undoCheckpoint.size(); if (undoCheckpoint.isEmpty()) { return; } if (undoNum != 0) { if (!(lastUndoIndex == 1)) { gameMap.updateMap(undoCheckpoint.get(lastUndoIndex - 2)); gameMap.updateBoxList(boxCheckpoint.get(lastUndoIndex - 2)); gameMap.updatePlayerLocation(playerCheckpoint.get(lastUndoIndex - 2)); undoCheckpoint.remove(lastUndoIndex - 1); boxCheckpoint.remove(lastUndoIndex - 1); playerCheckpoint.remove(lastUndoIndex - 1); if (undoNum != -1) { undoNum -= 1; } } gameMap.updateUndoLimit(undoNum); //gameMap.printMap(undoCheckpoint.get(0)); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO return gameMap.getPlayerPosition(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return gameMap.getUndoLimit(); }",
        "label": "P"
    },
    "296": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } for (var i: gameState.getPlayerIDs()) { if (i != 0 && i != 1) { throw new IllegalArgumentException(); } } } public void run() { // TODO exitFlag = false; renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(this.state); renderingEngine.message(\"\"); if (state.getUndoQuota().orElse(0) != -1) { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,state.getUndoQuota().orElse(0).toString())); } else { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,StringResources.UNDO_QUOTA_UNLIMITED)); } while(!shouldStop()) { var actionResult = processAction(inputEngine.fetchAction()); if (actionResult instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) actionResult).getReason()); } renderingEngine.render(this.state); renderingEngine.message(\"\"); if (state.getUndoQuota().orElse(0) != -1) { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,state.getUndoQuota().orElse(0).toString())); } else { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,StringResources.UNDO_QUOTA_UNLIMITED)); } if (shouldStop()) { if (exitFlag) { renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); } else { renderingEngine.message(StringResources.WIN_MESSAGE); } //exit(0); } } }",
        "label": "P"
    },
    "297": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } for (var i: gameState.getPlayerIDs()) { if (i != 0 && i != 1) { throw new IllegalArgumentException(); } } }",
        "label": "P"
    },
    "298": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "299": {
        "dataset": "COMP 3021",
        "project": "cwhoal",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameMap = map; undoCheckpoint.clear(); boxCheckpoint.clear(); playerCheckpoint.clear(); checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "300": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TOD return maxwidth; //throw new NotImplementedException(); } public int getMaxHeight() { // TOD return maxheight; //throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TOD return Optional.of(undolimit); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "301": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "302": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "303": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "304": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "305": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "306": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TOD return worldgamestate[position.x()+position.y()*maxwidth]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "307": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TOD return worldgamestate[position.x()+position.y()*maxwidth]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "308": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TOD return maxheight; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "309": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TOD return maxwidth; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "310": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TOD return destinations; //throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TOD return worldgamestate[position.x()+position.y()*maxwidth]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "311": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TOD return worldgamestate[position.x()+position.y()*maxwidth]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "312": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TOD return worldgamestate[position.x()+position.y()*maxwidth]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "313": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TOD return worldgamestate[position.x()+position.y()*maxwidth]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "314": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TOD inputLine.toLowerCase(); if (inputLine.equals(\"exit\")) return new Exit(0); if (inputLine.equals(\"u\")) return new Undo(0); if (inputLine.equals(\"s\")) return new Move.Down(GameMap.playersId.get(0)); if (inputLine.equals(\"a\")) return new Move.Left(GameMap.playersId.get(0)); if (inputLine.equals(\"d\")) return new Move.Right(GameMap.playersId.get(0)); if (inputLine.equals(\"w\")) return new Move.Up(GameMap.playersId.get(0)); if (GameMap.playersId.size()<2) { if (inputLine.equals(\"h\")) return new InvalidInput(0,\"Player not found.\"); if (inputLine.equals(\"j\")) return new InvalidInput(0,\"Player not found.\"); if (inputLine.equals(\"k\")) return new InvalidInput(0,\"Player not found.\"); if (inputLine.equals(\"l\")) return new InvalidInput(0,\"Player not found.\"); } if (inputLine.equals(\"h\")) return new Move.Left(GameMap.playersId.get(1)); if (inputLine.equals(\"j\")) return new Move.Down(GameMap.playersId.get(1)); if (inputLine.equals(\"k\")) return new Move.Up(GameMap.playersId.get(1)); if (inputLine.equals(\"l\")) return new Move.Right(GameMap.playersId.get(1)); return new InvalidInput(0,\"Invalid Input.\"); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "315": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TOD boolean bool = worldgamestate[from.x()+from.y()*maxwidth]instanceof Box; if (bool) { for (int i=0;i<boxsloc.size();i++) { if (worldgamestate[from.x()+from.y()*maxwidth].equals(boxs.get(i))) boxIndexmoved=i; } worldgamestate[to.x()+ to.y()*maxwidth] = worldgamestate[from.x()+from.y()*maxwidth]; worldgamestate[from.x()+from.y()*maxwidth] = new Empty(); for (int i = 0; i < boxsloc.size(); i++) { if (boxsloc.get(i).equals(from)) boxsloc.set(i, to); } }else { worldgamestate[to.x()+ to.y()*maxwidth] = worldgamestate[from.x()+from.y()*maxwidth]; worldgamestate[from.x()+from.y()*maxwidth] = new Empty(); for (int i = 0; i < playersloc.size(); i++) { if (playersloc.get(i).equals(from)) playersloc.set(i, to); } }//System.out.print(boxsloc); //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "316": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TOD boolean bool = worldgamestate[from.x()+from.y()*maxwidth]instanceof Box; if (bool) { for (int i=0;i<boxsloc.size();i++) { if (worldgamestate[from.x()+from.y()*maxwidth].equals(boxs.get(i))) boxIndexmoved=i; } worldgamestate[to.x()+ to.y()*maxwidth] = worldgamestate[from.x()+from.y()*maxwidth]; worldgamestate[from.x()+from.y()*maxwidth] = new Empty(); for (int i = 0; i < boxsloc.size(); i++) { if (boxsloc.get(i).equals(from)) boxsloc.set(i, to); } }else { worldgamestate[to.x()+ to.y()*maxwidth] = worldgamestate[from.x()+from.y()*maxwidth]; worldgamestate[from.x()+from.y()*maxwidth] = new Empty(); for (int i = 0; i < playersloc.size(); i++) { if (playersloc.get(i).equals(from)) playersloc.set(i, to); } }//System.out.print(boxsloc); //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TOD for (int i=0;i<playersloc.size();i++) { if (players.get(i).getId()==id) return playersloc.get(i); } return null; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "317": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TOD boolean bool = worldgamestate[from.x()+from.y()*maxwidth]instanceof Box; if (bool) { for (int i=0;i<boxsloc.size();i++) { if (worldgamestate[from.x()+from.y()*maxwidth].equals(boxs.get(i))) boxIndexmoved=i; } worldgamestate[to.x()+ to.y()*maxwidth] = worldgamestate[from.x()+from.y()*maxwidth]; worldgamestate[from.x()+from.y()*maxwidth] = new Empty(); for (int i = 0; i < boxsloc.size(); i++) { if (boxsloc.get(i).equals(from)) boxsloc.set(i, to); } }else { worldgamestate[to.x()+ to.y()*maxwidth] = worldgamestate[from.x()+from.y()*maxwidth]; worldgamestate[from.x()+from.y()*maxwidth] = new Empty(); for (int i = 0; i < playersloc.size(); i++) { if (playersloc.get(i).equals(from)) playersloc.set(i, to); } }//System.out.print(boxsloc); //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TOD for (int i=0;i<playersloc.size();i++) { if (players.get(i).getId()==id) return playersloc.get(i); } return null; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TOD return worldgamestate[position.x()+position.y()*maxwidth]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "318": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TOD if (undolimit == -1) return Optional.empty(); else return Optional.of(undolimit); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "319": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TOD Set<Position> setplayer = new HashSet<Position>(); for (Position p: playersloc) { setplayer.add(p); } return setplayer; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "320": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TOD boolean bool = worldgamestate[from.x()+from.y()*maxwidth]instanceof Box; if (bool) { for (int i=0;i<boxsloc.size();i++) { if (worldgamestate[from.x()+from.y()*maxwidth].equals(boxs.get(i))) boxIndexmoved=i; } worldgamestate[to.x()+ to.y()*maxwidth] = worldgamestate[from.x()+from.y()*maxwidth]; worldgamestate[from.x()+from.y()*maxwidth] = new Empty(); for (int i = 0; i < boxsloc.size(); i++) { if (boxsloc.get(i).equals(from)) boxsloc.set(i, to); } }else { worldgamestate[to.x()+ to.y()*maxwidth] = worldgamestate[from.x()+from.y()*maxwidth]; worldgamestate[from.x()+from.y()*maxwidth] = new Empty(); for (int i = 0; i < playersloc.size(); i++) { if (playersloc.get(i).equals(from)) playersloc.set(i, to); } }//System.out.print(boxsloc); //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TOD Entity[] cp = new Entity[maxwidth*maxheight]; for (int i = 0;i<cp.length;i++) { cp[i] = worldgamestate[i]; } checkpt.push(cp); //throw new NotImplementedException(); } public void undo() { // TOD if (checkpt.empty()) { for (int i = 0;i<worldgamestate.length;i++) worldgamestate[i] = GameMap.getWorld()[i]; for (int i = 0;i<worldgamestate.length;i++) { if (GameMap.getWorld()[i]instanceof Player) { for (int j=0;j<players.size();j++) { if (players.get(j).getId()==((Player) GameMap.getWorld()[i]).getId()) playersloc.set(j,Position.of(i%maxwidth,i/maxwidth)); } } } return; } else if (checkpt.size()==1) { checkpt.pop(); if (undolimit>=1) undolimit-=1; for (int i = 0;i<worldgamestate.length;i++) { if (GameMap.getWorld()[i]instanceof Player) { for (int j=0;j<players.size();j++) { if (players.get(j).getId()==((Player) GameMap.getWorld()[i]).getId()) playersloc.set(j,Position.of(i%maxwidth,i/maxwidth)); } } else if (GameMap.getWorld()[i]instanceof Box) { if (worldgamestate[i]instanceof Player) { boxsloc.set(boxIndexmoved, Position.of(i % maxwidth, i / maxwidth)); } } } for (int i = 0;i<worldgamestate.length;i++) worldgamestate[i] = GameMap.getWorld()[i]; return; } else { boolean b = true; if (b) { checkpt.pop(); Entity[] undocheckpt = checkpt.get(checkpt.size()-1); if (undolimit >= 1) undolimit -= 1; for (int i = 0; i < worldgamestate.length; i++) { if (undocheckpt[i] instanceof Player) { for (int j = 0; j < players.size(); j++) { if (players.get(j).getId() == ((Player) undocheckpt[i]).getId()) playersloc.set(j, Position.of(i % maxwidth, i / maxwidth)); } } else if (undocheckpt[i] instanceof Box) { boxsloc.set(boxIndexmoved, Position.of(i % maxwidth, i / maxwidth)); } } for (int i = 0; i < worldgamestate.length; i++) { worldgamestate[i] = undocheckpt[i]; } return; } } //throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TOD for (int i=0;i<playersloc.size();i++) { if (players.get(i).getId()==id) return playersloc.get(i); } return null; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TOD return worldgamestate[position.x()+position.y()*maxwidth]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TOD if (undolimit == -1) return Optional.empty(); else return Optional.of(undolimit); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "321": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TOD if (gameState.getPlayers().size()>2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); // Check the number of players //throw new NotImplementedException(); } public void run() { // TOD renderingEngine.message(\"Sokoban game is ready.\"); while (!shouldStop()) { renderingEngine.render(super.state); renderingEngine.message(\"\"); if (super.state.getUndoQuota().isPresent()) renderingEngine.message(\"Undo Quata: \" + super.state.getUndoQuota().get().toString()); else renderingEngine.message(\"Unlimited\"); Action inputaction = inputEngine.fetchAction(); ActionResult inputresult = processAction(inputaction); renderingEngine.message(\"\"); if (inputresult instanceof ActionResult.Failed) renderingEngine.message(((ActionResult.Failed) inputresult).getReason()); } renderingEngine.render(super.state); renderingEngine.message(\"\"); renderingEngine.message(\"Game exits.\"); if (!(super.a instanceof Exit)) { renderingEngine.message(\"You win.\"); } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "322": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TOD if (gameState.getPlayers().size()>2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); // Check the number of players //throw new NotImplementedException(); }",
        "label": "P"
    },
    "323": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TOD outputSteam.println(content); // Hint: System.out is also a PrintStream. //throw new NotImplementedException(); }",
        "label": "P"
    },
    "324": {
        "dataset": "COMP 3021",
        "project": "mchon",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TOD this.maxwidth = map.getMaxWidth(); this.maxheight =map.getMaxHeight(); this.destinations = map.getDestinations(); this.walls = map.getWalls(); this.emptys = map.getEmptys(); this.boxsloc = map.getBoxsloc(); this.playersloc = map.getPlayersloc(); this.boxs = map.getBoxs(); this.players = map.getPlayers(); this.undolimit = map.getUndoLimit().orElse(0); drawGamestate(); //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "325": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "326": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "327": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "328": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "329": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "330": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "331": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= 0 && position.y() >= 0 && position.y() < this.map.length && position.x() < this.map[position.y()].length) { char c = this.map[position.y()][position.x()]; if (c == ' ') return null; else if (c == '#') return new Wall(); else if (c == '.' || c == '@') return new Empty(); else if (Character.isLowerCase(c)) return new Box(c - 'a'); else if (Character.isUpperCase(c)) return new Player(c - 'A'); else return null; } else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "332": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= 0 && position.y() >= 0 && position.y() < this.map.length && position.x() < this.map[position.y()].length) { char c = this.map[position.y()][position.x()]; if (c == ' ') return null; else if (c == '#') return new Wall(); else if (c == '.' || c == '@') return new Empty(); else if (Character.isLowerCase(c)) return new Box(c - 'a'); else if (Character.isUpperCase(c)) return new Player(c - 'A'); else return null; } else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "333": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "334": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "335": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= 0 && position.y() >= 0 && position.y() < this.map.length && position.x() < this.map[position.y()].length) { char c = this.map[position.y()][position.x()]; if (c == ' ') return null; else if (c == '#') return new Wall(); else if (c == '.' || c == '@') return new Empty(); else if (Character.isLowerCase(c)) return new Box(c - 'a'); else if (Character.isUpperCase(c)) return new Player(c - 'A'); else return null; } else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "336": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= 0 && position.y() >= 0 && position.y() < this.map.length && position.x() < this.map[position.y()].length) { char c = this.map[position.y()][position.x()]; if (c == ' ') return null; else if (c == '#') return new Wall(); else if (c == '.' || c == '@') return new Empty(); else if (Character.isLowerCase(c)) return new Box(c - 'a'); else if (Character.isUpperCase(c)) return new Player(c - 'A'); else return null; } else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "337": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= 0 && position.y() >= 0 && position.y() < this.map.length && position.x() < this.map[position.y()].length) { char c = this.map[position.y()][position.x()]; if (c == ' ') return null; else if (c == '#') return new Wall(); else if (c == '.' || c == '@') return new Empty(); else if (Character.isLowerCase(c)) return new Box(c - 'a'); else if (Character.isUpperCase(c)) return new Player(c - 'A'); else return null; } else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "338": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= 0 && position.y() >= 0 && position.y() < this.map.length && position.x() < this.map[position.y()].length) { char c = this.map[position.y()][position.x()]; if (c == ' ') return null; else if (c == '#') return new Wall(); else if (c == '.' || c == '@') return new Empty(); else if (Character.isLowerCase(c)) return new Box(c - 'a'); else if (Character.isUpperCase(c)) return new Player(c - 'A'); else return null; } else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "339": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO inputLine.toLowerCase(); if (inputLine.equalsIgnoreCase(StringResources.EXIT_COMMAND_TEXT)) return new Exit(-1); else if (inputLine.equalsIgnoreCase(\"a\")) return new Move.Left(0); else if (inputLine.equalsIgnoreCase(\"s\")) return new Move.Down(0); else if (inputLine.equalsIgnoreCase(\"w\")) return new Move.Up(0); else if (inputLine.equalsIgnoreCase(\"d\")) return new Move.Right(0); else if (inputLine.equalsIgnoreCase(\"h\")) return new Move.Left(1); else if (inputLine.equalsIgnoreCase(\"j\")) return new Move.Down(1); else if (inputLine.equalsIgnoreCase(\"k\")) return new Move.Up(1); else if (inputLine.equalsIgnoreCase(\"l\")) return new Move.Right(1); else if (inputLine.equalsIgnoreCase(\"u\")) return new Undo(-1); else return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); }",
        "label": "P"
    },
    "340": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public void move(Position from, Position to) { // TODO char fromEntity = this.map[from.y()][from.x()]; //char toEntity = this.map[to.y()][to.x()]; this.map[from.y()][from.x()] = (char)(this.destinations.contains(from) ? '@' : '.'); this.map[to.y()][to.x()] = fromEntity; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "341": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public void move(Position from, Position to) { // TODO char fromEntity = this.map[from.y()][from.x()]; //char toEntity = this.map[to.y()][to.x()]; this.map[from.y()][from.x()] = (char)(this.destinations.contains(from) ? '@' : '.'); this.map[to.y()][to.x()] = fromEntity; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < this.map.length; ++i) { for(int j = 0; j < this.map[i].length; ++j) { if (Character.isUpperCase(this.map[i][j]) && this.map[i][j] - 65 == id) return new Position(j, i); } } return null; }",
        "label": "P"
    },
    "342": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public void move(Position from, Position to) { // TODO char fromEntity = this.map[from.y()][from.x()]; //char toEntity = this.map[to.y()][to.x()]; this.map[from.y()][from.x()] = (char)(this.destinations.contains(from) ? '@' : '.'); this.map[to.y()][to.x()] = fromEntity; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < this.map.length; ++i) { for(int j = 0; j < this.map[i].length; ++j) { if (Character.isUpperCase(this.map[i][j]) && this.map[i][j] - 65 == id) return new Position(j, i); } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= 0 && position.y() >= 0 && position.y() < this.map.length && position.x() < this.map[position.y()].length) { char c = this.map[position.y()][position.x()]; if (c == ' ') return null; else if (c == '#') return new Wall(); else if (c == '.' || c == '@') return new Empty(); else if (Character.isLowerCase(c)) return new Box(c - 'a'); else if (Character.isUpperCase(c)) return new Player(c - 'A'); else return null; } else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "343": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota == -1 ? Optional.empty() : Optional.of(this.undoQuota); }",
        "label": "P"
    },
    "344": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> positions = new HashSet(); for(int i = 0; i < this.map.length; ++i) { for(int j = 0; j < this.map[i].length; ++j) { if (Character.isUpperCase(this.map[i][j])) positions.add(new Position(j, i)); } } return positions; }",
        "label": "P"
    },
    "345": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public void move(Position from, Position to) { // TODO char fromEntity = this.map[from.y()][from.x()]; //char toEntity = this.map[to.y()][to.x()]; this.map[from.y()][from.x()] = (char)(this.destinations.contains(from) ? '@' : '.'); this.map[to.y()][to.x()] = fromEntity; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO this.checkPoints.push(this.deepCopyMap(this.map)); } public void undo() { // TODO if (this.undoQuota > 0 && !this.checkPoints.isEmpty()) --this.undoQuota; if (!this.checkPoints.empty()) this.checkPoints.pop(); if (this.checkPoints.empty()) this.map = this.deepCopyMap(GameMap.initialMap); else this.map = this.deepCopyMap((char[][])this.checkPoints.peek()); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < this.map.length; ++i) { for(int j = 0; j < this.map[i].length; ++j) { if (Character.isUpperCase(this.map[i][j]) && this.map[i][j] - 65 == id) return new Position(j, i); } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= 0 && position.y() >= 0 && position.y() < this.map.length && position.x() < this.map[position.y()].length) { char c = this.map[position.y()][position.x()]; if (c == ' ') return null; else if (c == '#') return new Wall(); else if (c == '.' || c == '@') return new Empty(); else if (Character.isLowerCase(c)) return new Box(c - 'a'); else if (Character.isUpperCase(c)) return new Player(c - 'A'); else return null; } else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota == -1 ? Optional.empty() : Optional.of(this.undoQuota); }",
        "label": "P"
    },
    "346": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(); } public void run() { // TODO this.renderingEngine.message(StringResources.GAME_READY_MESSAGE); while(!this.shouldStop()) { this.renderingEngine.render(this.state); if (this.state.getUndoQuota().isEmpty()) this.renderingEngine.message(StringResources.UNDO_QUOTA_UNLIMITED); else this.renderingEngine.message(\"Undo Quota: \" + this.state.getUndoQuota().get()); Action action = this.inputEngine.fetchAction(); ActionResult result = this.processAction(action); if (result instanceof ActionResult.Failed) { this.renderingEngine.message(((ActionResult.Failed)result).getReason()); } } this.renderingEngine.render(this.state); renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (state.isWin()) this.renderingEngine.message(StringResources.WIN_MESSAGE); }",
        "label": "P"
    },
    "347": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "348": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "349": {
        "dataset": "COMP 3021",
        "project": "jzhanggc",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; this.map = this.deepCopyMap(GameMap.initialMap); this.destinations = this.gameMap.destinations; this.checkPoints = new Stack(); this.undoQuota = map.undoLimit; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "350": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return this.undoLimit; }",
        "label": "P"
    },
    "351": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "352": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "353": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "354": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "355": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "356": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.currentMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "357": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.currentMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "358": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "359": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "360": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.currentMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "361": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.currentMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "362": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.currentMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "363": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.currentMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "364": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO switch (inputLine.toLowerCase()){ case \"exit\": return new Exit(-1); case \"a\": return new Move.Left(0); case \"s\": return new Move.Down(0); case \"w\": return new Move.Up(0); case \"d\": return new Move.Right(0); case \"h\": return new Move.Left(1); case \"j\": return new Move.Down(1); case \"k\": return new Move.Up(1); case \"l\": return new Move.Right(1); case \"u\": return new Undo(-1); default: return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "365": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public void move(Position from, Position to) { // TODO this.currentMap.put(to, this.currentMap.get(from)); this.currentMap.put(from, new Empty()); parsePlayerPosition(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "366": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public void move(Position from, Position to) { // TODO this.currentMap.put(to, this.currentMap.get(from)); this.currentMap.put(from, new Empty()); parsePlayerPosition(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.playersPosition.get(id); }",
        "label": "P"
    },
    "367": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public void move(Position from, Position to) { // TODO this.currentMap.put(to, this.currentMap.get(from)); this.currentMap.put(from, new Empty()); parsePlayerPosition(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.playersPosition.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.currentMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "368": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota; }",
        "label": "P"
    },
    "369": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> result = new HashSet<Position>(); List<Position> items = Arrays.asList(this.playersPosition.values().toArray(new Position[0])); for (var i : items) { result.add(i); } return result; }",
        "label": "P"
    },
    "370": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public void move(Position from, Position to) { // TODO this.currentMap.put(to, this.currentMap.get(from)); this.currentMap.put(from, new Empty()); parsePlayerPosition(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO HashMap<Position, Entity> previousMap = copy(this.currentMap); this.checkpoints.add(previousMap); } public void undo() { // TODO if (this.undoQuota.isPresent()) { var value = this.undoQuota.get(); if (this.checkpoints.size() > 1) { if (value > 0) { this.undoQuota = Optional.of(value - 1); this.currentMap = copy(this.checkpoints.get(this.checkpoints.size() - 2)); this.checkpoints.remove(this.checkpoints.size() - 1); } else if (value == -1) { this.currentMap = copy(this.checkpoints.get(this.checkpoints.size() - 2)); this.checkpoints.remove(this.checkpoints.size() - 1); } else { return; } parsePlayerPosition(); } else if (this.checkpoints.size() == 1) { if (value > 0) { this.currentMap = copy(this.checkpoints.get(0)); } else if (value == -1) { this.currentMap = copy(this.checkpoints.get(0)); } else { return; } parsePlayerPosition(); } else { return; } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO return this.playersPosition.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.currentMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota; }",
        "label": "P"
    },
    "371": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } } public void run() { // TODO this.renderingEngine.message(StringResources.GAME_READY_MESSAGE); while(!this.shouldStop()){ this.renderingEngine.render(state); if(state.getUndoQuota().isPresent()){ var undoQuota = Integer.valueOf(state.getUndoQuota().get()); if(undoQuota == -1){ this.renderingEngine.message(StringResources.UNDO_QUOTA_UNLIMITED); } else { this.renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, undoQuota)); } } this.renderingEngine.message(StringResources.LINE_BREAKERS); Action action = inputEngine.fetchAction(); ActionResult result = this.processAction(action); if(result instanceof ActionResult.Failed){ this.renderingEngine.message(((ActionResult.Failed) result).getReason()); } } this.renderingEngine.render(state); this.renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if(state.isWin()){ this.renderingEngine.message(StringResources.WIN_MESSAGE); } }",
        "label": "P"
    },
    "372": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "373": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.print(content + System.lineSeparator()); }",
        "label": "P"
    },
    "374": {
        "dataset": "COMP 3021",
        "project": "mjlaurent",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undoLimit; this.currentMap = map.getGameMap(); this.playersPosition = map.playersPosition; this.checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "375": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { return undoLimit; }",
        "label": "P"
    },
    "376": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "377": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "378": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "379": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "380": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "381": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.entityArray[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "382": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.entityArray[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "383": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "384": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "385": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.entityArray[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "386": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.entityArray[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "387": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.entityArray[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "388": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.entityArray[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "389": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); var inputLineUP = inputLine.toUpperCase(); switch (inputLineUP) { case \"W\": // player A move up return new Move.Up(0); case \"A\": // player A move left return new Move.Left(0); case \"S\": // player A move down return new Move.Down(0); case \"D\": // player A move right return new Move.Right(0); case \"K\": // player B move up return new Move.Up(1); case \"H\": // player B move left return new Move.Left(1); case \"J\": // player B move down return new Move.Down(1); case \"L\": // player B move down return new Move.Right(1); case \"U\": // undo return new Undo(-1); case \"EXIT\": // exit return new Exit(-1); default: // invalid return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "390": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public void move(Position from, Position to) { Entity entity = getEntity(from); if (entity instanceof Player) { int id = ((Player)entity).getId(); char charID = (char)(id+65); currentPlayerLocations.remove(charID); currentPlayerLocations.put(charID, new Position(to.x(), to.y())); } else if (entity instanceof Box) { int id = ((Box)entity).getPlayerId(); char charID = (char)(id+97); currentBoxLocations.remove(from); currentBoxLocations.put(to, charID); } GameMap.entityArray[to.y()][to.x()] = GameMap.entityArray[from.y()][from.x()]; GameMap.entityArray[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "391": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public void move(Position from, Position to) { Entity entity = getEntity(from); if (entity instanceof Player) { int id = ((Player)entity).getId(); char charID = (char)(id+65); currentPlayerLocations.remove(charID); currentPlayerLocations.put(charID, new Position(to.x(), to.y())); } else if (entity instanceof Box) { int id = ((Box)entity).getPlayerId(); char charID = (char)(id+97); currentBoxLocations.remove(from); currentBoxLocations.put(to, charID); } GameMap.entityArray[to.y()][to.x()] = GameMap.entityArray[from.y()][from.x()]; GameMap.entityArray[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { Character key = (char)(id+65); if (currentPlayerLocations.containsKey(key)) { return currentPlayerLocations.get(key); } return null; }",
        "label": "P"
    },
    "392": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public void move(Position from, Position to) { Entity entity = getEntity(from); if (entity instanceof Player) { int id = ((Player)entity).getId(); char charID = (char)(id+65); currentPlayerLocations.remove(charID); currentPlayerLocations.put(charID, new Position(to.x(), to.y())); } else if (entity instanceof Box) { int id = ((Box)entity).getPlayerId(); char charID = (char)(id+97); currentBoxLocations.remove(from); currentBoxLocations.put(to, charID); } GameMap.entityArray[to.y()][to.x()] = GameMap.entityArray[from.y()][from.x()]; GameMap.entityArray[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { Character key = (char)(id+65); if (currentPlayerLocations.containsKey(key)) { return currentPlayerLocations.get(key); } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.entityArray[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "393": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public Optional<Integer> getUndoQuota() { if (undoQuota == -1) { return Optional.empty(); } else { return Optional.of(undoQuota); } }",
        "label": "P"
    },
    "394": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { Set<Position> allPositions = new HashSet<>(); for (int i = 0; i < 26; i++) { Character key = (char)(i+65); if (currentPlayerLocations.containsKey(key)) { allPositions.add(currentPlayerLocations.get(key)); } } return allPositions; }",
        "label": "P"
    },
    "395": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public void move(Position from, Position to) { Entity entity = getEntity(from); if (entity instanceof Player) { int id = ((Player)entity).getId(); char charID = (char)(id+65); currentPlayerLocations.remove(charID); currentPlayerLocations.put(charID, new Position(to.x(), to.y())); } else if (entity instanceof Box) { int id = ((Box)entity).getPlayerId(); char charID = (char)(id+97); currentBoxLocations.remove(from); currentBoxLocations.put(to, charID); } GameMap.entityArray[to.y()][to.x()] = GameMap.entityArray[from.y()][from.x()]; GameMap.entityArray[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // perform deep copy to store the current state Entity[][] entityArrayCheckpoint = new Entity[getMapMaxHeight()][getMapMaxWidth()]; for (int i = 0; i < entityArrayCheckpoint.length; i++) { for (int j = 0; j < entityArrayCheckpoint[0].length; j++) { Entity entity = getEntity(new Position(j, i)); if (entity instanceof Player) { entityArrayCheckpoint[i][j] = new Player(((Player)entity).getId()); } else if (entity instanceof Box) { entityArrayCheckpoint[i][j] = new Box(((Box)entity).getPlayerId()); } else if (entity instanceof Wall) { entityArrayCheckpoint[i][j] = new Wall(); } else if (entity instanceof Empty) { entityArrayCheckpoint[i][j] = new Empty(); } else { // outside the wall entityArrayCheckpoint[i][j] = null; } } } moveHistoryOfEntity.push(entityArrayCheckpoint); } public void undo() { if (moveHistoryOfEntity.size() > 1) { // have move history (not only init state) moveHistoryOfEntity.pop(); // remove the recent move // perform deep copy to get back previous state Entity[][] entityArrayCheckpoint = moveHistoryOfEntity.peek(); // get the last move for (int i = 0; i < entityArrayCheckpoint.length; i++) { for (int j = 0; j < entityArrayCheckpoint[0].length; j++) { Entity entity = entityArrayCheckpoint[i][j]; if (entity instanceof Player) { int id = ((Player) entity).getId(); char charID = (char) (id + 65); gameMap.entityArray[i][j] = new Player(id); currentPlayerLocations.remove(charID); currentPlayerLocations.put(charID, new Position(j, i)); } else if (entity instanceof Box) { int id = ((Box) entity).getPlayerId(); char charID = (char) (id + 97); gameMap.entityArray[i][j] = new Box(id); currentBoxLocations.remove(new Position(j, i)); currentBoxLocations.put(new Position(j, i), charID); } else if (entity instanceof Wall) { gameMap.entityArray[i][j] = new Wall(); } else if (entity instanceof Empty) { gameMap.entityArray[i][j] = new Empty(); } else { // outside the wall gameMap.entityArray[i][j] = null; } } } if (undoQuota != -1) { undoQuota--; } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { Character key = (char)(id+65); if (currentPlayerLocations.containsKey(key)) { return currentPlayerLocations.get(key); } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.entityArray[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { if (undoQuota == -1) { return Optional.empty(); } else { return Optional.of(undoQuota); } }",
        "label": "P"
    },
    "396": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // Check the number of players int numOfPlayers = 0; for (int i = 0; i < gameState.getMapMaxHeight(); i++) { for (int j = 0; j < gameState.getMapMaxWidth(); j++) { if (gameState.getEntity(new Position(j, i)) instanceof Player) { numOfPlayers++; } } } if (numOfPlayers > 2) { throw new IllegalArgumentException(); } } public void run() { renderingEngine.message(StringResources.GAME_READY_MESSAGE); do { // game loop renderingEngine.render(state); renderingEngine.message(\"\"); if (state.getUndoQuota().isEmpty()) { // unlimited undo quota renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, StringResources.UNDO_QUOTA_UNLIMITED)); } else { // limited undo quota renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get())); } renderingEngine.message(\">>>\"); Action action = inputEngine.fetchAction(); // get the action ActionResult result = processAction(action); // process the action // if fail to process, give message; if success, process if (result instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed)result).getReason()); } else if (action instanceof InvalidInput) { renderingEngine.message(((InvalidInput)action).getMessage()); } else if (action instanceof Exit) { break; } else if (action instanceof Undo) { state.undo(); } // ignore Move since handled in AbstractSokobanGame::processAction } while (!shouldStop()); // end of game if (state.isWin()) { // win the game renderingEngine.render(state); renderingEngine.message(\"\"); renderingEngine.message(StringResources.WIN_MESSAGE); } else { // exit the game renderingEngine.render(state); renderingEngine.message(\"\"); renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); } }",
        "label": "P"
    },
    "397": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // Check the number of players int numOfPlayers = 0; for (int i = 0; i < gameState.getMapMaxHeight(); i++) { for (int j = 0; j < gameState.getMapMaxWidth(); j++) { if (gameState.getEntity(new Position(j, i)) instanceof Player) { numOfPlayers++; } } } if (numOfPlayers > 2) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "398": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "399": {
        "dataset": "COMP 3021",
        "project": "thliai",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.currentBoxLocations = new HashMap<>(); this.currentPlayerLocations = new HashMap<>(); this.moveHistoryOfEntity = new Stack<>(); if (map.getUndoLimit().isEmpty()) { this.undoQuota = -1; } else { this.undoQuota = map.getUndoLimit().get(); } this.exitCondition = false; // all the current locations come from GameMap at first for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = map.getEntity(new Position(j, i)); if (entity instanceof Box) { currentBoxLocations.put(new Position(j, i), (char)(((Box)entity).getPlayerId()+97)); } else if (entity instanceof Player) { currentPlayerLocations.put((char)(((Player)entity).getId()+65), new Position(j, i)); } } } checkpoint(); // record the init state } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "400": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.mapWidth; //throw new NotImplementedException(); } public int getMaxHeight() { // TODO return this.mapHeight; //throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undoLimit); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "401": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "402": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "403": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "404": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "405": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "406": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return currentState.getMap().get(position.y()).get(position.x()); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "407": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return currentState.getMap().get(position.y()).get(position.x()); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "408": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.mapHeight; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "409": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.mapWidth; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "410": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO System.out.println(originalMap.getDestinations()); return originalMap.getDestinations(); //return currentState.getDestinations(); //throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return currentState.getMap().get(position.y()).get(position.x()); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "411": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return currentState.getMap().get(position.y()).get(position.x()); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "412": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return currentState.getMap().get(position.y()).get(position.x()); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "413": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return currentState.getMap().get(position.y()).get(position.x()); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "414": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); inputLine.toLowerCase(); Action action; if (inputLine.equals(\"exit\")) { action = new Exit(0); return action; } // TODO if (inputLine.charAt(0) == 'w') action = new Move.Up(0); else if (inputLine.charAt(0) == 'a') action = new Move.Left(0); else if (inputLine.charAt(0) == 's') action = new Move.Down(0); else if (inputLine.charAt(0) == 'd') action = new Move.Right(0); else if (inputLine.charAt(0) == 'j') action = new Move.Left(1); else if (inputLine.charAt(0) == 'i') action = new Move.Up(1); else if (inputLine.charAt(0) == 'k') action = new Move.Down(1); else if (inputLine.charAt(0) == 'l') action = new Move.Right(1); else if (inputLine.charAt(0) == 'u') action = new Undo(0); else throw new IllegalArgumentException(); return action; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "415": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO var obj = getEntity(from); if (obj instanceof Box) checkpoint(); currentState.putEntity(to, obj); currentState.putEntity(from, new Empty()); //printMap(); return; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "416": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO var obj = getEntity(from); if (obj instanceof Box) checkpoint(); currentState.putEntity(to, obj); currentState.putEntity(from, new Empty()); //printMap(); return; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO var playerList = currentState.getPlayerIds(); if (!playerList.contains(id)) throw new IllegalArgumentException(); int rowidx = 0; int colidx = 0; for ( var i : currentState.getMap()) { colidx = 0; for (var j : i) { colidx++; if(j.getClass().equals(Player.class)) if(((Player) j).getId() == id) return new Position(colidx - 1, rowidx); else continue; } rowidx++; } throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "417": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO var obj = getEntity(from); if (obj instanceof Box) checkpoint(); currentState.putEntity(to, obj); currentState.putEntity(from, new Empty()); //printMap(); return; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO var playerList = currentState.getPlayerIds(); if (!playerList.contains(id)) throw new IllegalArgumentException(); int rowidx = 0; int colidx = 0; for ( var i : currentState.getMap()) { colidx = 0; for (var j : i) { colidx++; if(j.getClass().equals(Player.class)) if(((Player) j).getId() == id) return new Position(colidx - 1, rowidx); else continue; } rowidx++; } throw new IllegalArgumentException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return currentState.getMap().get(position.y()).get(position.x()); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "418": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO if(!undoQuota.isEmpty()) return undoQuota; else return Optional.empty(); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "419": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO //throw new NotImplementedException(); var playerList = currentState.getPlayerIds(); //System.out.println(playerList); if (playerList.size() == 0) throw new IllegalArgumentException(); Set<Position> allPos = new HashSet<>(); for ( var i : currentState.getMap()) { //System.out.println(); for (var j : i) { //System.out.println(j.getClass()); if(j instanceof Player) { allPos.add(getPlayerPositionById(((Player) j).getId())); //System.out.println(getPlayerPositionById(((Player) j).getId())); } } } return allPos; //throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "420": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO var obj = getEntity(from); if (obj instanceof Box) checkpoint(); currentState.putEntity(to, obj); currentState.putEntity(from, new Empty()); //printMap(); return; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO List<List<Entity>> toBeRecord = new ArrayList<>(); for (var i : lastMap.getMap()) { var row = new ArrayList<Entity>(); for (var j : i) row.add(j); toBeRecord.add(row); } checkPointList.add(toBeRecord); lastMap.putMap(currentState.getMap()); //printMap(); return; //throw new NotImplementedException(); } public void undo() { // TODO //printMap(); int index = checkPointList.size() - 1; if(index < 0) currentState.putMap(originalMap.getMap()); else { currentState.putMap(checkPointList.get(index)); if (index == 0) lastMap.putMap(originalMap.getMap()); else lastMap.putMap(checkPointList.get(index - 1)); //printMap(); checkPointList.remove(index); var undoLeft = undoQuota.get(); undoLeft = Integer.valueOf((undoLeft.intValue() - 1)); undoQuota = Optional.of(undoLeft); } return; //throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO var playerList = currentState.getPlayerIds(); if (!playerList.contains(id)) throw new IllegalArgumentException(); int rowidx = 0; int colidx = 0; for ( var i : currentState.getMap()) { colidx = 0; for (var j : i) { colidx++; if(j.getClass().equals(Player.class)) if(((Player) j).getId() == id) return new Position(colidx - 1, rowidx); else continue; } rowidx++; } throw new IllegalArgumentException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return currentState.getMap().get(position.y()).get(position.x()); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if(!undoQuota.isEmpty()) return undoQuota; else return Optional.empty(); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "421": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; this.gameState = gameState; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); //throw new NotImplementedException(); } public void run() { // TODO System.out.println(\"Sokoban game is ready.\"); renderingEngine.render(gameState); System.out.println(\"Undo Quota: \" + gameState.getUndoQuota()); while (true) { if (shouldStop() || inputEngine.fetchAction() instanceof Exit) return; else { var action = inputEngine.fetchAction(); processAction(action); renderingEngine.render(state); } } //throw new NotImplementedException(); }",
        "label": "F"
    },
    "422": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; this.gameState = gameState; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "423": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.print(content); return; }",
        "label": "F"
    },
    "424": {
        "dataset": "COMP 3021",
        "project": "rliba",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO originalMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); originalMap.putMap(map.getMap()); currentState = map; lastMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.getUndoLimit().get()); lastMap.putMap(map.getMap()); undoQuota = map.getUndoLimit(); checkPointList = new ArrayList<>(); return; //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "F"
    },
    "425": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return this.maxWidth; } public int getMaxHeight() { return this.maxHeight; } public Optional<Integer> getUndoLimit() { if (undoLimit >= 0) { return Optional.of(undoLimit); } else { return Optional.empty(); } }",
        "label": "P"
    },
    "426": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "427": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "428": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "429": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "430": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "431": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "432": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "433": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return this.maxHeight; }",
        "label": "P"
    },
    "434": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return this.maxWidth; }",
        "label": "P"
    },
    "435": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return map.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "436": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "437": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "438": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "439": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); var action = switch (inputLine.toUpperCase()) { case \"U\" -> new Undo(0); case \"A\" -> new Move.Left(0); case \"S\" -> new Move.Down(0); case \"W\" -> new Move.Up(0); case \"D\" -> new Move.Right(0); case \"H\" -> new Move.Left(1); case \"J\" -> new Move.Down(1); case \"K\" -> new Move.Up(1); case \"L\" -> new Move.Right(1); case \"EXIT\" -> new Exit(0); default -> new InvalidInput(0, \"Invalid Input\"); }; return action; }",
        "label": "P"
    },
    "440": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public void move(Position from, Position to) { Object entity = map.get(from); map.replace(to, map.get(from)); map.replace(from, new Empty()); if (entity instanceof Player) { Player player = (Player) entity; playerPosition.replace(player.getId(), to); } else if (entity instanceof Box) { Box box = (Box) entity; boxPosition.replace(box, to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "441": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public void move(Position from, Position to) { Object entity = map.get(from); map.replace(to, map.get(from)); map.replace(from, new Empty()); if (entity instanceof Player) { Player player = (Player) entity; playerPosition.replace(player.getId(), to); } else if (entity instanceof Box) { Box box = (Box) entity; boxPosition.replace(box, to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return playerPosition.get(id); }",
        "label": "P"
    },
    "442": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public void move(Position from, Position to) { Object entity = map.get(from); map.replace(to, map.get(from)); map.replace(from, new Empty()); if (entity instanceof Player) { Player player = (Player) entity; playerPosition.replace(player.getId(), to); } else if (entity instanceof Box) { Box box = (Box) entity; boxPosition.replace(box, to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return playerPosition.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { return map.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "443": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public Optional<Integer> getUndoQuota() { if (undoQuotaLeft == -1) { return Optional.empty(); } else { return Optional.of(undoQuotaLeft); } }",
        "label": "P"
    },
    "444": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { Set<Position> allPlayerPositions = new HashSet<>(); allPlayerPositions.addAll(playerPosition.values()); return allPlayerPositions; }",
        "label": "P"
    },
    "445": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public void move(Position from, Position to) { Object entity = map.get(from); map.replace(to, map.get(from)); map.replace(from, new Empty()); if (entity instanceof Player) { Player player = (Player) entity; playerPosition.replace(player.getId(), to); } else if (entity instanceof Box) { Box box = (Box) entity; boxPosition.replace(box, to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { Map<Position, Entity> newMap = new HashMap<>(); for (int x = 0; x < this.gameMap.getMaxWidth(); ++x) { for (int y = 0; y < this.gameMap.getMaxHeight(); ++y) { Position position = Position.of(x, y); newMap.put(position, map.get(position)); } } moveHistory.add(newMap); } public void undo() { if (undoQuotaLeft > 0) { undoQuotaLeft -= 1; } Map<Position, Entity> mapToCopy; if (moveHistory.size() == 1) { mapToCopy = moveHistory.get(0); this.equalInitialMap = true; } else { if (moveHistory.size() == 2) { this.equalInitialMap = true; } mapToCopy = moveHistory.get(moveHistory.size() - 2); moveHistory.remove(moveHistory.size() - 1); } this.map = new HashMap<>(); playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); for (int x = 0; x < this.gameMap.getMaxWidth(); ++x) { for (int y = 0; y < this.gameMap.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = mapToCopy.get(position); this.map.put(position, entity); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { return playerPosition.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { return map.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { if (undoQuotaLeft == -1) { return Optional.empty(); } else { return Optional.of(undoQuotaLeft); } }",
        "label": "P"
    },
    "446": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.gameState = gameState; this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; int numPlayer = gameState.getAllPlayerPositions().size(); if (numPlayer > 2) { throw new IllegalArgumentException(\"There are more than two players in the map.\"); } } public void run() { System.out.println(\"Sokoban game is ready.\"); renderingEngine.render(this.gameState); while (!shouldStop()) { if (state.getUndoQuota().isPresent()) { renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get().toString()); } else { renderingEngine.message(\"Unlimited\"); } renderingEngine.message(\">>>\"); Action action = inputEngine.fetchAction(); ActionResult actionResult = processAction(action); if (actionResult instanceof ActionResult.Failed) { ActionResult.Failed failActionResult = (ActionResult.Failed) actionResult; if (!failActionResult.getReason().isEmpty()) { renderingEngine.message(failActionResult.getReason()); } } renderingEngine.render(this.gameState); } renderingEngine.message(\"Game exits.\"); if (state.isWin()) { renderingEngine.message(\"You win.\"); } }",
        "label": "P"
    },
    "447": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.gameState = gameState; this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; int numPlayer = gameState.getAllPlayerPositions().size(); if (numPlayer > 2) { throw new IllegalArgumentException(\"There are more than two players in the map.\"); } }",
        "label": "P"
    },
    "448": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { outputSteam.println(content); }",
        "label": "P"
    },
    "449": {
        "dataset": "COMP 3021",
        "project": "zgaoao",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { moveHistory = new ArrayList<>(); if (map.getUndoLimit().isPresent()) { undoQuotaLeft = map.getUndoLimit().get(); } else { undoQuotaLeft = -1; } gameMap = map; playerPosition = new HashMap<>(); boxPosition = new HashMap<>(); this.map = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) { for (int y = 0; y < map.getMaxHeight(); ++y) { Position position = Position.of(x, y); var entity = map.getEntity(position); if (entity instanceof Player) { var player = (Player)entity; playerPosition.put(player.getId(), position); } else if (entity instanceof Box) { var box = (Box)entity; boxPosition.put(box, position); } this.map.put(position, entity); } } this.checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "450": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { //TODO return maxWidth; } public int getMaxHeight() { //TODO return maxHeight; } public Optional<Integer> getUndoLimit() { //TODO return Optional.of(undoLimit); }",
        "label": "P"
    },
    "451": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "452": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "453": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "454": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "455": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "456": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (box_loc.contains(position)){ return new Box(box.get(box_loc.indexOf(position))); } else if (player_loc.contains(position)){ return new Player(player.get(player_loc.indexOf(position))); } else if (map.getEntity(position) instanceof Wall){ return new Wall(); } else if (effective_loc.contains(position)){ return new Empty(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "457": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (box_loc.contains(position)){ return new Box(box.get(box_loc.indexOf(position))); } else if (player_loc.contains(position)){ return new Player(player.get(player_loc.indexOf(position))); } else if (map.getEntity(position) instanceof Wall){ return new Wall(); } else if (effective_loc.contains(position)){ return new Empty(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "458": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { //TODO return maxHeight; }",
        "label": "P"
    },
    "459": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { //TODO return maxWidth; }",
        "label": "P"
    },
    "460": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (box_loc.contains(position)){ return new Box(box.get(box_loc.indexOf(position))); } else if (player_loc.contains(position)){ return new Player(player.get(player_loc.indexOf(position))); } else if (map.getEntity(position) instanceof Wall){ return new Wall(); } else if (effective_loc.contains(position)){ return new Empty(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "461": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (box_loc.contains(position)){ return new Box(box.get(box_loc.indexOf(position))); } else if (player_loc.contains(position)){ return new Player(player.get(player_loc.indexOf(position))); } else if (map.getEntity(position) instanceof Wall){ return new Wall(); } else if (effective_loc.contains(position)){ return new Empty(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "462": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (box_loc.contains(position)){ return new Box(box.get(box_loc.indexOf(position))); } else if (player_loc.contains(position)){ return new Player(player.get(player_loc.indexOf(position))); } else if (map.getEntity(position) instanceof Wall){ return new Wall(); } else if (effective_loc.contains(position)){ return new Empty(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "463": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (box_loc.contains(position)){ return new Box(box.get(box_loc.indexOf(position))); } else if (player_loc.contains(position)){ return new Player(player.get(player_loc.indexOf(position))); } else if (map.getEntity(position) instanceof Wall){ return new Wall(); } else if (effective_loc.contains(position)){ return new Empty(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "464": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // // TODO switch (inputLine.toLowerCase()) { case \"w\": { return new Move.Up(0); } case \"a\": { return new Move.Left(0); } case \"s\": { return new Move.Down(0); } case \"d\": { return new Move.Right(0); } case \"h\": { return new Move.Up(1); } case \"j\": { return new Move.Left(1); } case \"k\": { return new Move.Down(1); } case \"l\": { return new Move.Right(1); } case \"u\": { return new Undo(0); } case \"exit\": { return new Exit(0); } case default: { return new InvalidInput(0, \"Invalid Input\"); } } } }",
        "label": "P"
    },
    "465": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public void move(Position from, Position to) { // TODO ArrayList<Position> move = new ArrayList<>(); move.add(from); move.add(to); if (player_loc.contains(from)){ player_loc.set(player_loc.indexOf(from), to); } else if (box_loc.contains(from)){ box_loc.set(box_loc.indexOf(from), to); } move_history.add(move); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "466": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public void move(Position from, Position to) { // TODO ArrayList<Position> move = new ArrayList<>(); move.add(from); move.add(to); if (player_loc.contains(from)){ player_loc.set(player_loc.indexOf(from), to); } else if (box_loc.contains(from)){ box_loc.set(box_loc.indexOf(from), to); } move_history.add(move); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if (player.contains(id)) { return player_loc.get(player.indexOf(id)); } else { return(Position.of(-10000, -10000)); } }",
        "label": "P"
    },
    "467": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public void move(Position from, Position to) { // TODO ArrayList<Position> move = new ArrayList<>(); move.add(from); move.add(to); if (player_loc.contains(from)){ player_loc.set(player_loc.indexOf(from), to); } else if (box_loc.contains(from)){ box_loc.set(box_loc.indexOf(from), to); } move_history.add(move); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if (player.contains(id)) { return player_loc.get(player.indexOf(id)); } else { return(Position.of(-10000, -10000)); } } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (box_loc.contains(position)){ return new Box(box.get(box_loc.indexOf(position))); } else if (player_loc.contains(position)){ return new Player(player.get(player_loc.indexOf(position))); } else if (map.getEntity(position) instanceof Wall){ return new Wall(); } else if (effective_loc.contains(position)){ return new Empty(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "468": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public Optional<Integer> getUndoQuota() { // TODO return Optional.of(undo); }",
        "label": "P"
    },
    "469": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO var player_loc_set = new HashSet<Position>(); player_loc_set.addAll(player_loc); return player_loc_set; }",
        "label": "P"
    },
    "470": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public void move(Position from, Position to) { // TODO ArrayList<Position> move = new ArrayList<>(); move.add(from); move.add(to); if (player_loc.contains(from)){ player_loc.set(player_loc.indexOf(from), to); } else if (box_loc.contains(from)){ box_loc.set(box_loc.indexOf(from), to); } move_history.add(move); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { checkpoint.addAll(move_history); move_times.add(move_history.size()); move_history.removeAll(move_history); } public void undo() { // TODO if (!checkpoint.isEmpty()){ for (int i = 0; i < move_times.get(move_times.size()-1); i++){ Position from = checkpoint.get(checkpoint.size()-1).get(1); Position to = checkpoint.get(checkpoint.size()-1).get(0); if (player_loc.contains(from)){ player_loc.set(player_loc.indexOf(from), to); } else if (box_loc.contains(from)){ box_loc.set(box_loc.indexOf(from), to); } checkpoint.remove(checkpoint.size()-1); } move_times.remove(move_times.size()-1); if (undo != -1){ undo--; } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO if (player.contains(id)) { return player_loc.get(player.indexOf(id)); } else { return(Position.of(-10000, -10000)); } } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (box_loc.contains(position)){ return new Box(box.get(box_loc.indexOf(position))); } else if (player_loc.contains(position)){ return new Player(player.get(player_loc.indexOf(position))); } else if (map.getEntity(position) instanceof Wall){ return new Wall(); } else if (effective_loc.contains(position)){ return new Empty(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return Optional.of(undo); }",
        "label": "P"
    },
    "471": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } } public void run() { // TODO renderingEngine.message(\"Sokoban game is ready.\\n\"); renderingEngine.render(state); if(state.getUndoQuota().orElse(0) != -1){renderingEngine.message(\"\\nUndo Quota: \"+state.getUndoQuota().orElse(0)+\"\\n\");} else{renderingEngine.message(\"\\nUnlimited\\n\");} while (true){ var actionResult = processAction(inputEngine.fetchAction()); if (actionResult instanceof ActionResult.Failed fail) { renderingEngine.message(fail.getReason()); } renderingEngine.render(state); if(state.getUndoQuota().orElse(0) != -1){renderingEngine.message(\"\\nUndo Quota: \"+state.getUndoQuota().orElse(0)+\"\\n\");} else{renderingEngine.message(\"\\nUnlimited\\n\");} if (actionResult.getAction() instanceof Exit || shouldStop()){ renderingEngine.message(\"Game exits.\\n\"); break; } } if (state.isWin()){ renderingEngine.message(\"You win.\"); } }",
        "label": "P"
    },
    "472": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } }",
        "label": "P"
    },
    "473": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.print(content); }",
        "label": "F"
    },
    "474": {
        "dataset": "COMP 3021",
        "project": "khyanaa",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; player_loc = map.getInit_player_loc(); player = map.getInit_player(); if(map.getUndoLimit().isPresent()){ undo = map.getUndoLimit().get(); } box = map.getInit_box(); box_loc = map.getInit_box_loc(); effective_loc = map.getEffective_loc(); move_history = new ArrayList<>(); checkpoint = new ArrayList<>(); move_times = new ArrayList<>(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "475": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; //throw new NotImplementedException(); } public int getMaxHeight() { // TODO return maxHeight; //throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return (undoLimit == -1 ? null : undoLimit).describeConstable(); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "476": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "477": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "478": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "479": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "480": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "481": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (var player: curPlayers) { if (player.pos().x() == position.x() && player.pos().y() == position.y()) return player.player(); } for (var box: curBoxes) { if (box.pos().x() == position.x() && box.pos().y() == position.y()) return box.box(); } for (var pos:walls) { if (pos.x() == position.x() && pos.y() == position.y()) return new Wall(); } for (var pos:spaces) { if (pos.x() == position.x() && pos.y() == position.y()) return new Empty(); } return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "482": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (var player: curPlayers) { if (player.pos().x() == position.x() && player.pos().y() == position.y()) return player.player(); } for (var box: curBoxes) { if (box.pos().x() == position.x() && box.pos().y() == position.y()) return box.box(); } for (var pos:walls) { if (pos.x() == position.x() && pos.y() == position.y()) return new Wall(); } for (var pos:spaces) { if (pos.x() == position.x() && pos.y() == position.y()) return new Empty(); } return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "483": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "484": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "485": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return dests; //throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (var player: curPlayers) { if (player.pos().x() == position.x() && player.pos().y() == position.y()) return player.player(); } for (var box: curBoxes) { if (box.pos().x() == position.x() && box.pos().y() == position.y()) return box.box(); } for (var pos:walls) { if (pos.x() == position.x() && pos.y() == position.y()) return new Wall(); } for (var pos:spaces) { if (pos.x() == position.x() && pos.y() == position.y()) return new Empty(); } return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "486": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (var player: curPlayers) { if (player.pos().x() == position.x() && player.pos().y() == position.y()) return player.player(); } for (var box: curBoxes) { if (box.pos().x() == position.x() && box.pos().y() == position.y()) return box.box(); } for (var pos:walls) { if (pos.x() == position.x() && pos.y() == position.y()) return new Wall(); } for (var pos:spaces) { if (pos.x() == position.x() && pos.y() == position.y()) return new Empty(); } return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "487": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (var player: curPlayers) { if (player.pos().x() == position.x() && player.pos().y() == position.y()) return player.player(); } for (var box: curBoxes) { if (box.pos().x() == position.x() && box.pos().y() == position.y()) return box.box(); } for (var pos:walls) { if (pos.x() == position.x() && pos.y() == position.y()) return new Wall(); } for (var pos:spaces) { if (pos.x() == position.x() && pos.y() == position.y()) return new Empty(); } return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "488": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (var player: curPlayers) { if (player.pos().x() == position.x() && player.pos().y() == position.y()) return player.player(); } for (var box: curBoxes) { if (box.pos().x() == position.x() && box.pos().y() == position.y()) return box.box(); } for (var pos:walls) { if (pos.x() == position.x() && pos.y() == position.y()) return new Wall(); } for (var pos:spaces) { if (pos.x() == position.x() && pos.y() == position.y()) return new Empty(); } return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "489": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO switch(inputLine){ case \"w\" : { return new Move.Up(0); } case \"a\" : { return new Move.Left(0); } case \"s\" : { return new Move.Down(0); } case \"d\" : { return new Move.Right(0); } case \"k\" : { return new Move.Up(1); } case \"h\" : { return new Move.Left(1); } case \"j\" : { return new Move.Down(1); } case \"l\" : { return new Move.Right(1); } case \"r\" : { return new Undo(0); } case \"W\" : { return new Move.Up(0); } case \"A\" : { return new Move.Left(0); } case \"S\" : { return new Move.Down(0); } case \"D\" : { return new Move.Right(0); } case \"K\" : { return new Move.Up(1); } case \"H\" : { return new Move.Left(1); } case \"J\" : { return new Move.Down(1); } case \"L\" : { return new Move.Right(1); } case \"R\" : { return new Undo(0); } case \"exit\" : { return new Exit(0); } case \"EXIT\" : { return new Exit(0); } default : { return new InvalidInput(0,\"illgeal input\"); } } }",
        "label": "P"
    },
    "490": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO //checkpoint(); //int x = to.x() - from.x(); //int y = to.y() - from.y(); var tempOBJ = getEntity(from); if(tempOBJ instanceof Player p) { /* if(getEntity(to) instanceof Box b) if(b.getPlayerId() == p.getId()) { curBoxes.removeIf(temp -> temp.box.getPlayerId() == b.getPlayerId()&& temp.pos().x() == from.x() && temp.pos.y() == from.y()); curBoxes.add(new BoxRec(b, Position.of(to.x()+x,to.y()+y))); //checkpoint(); }*/ curPlayers.removeIf(temp -> temp.player().getId() == p.getId()); curPlayers.add(new PlayerRec(p,to)); } if(tempOBJ instanceof Box b){ curBoxes.removeIf(temp -> temp.box().getPlayerId() == b.getPlayerId() && temp.pos().x() == from.x() && temp.pos.y() == from.y()) ; curBoxes.add(new BoxRec(b,to)); //checkpoint(); } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "491": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO //checkpoint(); //int x = to.x() - from.x(); //int y = to.y() - from.y(); var tempOBJ = getEntity(from); if(tempOBJ instanceof Player p) { /* if(getEntity(to) instanceof Box b) if(b.getPlayerId() == p.getId()) { curBoxes.removeIf(temp -> temp.box.getPlayerId() == b.getPlayerId()&& temp.pos().x() == from.x() && temp.pos.y() == from.y()); curBoxes.add(new BoxRec(b, Position.of(to.x()+x,to.y()+y))); //checkpoint(); }*/ curPlayers.removeIf(temp -> temp.player().getId() == p.getId()); curPlayers.add(new PlayerRec(p,to)); } if(tempOBJ instanceof Box b){ curBoxes.removeIf(temp -> temp.box().getPlayerId() == b.getPlayerId() && temp.pos().x() == from.x() && temp.pos.y() == from.y()) ; curBoxes.add(new BoxRec(b,to)); //checkpoint(); } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (var p: curPlayers) { if (p.player.getId() == id) return (p.pos); } return null; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "492": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO //checkpoint(); //int x = to.x() - from.x(); //int y = to.y() - from.y(); var tempOBJ = getEntity(from); if(tempOBJ instanceof Player p) { /* if(getEntity(to) instanceof Box b) if(b.getPlayerId() == p.getId()) { curBoxes.removeIf(temp -> temp.box.getPlayerId() == b.getPlayerId()&& temp.pos().x() == from.x() && temp.pos.y() == from.y()); curBoxes.add(new BoxRec(b, Position.of(to.x()+x,to.y()+y))); //checkpoint(); }*/ curPlayers.removeIf(temp -> temp.player().getId() == p.getId()); curPlayers.add(new PlayerRec(p,to)); } if(tempOBJ instanceof Box b){ curBoxes.removeIf(temp -> temp.box().getPlayerId() == b.getPlayerId() && temp.pos().x() == from.x() && temp.pos.y() == from.y()) ; curBoxes.add(new BoxRec(b,to)); //checkpoint(); } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (var p: curPlayers) { if (p.player.getId() == id) return (p.pos); } return null; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (var player: curPlayers) { if (player.pos().x() == position.x() && player.pos().y() == position.y()) return player.player(); } for (var box: curBoxes) { if (box.pos().x() == position.x() && box.pos().y() == position.y()) return box.box(); } for (var pos:walls) { if (pos.x() == position.x() && pos.y() == position.y()) return new Wall(); } for (var pos:spaces) { if (pos.x() == position.x() && pos.y() == position.y()) return new Empty(); } return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "493": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO if(undos == -1) return Optional.empty(); return Optional.of(undos); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "494": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> tempset = new HashSet<>(); for (var p: curPlayers) { tempset.add(p.pos()); } return tempset; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "495": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO //checkpoint(); //int x = to.x() - from.x(); //int y = to.y() - from.y(); var tempOBJ = getEntity(from); if(tempOBJ instanceof Player p) { /* if(getEntity(to) instanceof Box b) if(b.getPlayerId() == p.getId()) { curBoxes.removeIf(temp -> temp.box.getPlayerId() == b.getPlayerId()&& temp.pos().x() == from.x() && temp.pos.y() == from.y()); curBoxes.add(new BoxRec(b, Position.of(to.x()+x,to.y()+y))); //checkpoint(); }*/ curPlayers.removeIf(temp -> temp.player().getId() == p.getId()); curPlayers.add(new PlayerRec(p,to)); } if(tempOBJ instanceof Box b){ curBoxes.removeIf(temp -> temp.box().getPlayerId() == b.getPlayerId() && temp.pos().x() == from.x() && temp.pos.y() == from.y()) ; curBoxes.add(new BoxRec(b,to)); //checkpoint(); } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO List<PlayerRec> tempplayers = new ArrayList<>(curPlayers); List<BoxRec> tempboxes = new ArrayList<>(curBoxes); Snapshots.push(new Snapshot(new ArrayList<>(tempplayers),new ArrayList<>(tempboxes))); //throw new NotImplementedException(); } public void undo() { // TODO if (!Snapshots.empty()) { Snapshots.pop(); } undos -= 1; if(Snapshots.empty()) { curPlayers = new ArrayList<>(initPlayers); curBoxes = new ArrayList<>(initBoxes); return; } var recover = Snapshots.peek(); curPlayers = new ArrayList<>(recover.cur_players()); curBoxes = new ArrayList<>(recover.cur_boxes()); //throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (var p: curPlayers) { if (p.player.getId() == id) return (p.pos); } return null; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (var player: curPlayers) { if (player.pos().x() == position.x() && player.pos().y() == position.y()) return player.player(); } for (var box: curBoxes) { if (box.pos().x() == position.x() && box.pos().y() == position.y()) return box.box(); } for (var pos:walls) { if (pos.x() == position.x() && pos.y() == position.y()) return new Wall(); } for (var pos:spaces) { if (pos.x() == position.x() && pos.y() == position.y()) return new Empty(); } return null; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if(undos == -1) return Optional.empty(); return Optional.of(undos); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "496": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO var Num_players = gameState.getAllPlayerPositions().size(); if (Num_players > 2) throw new IllegalArgumentException(); // Check the number of players } public void run() { // TODO while (!shouldStop()){ renderingEngine.render(this.state); processAction(inputEngine.fetchAction()); } }",
        "label": "F"
    },
    "497": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO var Num_players = gameState.getAllPlayerPositions().size(); if (Num_players > 2) throw new IllegalArgumentException(); // Check the number of players }",
        "label": "P"
    },
    "498": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "499": {
        "dataset": "COMP 3021",
        "project": "kywongcb",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undos = map.undoLimit; dests = map.getDestinations(); width = map.getMaxWidth(); height = map.getMaxHeight(); steps.add(map.map); walls = map.walls; spaces = map.spaces; initPlayers = map.playerloc; initBoxes = map.boxloc; curBoxes = new ArrayList<>(initBoxes); curPlayers = new ArrayList<>(initPlayers); //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "500": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return this.maxWidth; } public int getMaxHeight() { return this.maxHeight; } public Optional<Integer> getUndoLimit() { return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "501": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "502": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "503": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "504": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "505": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "506": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxPos.get(position) != null){ return boxPos.get(position); } else if (playerPos.get(position) != null) { return playerPos.get(position); } else if (emptyPos.get(position) != null) { return emptyPos.get(position); } else { return gameMap.getEntity(position); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "507": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxPos.get(position) != null){ return boxPos.get(position); } else if (playerPos.get(position) != null) { return playerPos.get(position); } else if (emptyPos.get(position) != null) { return emptyPos.get(position); } else { return gameMap.getEntity(position); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "508": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return this.maxHeight; }",
        "label": "P"
    },
    "509": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return this.maxWidth; }",
        "label": "P"
    },
    "510": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return this.gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { if (boxPos.get(position) != null){ return boxPos.get(position); } else if (playerPos.get(position) != null) { return playerPos.get(position); } else if (emptyPos.get(position) != null) { return emptyPos.get(position); } else { return gameMap.getEntity(position); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "511": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxPos.get(position) != null){ return boxPos.get(position); } else if (playerPos.get(position) != null) { return playerPos.get(position); } else if (emptyPos.get(position) != null) { return emptyPos.get(position); } else { return gameMap.getEntity(position); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "512": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxPos.get(position) != null){ return boxPos.get(position); } else if (playerPos.get(position) != null) { return playerPos.get(position); } else if (emptyPos.get(position) != null) { return emptyPos.get(position); } else { return gameMap.getEntity(position); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "513": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxPos.get(position) != null){ return boxPos.get(position); } else if (playerPos.get(position) != null) { return playerPos.get(position); } else if (emptyPos.get(position) != null) { return emptyPos.get(position); } else { return gameMap.getEntity(position); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "514": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); String lcinput = inputLine.toLowerCase(); if (lcinput.equals(\"exit\")) { return new Exit(-1); } else if (lcinput.equals(\"u\")) { return new Undo(-1); } else if (lcinput.matches(\"a|s|d|w\")) { switch (lcinput) { case \"a\": return new Move.Left(0); case \"s\": return new Move.Down(0); case \"d\": return new Move.Right(0); case \"w\": return new Move.Up(0); default: return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } } else if (lcinput.matches(\"h|j|k|l\")) { switch (lcinput) { case \"h\": return new Move.Left(1); case \"j\": return new Move.Down(1); case \"k\": return new Move.Right(1); case \"l\": return new Move.Up(1); default: return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } } else { return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "515": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public void move(Position from, Position to) { var entity = getEntity(from); if (entity instanceof Box){ this.boxPos.put(to,entity); this.boxPos.remove(from); this.emptyPos.put(from,new Empty()); } if (entity instanceof Player){ this.playerPos.put(to,entity); this.playerPos.remove(from); this.emptyPos.put(from,new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "516": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public void move(Position from, Position to) { var entity = getEntity(from); if (entity instanceof Box){ this.boxPos.put(to,entity); this.boxPos.remove(from); this.emptyPos.put(from,new Empty()); } if (entity instanceof Player){ this.playerPos.put(to,entity); this.playerPos.remove(from); this.emptyPos.put(from,new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return this.playerPos.entrySet() .stream() .filter(entry -> ((Player) entry.getValue()).getId() == id) .map(Map.Entry::getKey) .findFirst() .orElse(null); }",
        "label": "P"
    },
    "517": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public void move(Position from, Position to) { var entity = getEntity(from); if (entity instanceof Box){ this.boxPos.put(to,entity); this.boxPos.remove(from); this.emptyPos.put(from,new Empty()); } if (entity instanceof Player){ this.playerPos.put(to,entity); this.playerPos.remove(from); this.emptyPos.put(from,new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return this.playerPos.entrySet() .stream() .filter(entry -> ((Player) entry.getValue()).getId() == id) .map(Map.Entry::getKey) .findFirst() .orElse(null); } public @Nullable Entity getEntity(@NotNull Position position) { if (boxPos.get(position) != null){ return boxPos.get(position); } else if (playerPos.get(position) != null) { return playerPos.get(position); } else if (emptyPos.get(position) != null) { return emptyPos.get(position); } else { return gameMap.getEntity(position); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "518": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public Optional<Integer> getUndoQuota() { if (this.undo < 0) return Optional.empty(); return Optional.of(this.undo); }",
        "label": "P"
    },
    "519": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { return new HashSet<>(this.playerPos.keySet()); }",
        "label": "P"
    },
    "520": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public void move(Position from, Position to) { var entity = getEntity(from); if (entity instanceof Box){ this.boxPos.put(to,entity); this.boxPos.remove(from); this.emptyPos.put(from,new Empty()); } if (entity instanceof Player){ this.playerPos.put(to,entity); this.playerPos.remove(from); this.emptyPos.put(from,new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { checkpoint.add(new GameState(this)); } public void undo() { int size = checkpoint.size(); if (checkpoint.size()==1){ this.boxPos = copyHashMap(checkpoint.get(0).boxPos); this.playerPos = copyHashMap(checkpoint.get(0).playerPos); this.emptyPos = copyHashMap(checkpoint.get(0).emptyPos); return; } this.boxPos = copyHashMap(checkpoint.get(size-2).boxPos); this.playerPos = copyHashMap(checkpoint.get(size-2).playerPos); this.emptyPos = copyHashMap(checkpoint.get(size-2).emptyPos); this.undo = this.undo -1; this.checkpoint.remove(size-1); } public @Nullable Position getPlayerPositionById(int id) { return this.playerPos.entrySet() .stream() .filter(entry -> ((Player) entry.getValue()).getId() == id) .map(Map.Entry::getKey) .findFirst() .orElse(null); } public @Nullable Entity getEntity(@NotNull Position position) { if (boxPos.get(position) != null){ return boxPos.get(position); } else if (playerPos.get(position) != null) { return playerPos.get(position); } else if (emptyPos.get(position) != null) { return emptyPos.get(position); } else { return gameMap.getEntity(position); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { if (this.undo < 0) return Optional.empty(); return Optional.of(this.undo); }",
        "label": "P"
    },
    "521": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); } public void run() { this.renderingEngine.message(GAME_READY_MESSAGE); this.renderingEngine.render(super.state); while(!shouldStop()){ if (state.getUndoQuota().isEmpty()) this.renderingEngine.message(UNDO_QUOTA_UNLIMITED); else this.renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get()); this.renderingEngine.message(\">>>\"); Action action = this.inputEngine.fetchAction(); ActionResult result = super.processAction(action); if (result.getAction() instanceof Exit) { this.renderingEngine.message(GAME_EXIT_MESSAGE); break; } if (result instanceof ActionResult.Failed) this.renderingEngine.message(((ActionResult.Failed) result).getReason()); this.renderingEngine.render(state); } this.renderingEngine.message(WIN_MESSAGE); }",
        "label": "F"
    },
    "522": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "523": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { this.outputSteam.println(content); // Hint: System.out is also a PrintStream. }",
        "label": "P"
    },
    "524": {
        "dataset": "COMP 3021",
        "project": "yshinab",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.playerPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Player) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); if (this.playerPos.size() > new HashSet<Object>(this.playerPos.values()).size() || this.playerPos.size() > 26){ throw new IllegalArgumentException(\"There are either too many or duplicate players in this map\"); } this.boxPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Box) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.emptyPos = map.entityPos.entrySet().stream() .filter(o -> o.getValue() instanceof Empty) .collect(Collectors.toMap(o -> o.getKey(), o -> o.getValue(), (prev, next) -> next, HashMap::new)); this.undo = map.getUndoLimit().get(); this.checkpoint.add(new GameState(this)); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "525": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO if (this.undoLimit < -1) { return null; } else if (this.undoLimit == -1) { return Optional.empty(); } else { return Optional.ofNullable(this.undoLimit); } }",
        "label": "P"
    },
    "526": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "527": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "528": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "529": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "530": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "531": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if ((position.x()) > currentMap.getMaxWidth() - 1 || (position.y()) > currentMap.getMaxHeight()- 1 || (position.x()) < 0|| (position.y()) < 0) { this.errorMsg = \"position out of bound\"; return null; } return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "532": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if ((position.x()) > currentMap.getMaxWidth() - 1 || (position.y()) > currentMap.getMaxHeight()- 1 || (position.x()) < 0|| (position.y()) < 0) { this.errorMsg = \"position out of bound\"; return null; } return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "533": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "534": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "535": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return currentMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if ((position.x()) > currentMap.getMaxWidth() - 1 || (position.y()) > currentMap.getMaxHeight()- 1 || (position.x()) < 0|| (position.y()) < 0) { this.errorMsg = \"position out of bound\"; return null; } return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "536": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if ((position.x()) > currentMap.getMaxWidth() - 1 || (position.y()) > currentMap.getMaxHeight()- 1 || (position.x()) < 0|| (position.y()) < 0) { this.errorMsg = \"position out of bound\"; return null; } return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "537": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if ((position.x()) > currentMap.getMaxWidth() - 1 || (position.y()) > currentMap.getMaxHeight()- 1 || (position.x()) < 0|| (position.y()) < 0) { this.errorMsg = \"position out of bound\"; return null; } return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "538": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if ((position.x()) > currentMap.getMaxWidth() - 1 || (position.y()) > currentMap.getMaxHeight()- 1 || (position.x()) < 0|| (position.y()) < 0) { this.errorMsg = \"position out of bound\"; return null; } return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "539": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO switch (inputLine) { // pattern matching using objects in switch statement case \"w\": case \"W\": return new Move.Up(0); case \"a\": case \"A\": return new Move.Left(0); case \"s\": case \"S\": return new Move.Down(0); case \"d\": case \"D\": return new Move.Right(0); case \"k\": case \"K\": return new Move.Up(1); case \"h\": case \"H\": return new Move.Left(1); case \"j\": case \"J\": return new Move.Down(1); case \"l\": case \"L\": return new Move.Right(1); case \"u\": case \"U\": return new Undo(-1); case \"exit\": case \"EXIT\": return new Exit(-1); default: return new InvalidInput(-1, \"Invalid input\"); } }",
        "label": "P"
    },
    "540": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public void move(Position from, Position to) { // TODO currentMap.putEntity(to, currentMap.getEntity(from)); if (currentMap.getDestinations().contains(from)) { currentMap.putEntity(from, new Empty(true)); } else { currentMap.putEntity(from, new Empty(false)); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "541": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public void move(Position from, Position to) { // TODO currentMap.putEntity(to, currentMap.getEntity(from)); if (currentMap.getDestinations().contains(from)) { currentMap.putEntity(from, new Empty(true)); } else { currentMap.putEntity(from, new Empty(false)); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Integer j = 0; j < currentMap.getMaxHeight(); j++) { for (Integer i = 0; i < currentMap.getMaxWidth(); i++) { Entity temp = currentMap.getEntity(Position.of(i, j)); if (temp instanceof Player && ((Player) temp).getId() == id){ return Position.of(i, j); } } } this.errorMsg = \"Player not found\"; return null; }",
        "label": "P"
    },
    "542": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public void move(Position from, Position to) { // TODO currentMap.putEntity(to, currentMap.getEntity(from)); if (currentMap.getDestinations().contains(from)) { currentMap.putEntity(from, new Empty(true)); } else { currentMap.putEntity(from, new Empty(false)); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Integer j = 0; j < currentMap.getMaxHeight(); j++) { for (Integer i = 0; i < currentMap.getMaxWidth(); i++) { Entity temp = currentMap.getEntity(Position.of(i, j)); if (temp instanceof Player && ((Player) temp).getId() == id){ return Position.of(i, j); } } } this.errorMsg = \"Player not found\"; return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if ((position.x()) > currentMap.getMaxWidth() - 1 || (position.y()) > currentMap.getMaxHeight()- 1 || (position.x()) < 0|| (position.y()) < 0) { this.errorMsg = \"position out of bound\"; return null; } return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "543": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public Optional<Integer> getUndoQuota() { // TODO if (!currentMap.getUndoLimit().isPresent()) { return null; } else if (currentMap.getUndoLimit().isEmpty()) { return Optional.empty(); } else { return currentMap.getUndoLimit(); } }",
        "label": "P"
    },
    "544": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> result = new HashSet<>(); Set<Integer> playerID = currentMap.getPlayerIds(); for (Integer i = 0; i < currentMap.getMaxWidth(); i++) { for (Integer j = 0; j < currentMap.getMaxHeight(); j++) { Entity temp = currentMap.getEntity(Position.of(i,j)); if (temp instanceof Player && playerID.contains(((Player) temp).getId())){ result.add(Position.of(i,j)); } } } return result; }",
        "label": "P"
    },
    "545": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public void move(Position from, Position to) { // TODO currentMap.putEntity(to, currentMap.getEntity(from)); if (currentMap.getDestinations().contains(from)) { currentMap.putEntity(from, new Empty(true)); } else { currentMap.putEntity(from, new Empty(false)); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO mapCheckpoints.add(currentMap.getMapSnapshot()); } public void undo() { // TODO if (mapCheckpoints.size() == 1) { setErrorMsg(\"You are at first checkpoint already\"); } else if (currentMap.getUndoLimit().isPresent() && currentMap.getUndoLimit().get() == 0) { setErrorMsg(\"You have run out of your undo quota.\"); } else if (currentMap.getUndoLimit().isEmpty()) { currentMap.setMapSnapshot(mapCheckpoints.get(mapCheckpoints.size() - 2)); this.popCheckPoint(); } else { currentMap.deductUndoLimit(); currentMap.setMapSnapshot(mapCheckpoints.get(mapCheckpoints.size() - 2)); this.popCheckPoint(); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (Integer j = 0; j < currentMap.getMaxHeight(); j++) { for (Integer i = 0; i < currentMap.getMaxWidth(); i++) { Entity temp = currentMap.getEntity(Position.of(i, j)); if (temp instanceof Player && ((Player) temp).getId() == id){ return Position.of(i, j); } } } this.errorMsg = \"Player not found\"; return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if ((position.x()) > currentMap.getMaxWidth() - 1 || (position.y()) > currentMap.getMaxHeight()- 1 || (position.x()) < 0|| (position.y()) < 0) { this.errorMsg = \"position out of bound\"; return null; } return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (!currentMap.getUndoLimit().isPresent()) { return null; } else if (currentMap.getUndoLimit().isEmpty()) { return Optional.empty(); } else { return currentMap.getUndoLimit(); } }",
        "label": "P"
    },
    "546": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"Game only support at most two players.\"); } } public void run() { boolean isExit = false; // TODO renderingEngine.message(\"\"); renderingEngine.message(\"Sokoban game is ready.\"); renderingEngine.render(state); renderingEngine.message(\"\"); if (state.getUndoQuota() != null && state.getUndoQuota().isPresent()) { renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get().toString()); } else { renderingEngine.message(\"Undo Quota: infinity\"); } renderingEngine.message(\">>>\"); while (!isExit && !shouldStop()) { Action currentAction = inputEngine.fetchAction(); if (currentAction instanceof Exit) { isExit = true; renderingEngine.render(state); renderingEngine.message(\"\"); renderingEngine.message(\"Game exits.\"); } else { processAction(currentAction); if (state.getErrorMsg() != \"normal\") { renderingEngine.message(state.getErrorMsg()); } renderingEngine.render(state); renderingEngine.message(\"\"); if (state.getUndoQuota() != null && state.getUndoQuota().isPresent()) { renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get().toString()); } else { renderingEngine.message(\"Undo Quota: infinity\"); } renderingEngine.message(\">>>\"); if (state.isWin()) { renderingEngine.message(\"You win!\"); } state.setErrorMsg(\"normal\"); } } }",
        "label": "P"
    },
    "547": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"Game only support at most two players.\"); } }",
        "label": "P"
    },
    "548": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "549": {
        "dataset": "COMP 3021",
        "project": "yysze",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO currentMap = map; mapCheckpoints = new ArrayList<>(); mapCheckpoints.add(map.getMapSnapshot()); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "550": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; } public int getMaxHeight() { // TODO return maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undoLimit); }",
        "label": "P"
    },
    "551": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "552": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "553": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "554": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "555": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "556": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return space.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "557": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return space.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "558": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; }",
        "label": "P"
    },
    "559": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; }",
        "label": "P"
    },
    "560": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return space.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "561": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return space.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "562": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return space.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "563": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return space.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "564": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO switch (inputLine) { case \"exit\": return new Exit(0); case \"A\": case \"a\": return new Move.Left(0); case \"S\": case \"s\": return new Move.Down(0); case \"W\": case \"w\": return new Move.Up(0); case \"D\": case \"d\": return new Move.Right(0); case \"H\": case \"h\": return new Move.Left(1); case \"J\": case \"j\": return new Move.Down(1); case \"K\": case \"k\": return new Move.Up(1); case \"L\": case \"l\": return new Move.Right(1); case \"U\": case \"u\": return new Undo(0); default: return new InvalidInput(0, \"invalidKey\"); } }",
        "label": "P"
    },
    "565": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public void move(Position from, Position to) { // TODO Entity fromEntity = space.get(from); if(fromEntity instanceof Player){ Player play = (Player) fromEntity; players.remove(play); players.put(play,to); space.put(from,new Empty()); space.put(to,play); } else if(fromEntity instanceof Box){ Box box = (Box) fromEntity; boxes.remove(box); boxes.put(box,to); space.put(from,new Empty()); space.put(to,box); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "566": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public void move(Position from, Position to) { // TODO Entity fromEntity = space.get(from); if(fromEntity instanceof Player){ Player play = (Player) fromEntity; players.remove(play); players.put(play,to); space.put(from,new Empty()); space.put(to,play); } else if(fromEntity instanceof Box){ Box box = (Box) fromEntity; boxes.remove(box); boxes.put(box,to); space.put(from,new Empty()); space.put(to,box); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(Player play:players.keySet()){ if(play.getId() == id) return players.get(play); } return null; }",
        "label": "P"
    },
    "567": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public void move(Position from, Position to) { // TODO Entity fromEntity = space.get(from); if(fromEntity instanceof Player){ Player play = (Player) fromEntity; players.remove(play); players.put(play,to); space.put(from,new Empty()); space.put(to,play); } else if(fromEntity instanceof Box){ Box box = (Box) fromEntity; boxes.remove(box); boxes.put(box,to); space.put(from,new Empty()); space.put(to,box); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(Player play:players.keySet()){ if(play.getId() == id) return players.get(play); } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return space.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "568": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public Optional<Integer> getUndoQuota() { // TODO return (undoLeft == -1)?Optional.empty():Optional.of(undoLeft); }",
        "label": "P"
    },
    "569": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO HashSet<Position> positionSet = new HashSet<>(); for(Position pos:players.values()) positionSet.add(pos); return positionSet; }",
        "label": "P"
    },
    "570": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public void move(Position from, Position to) { // TODO Entity fromEntity = space.get(from); if(fromEntity instanceof Player){ Player play = (Player) fromEntity; players.remove(play); players.put(play,to); space.put(from,new Empty()); space.put(to,play); } else if(fromEntity instanceof Box){ Box box = (Box) fromEntity; boxes.remove(box); boxes.put(box,to); space.put(from,new Empty()); space.put(to,box); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO achieved.add(new Tale(this)); ptr = achieved.size() - 1; } public void undo() { // TODO if(undoLeft == 0) return; if(ptr == -1 || ptr == 0) return; achieved.remove(ptr--); Tale temp = achieved.get(ptr); players = (HashMap<Player, Position>) temp.getPlayers().clone(); boxes = (HashMap<Box, Position>) temp.getBoxes().clone(); space = (HashMap<Position, Entity>) temp.getSpace().clone(); if(undoLeft != -1) --undoLeft; } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for(Player play:players.keySet()){ if(play.getId() == id) return players.get(play); } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return space.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return (undoLeft == -1)?Optional.empty():Optional.of(undoLeft); }",
        "label": "P"
    },
    "571": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); Optional<Integer> undo = gameState.getUndoQuota(); renderingEngine.message(\"Sokoban game is ready.\"); renderingEngine.render(gameState); renderingEngine.message(String.format(\"Undo Quota: %s\",(undo.isPresent())?undo.get():\"Unlimited\")); renderingEngine.message(\">>>\"); } public void run() { // TODO ActionResult result = processAction(inputEngine.fetchAction()); Optional<Integer> undo = state.getUndoQuota(); renderingEngine.render(state); if(shouldStop()){ renderingEngine.message(\"Game exits.\"); renderingEngine.message(\"You win.\"); return; } if(result.getAction() instanceof Exit){ renderingEngine.message(\"Game exits.\"); return; } if(result instanceof ActionResult.Failed){ renderingEngine.message(((ActionResult.Failed) result).getReason()); } renderingEngine.message(String.format(\"Undo Quota: %s\",(undo.isPresent())?undo.get():\"Unlimited\")); renderingEngine.message(\">>>\"); run(); }",
        "label": "P"
    },
    "572": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); Optional<Integer> undo = gameState.getUndoQuota(); renderingEngine.message(\"Sokoban game is ready.\"); renderingEngine.render(gameState); renderingEngine.message(String.format(\"Undo Quota: %s\",(undo.isPresent())?undo.get():\"Unlimited\")); renderingEngine.message(\">>>\"); }",
        "label": "P"
    },
    "573": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "574": {
        "dataset": "COMP 3021",
        "project": "ppusitdhikul",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLeft = map.getUndoLimit().get(); this.players = map.getPlayers(); this.boxes = map.getBoxes(); this.space = map.getAll(); checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public String toString() { return \"Item{\" + \"letter=\" + letter + \", position=\" + position + \", type=\" + type + '}'; }",
        "label": "P"
    },
    "575": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO done return maxwidth; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO done return maxheight; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO done Optional<Integer> ans = Optional.of(undolimit); return ans; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "576": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "577": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "578": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "F"
    },
    "579": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "F"
    },
    "580": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "F"
    },
    "581": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO char temp = currentmap[position.y() + 1].charAt(position.x()); if (Character.isAlphabetic(temp)) { if (Character.isUpperCase(temp)) { return new Player(temp - 'A'); } else { return new Box(temp - 'a'); } } else { Entity ans = switch (temp) { case '#' -> new Wall(); case '.' -> new Empty(); case ' ' -> null; default -> new Empty(); }; return ans; //return new Empty(); // throw new NotImplementedException(); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "582": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO char temp = currentmap[position.y() + 1].charAt(position.x()); if (Character.isAlphabetic(temp)) { if (Character.isUpperCase(temp)) { return new Player(temp - 'A'); } else { return new Box(temp - 'a'); } } else { Entity ans = switch (temp) { case '#' -> new Wall(); case '.' -> new Empty(); case ' ' -> null; default -> new Empty(); }; return ans; //return new Empty(); // throw new NotImplementedException(); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "583": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO done return maxheight; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "584": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO done return maxwidth; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "585": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO Set<Position> listofdest = new HashSet<Position>(); return listofdest; // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO char temp = currentmap[position.y() + 1].charAt(position.x()); if (Character.isAlphabetic(temp)) { if (Character.isUpperCase(temp)) { return new Player(temp - 'A'); } else { return new Box(temp - 'a'); } } else { Entity ans = switch (temp) { case '#' -> new Wall(); case '.' -> new Empty(); case ' ' -> null; default -> new Empty(); }; return ans; //return new Empty(); // throw new NotImplementedException(); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "586": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO char temp = currentmap[position.y() + 1].charAt(position.x()); if (Character.isAlphabetic(temp)) { if (Character.isUpperCase(temp)) { return new Player(temp - 'A'); } else { return new Box(temp - 'a'); } } else { Entity ans = switch (temp) { case '#' -> new Wall(); case '.' -> new Empty(); case ' ' -> null; default -> new Empty(); }; return ans; //return new Empty(); // throw new NotImplementedException(); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "587": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO char temp = currentmap[position.y() + 1].charAt(position.x()); if (Character.isAlphabetic(temp)) { if (Character.isUpperCase(temp)) { return new Player(temp - 'A'); } else { return new Box(temp - 'a'); } } else { Entity ans = switch (temp) { case '#' -> new Wall(); case '.' -> new Empty(); case ' ' -> null; default -> new Empty(); }; return ans; //return new Empty(); // throw new NotImplementedException(); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "588": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO char temp = currentmap[position.y() + 1].charAt(position.x()); if (Character.isAlphabetic(temp)) { if (Character.isUpperCase(temp)) { return new Player(temp - 'A'); } else { return new Box(temp - 'a'); } } else { Entity ans = switch (temp) { case '#' -> new Wall(); case '.' -> new Empty(); case ' ' -> null; default -> new Empty(); }; return ans; //return new Empty(); // throw new NotImplementedException(); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "589": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO return new Exit(0); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "590": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "591": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO done for(int i = 0; i < mapp.getMaxHeight(); i++){ for(int j = 0; j < mapp.getMaxWidth(); j++){ if(mapp.getEntity(new Position(i,j)).getClass() == Player.class){ Player temp = (Player) mapp.getEntity(new Position(i,j)); if(temp.getId() == id){ return new Position(i,j); } else{ continue; } } } } return new Position(0,0); //throw new NotImplementedException(); }",
        "label": "F"
    },
    "592": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO done for(int i = 0; i < mapp.getMaxHeight(); i++){ for(int j = 0; j < mapp.getMaxWidth(); j++){ if(mapp.getEntity(new Position(i,j)).getClass() == Player.class){ Player temp = (Player) mapp.getEntity(new Position(i,j)); if(temp.getId() == id){ return new Position(i,j); } else{ continue; } } } } return new Position(0,0); //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO char temp = currentmap[position.y() + 1].charAt(position.x()); if (Character.isAlphabetic(temp)) { if (Character.isUpperCase(temp)) { return new Player(temp - 'A'); } else { return new Box(temp - 'a'); } } else { Entity ans = switch (temp) { case '#' -> new Wall(); case '.' -> new Empty(); case ' ' -> null; default -> new Empty(); }; return ans; //return new Empty(); // throw new NotImplementedException(); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "F"
    },
    "593": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO return Optional.empty(); // throw new NotImplementedException(); }",
        "label": "F"
    },
    "594": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO //mapp. return playerlist; //throw new NotImplementedException(); }",
        "label": "F"
    },
    "595": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO // throw new NotImplementedException(); } public void undo() { // TODO // throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO done for(int i = 0; i < mapp.getMaxHeight(); i++){ for(int j = 0; j < mapp.getMaxWidth(); j++){ if(mapp.getEntity(new Position(i,j)).getClass() == Player.class){ Player temp = (Player) mapp.getEntity(new Position(i,j)); if(temp.getId() == id){ return new Position(i,j); } else{ continue; } } } } return new Position(0,0); //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO char temp = currentmap[position.y() + 1].charAt(position.x()); if (Character.isAlphabetic(temp)) { if (Character.isUpperCase(temp)) { return new Player(temp - 'A'); } else { return new Box(temp - 'a'); } } else { Entity ans = switch (temp) { case '#' -> new Wall(); case '.' -> new Empty(); case ' ' -> null; default -> new Empty(); }; return ans; //return new Empty(); // throw new NotImplementedException(); } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return Optional.empty(); // throw new NotImplementedException(); }",
        "label": "F"
    },
    "596": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } // Check the number of players //throw new NotImplementedException(); } public void run() { // TODO //throw new NotImplementedException(); }",
        "label": "F"
    },
    "597": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } // Check the number of players //throw new NotImplementedException(); }",
        "label": "P"
    },
    "598": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO done outputSteam.println(content); // Hint: System.out is also a PrintStream. //throw new NotImplementedException(); }",
        "label": "P"
    },
    "599": {
        "dataset": "COMP 3021",
        "project": "yhngaq",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done? undoquota = map.getUndoLimit(); locationofcrate = getDestinations(); locationofplayer = null; mapp = map; currentmap = map.arrofstr; //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "F"
    },
    "600": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.width; } public int getMaxHeight() { // TODO return this.height; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.limitation); }",
        "label": "P"
    },
    "601": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "602": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "603": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "604": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "605": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "606": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return posEntity.get(Position.of(position.x(), position.y())); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "607": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return posEntity.get(Position.of(position.x(), position.y())); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "608": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.height; }",
        "label": "P"
    },
    "609": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.width; }",
        "label": "P"
    },
    "610": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return setDesPos; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return posEntity.get(Position.of(position.x(), position.y())); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "611": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return posEntity.get(Position.of(position.x(), position.y())); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "612": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return posEntity.get(Position.of(position.x(), position.y())); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "613": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return posEntity.get(Position.of(position.x(), position.y())); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "614": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); Action action = switch (inputLine.toLowerCase()) { case \"exit\" : yield new Exit(0); case \"w\" : yield new Move.Up(0); case \"a\" : yield new Move.Left(0); case \"s\" : yield new Move.Down(0); case \"d\" : yield new Move.Right(0); case \"h\" : yield new Move.Left(1); case \"j\" : yield new Move.Down(1); case \"k\" : yield new Move.Up(1); case \"l\" : yield new Move.Right(1); case \"u\" : yield new Undo(0); default : yield new InvalidInput(0, \"Invalid Input.\"); }; // TODO return action; }",
        "label": "P"
    },
    "615": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public void move(Position from, Position to) { // TODO Entity entity = posEntity.get(Position.of(from.x(), from.y())); posEntity.put(Position.of(from.x(), from.y()), new Empty()); posEntity.put(Position.of(to.x(), to.y()), entity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "616": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public void move(Position from, Position to) { // TODO Entity entity = posEntity.get(Position.of(from.x(), from.y())); posEntity.put(Position.of(from.x(), from.y()), new Empty()); posEntity.put(Position.of(to.x(), to.y()), entity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO // System.out.println(POS_ID); for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player p) { if (p.getId() == id) { return position; } } } return null; }",
        "label": "P"
    },
    "617": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public void move(Position from, Position to) { // TODO Entity entity = posEntity.get(Position.of(from.x(), from.y())); posEntity.put(Position.of(from.x(), from.y()), new Empty()); posEntity.put(Position.of(to.x(), to.y()), entity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO // System.out.println(POS_ID); for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player p) { if (p.getId() == id) { return position; } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return posEntity.get(Position.of(position.x(), position.y())); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "618": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public Optional<Integer> getUndoQuota() { // TODO return limit; }",
        "label": "P"
    },
    "619": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO return allPlayer; }",
        "label": "P"
    },
    "620": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public void move(Position from, Position to) { // TODO Entity entity = posEntity.get(Position.of(from.x(), from.y())); posEntity.put(Position.of(from.x(), from.y()), new Empty()); posEntity.put(Position.of(to.x(), to.y()), entity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO recordHash.add(new HashMap<>(posEntity)); } public void undo() { // TODO if (limit.isPresent()) { int undoLimit; if (limit.get() == -1) { undoLimit = limit.get(); } else { undoLimit = limit.get() - 1; } limit = Optional.of(undoLimit); } if (recordHash.size() == 0) { recordHash.add(new HashMap<>(initMap)); posEntity = new HashMap<>(initMap); } else if (recordHash.size() == 1) { recordHash.remove(0); posEntity = new HashMap<>(initMap); checkpoint(); } else { recordHash.remove(recordHash.size() - 1); if (recordHash.size() == 0) { posEntity = new HashMap<>(initMap); checkpoint(); } else { posEntity = new HashMap<>(recordHash.get(recordHash.size() - 1)); } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO // System.out.println(POS_ID); for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player p) { if (p.getId() == id) { return position; } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return posEntity.get(Position.of(position.x(), position.y())); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return limit; }",
        "label": "P"
    },
    "621": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } } public void run() { // TODO renderingEngine.message(\"Sokoban game is ready.\"); renderingEngine.render(state); if (state.getUndoQuota().isEmpty() || state.getUndoQuota().get() == -1) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } renderingEngine.message(\">>>\"); do { Action action = inputEngine.fetchAction(); switch (action) { case Move.Up up -> { ActionResult actionResult = processAction(up); if (actionResult instanceof ActionResult.Success) { renderingEngine.render(state); if (!state.isWin()) { if (state.getUndoQuota().get() == -1) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } } } else if (actionResult instanceof ActionResult.Failed f) { renderingEngine.message(f.getReason()); renderingEngine.render(state); if (state.getUndoQuota().get() == -1) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } } } case Move.Down down -> { ActionResult actionResult = processAction(down); if (actionResult instanceof ActionResult.Success) { renderingEngine.render(state); if (!state.isWin()) { if (state.getUndoQuota().get() == -1) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } } } else if (actionResult instanceof ActionResult.Failed f) { renderingEngine.message(f.getReason()); renderingEngine.render(state); if (state.getUndoQuota().get() == -1) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } } } case Move.Left left -> { ActionResult actionResult = processAction(left); if (actionResult instanceof ActionResult.Success) { renderingEngine.render(state); if (!state.isWin()) { if (state.getUndoQuota().get() == -1) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } } } else if (actionResult instanceof ActionResult.Failed f) { renderingEngine.message(f.getReason()); renderingEngine.render(state); if (state.getUndoQuota().get() == -1) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } } } case Move.Right right -> { ActionResult actionResult = processAction(right); if (actionResult instanceof ActionResult.Success) { renderingEngine.render(state); if (!state.isWin()) { if (state.getUndoQuota().get() == -1) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } } } else if (actionResult instanceof ActionResult.Failed f) { renderingEngine.message(f.getReason()); renderingEngine.render(state); if (state.getUndoQuota().get() == -1) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } } } case InvalidInput invalidInput -> { ActionResult actionResult = processAction(invalidInput); // Here to start if (actionResult instanceof ActionResult.Failed f) { renderingEngine.message(f.getReason()); renderingEngine.render(state); if (state.getUndoQuota().isEmpty()) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } } else { renderingEngine.message(invalidInput.getMessage()); } } case Undo undo -> { ActionResult actionResult = processAction(undo); if (actionResult instanceof ActionResult.Success) { renderingEngine.render(state); // System.out.println(state.getUndoQuota().get()); if (state.getUndoQuota().get() == -1) { // -1 in previous) { renderingEngine.message(\"Unlimited\"); } else { renderingEngine.message(String.valueOf(state.getUndoQuota().get())); } // state.checkpoint(); } else if (actionResult instanceof ActionResult.Failed) { renderingEngine.message(\"You have run out of your undo quota.\"); renderingEngine.render(state); } } case Exit exit -> { ActionResult ignored = processAction(exit); renderingEngine.render(state); renderingEngine.message(\"Game exits.\"); } } if (!shouldStop()) { renderingEngine.message(\">>>\"); } } while (!shouldStop()); if (state.isWin()) { renderingEngine.message(\"Game exits.\"); renderingEngine.message(\"You win.\"); } }",
        "label": "P"
    },
    "622": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "623": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "624": {
        "dataset": "COMP 3021",
        "project": "yhubv",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); // System.out.println(WIDTH); this.height = map.getMaxHeight(); // System.out.println(HEIGHT); this.limit = map.getUndoLimit(); this.setDesPos = map.getDestinations(); // System.out.println(SET_DES_POS); this.playerId = map.getPlayerIds(); // hash entity need position as argument // copy the map and push by entity for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { Entity currentEntity = map.getEntity(Position.of(j, i)); // MAP_ID_POS.put(current_entity, Position.of(i,j)); posEntity.put(Position.of(j, i), currentEntity); map.putEntity(Position.of(j, i), currentEntity); } } // System.out.println(POS_ENTITY); for (int i : playerId) { for (Position position : posEntity.keySet()) { if (posEntity.get(position) instanceof Player) { // System.out.println(\"here\"); // POS_ID.put(i, position); // System.out.println(POS_ID); allPlayer.add(position); } } } initMap = new HashMap<>(posEntity); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "625": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { return undoLimit; }",
        "label": "P"
    },
    "626": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "627": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "628": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "629": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "630": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "631": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return entityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "632": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return entityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "633": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "634": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "635": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return entityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "636": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return entityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "637": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return entityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "638": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return entityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "639": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); switch (inputLine.toLowerCase()) { case \"w\": return new Move.Up(0); case \"a\": return new Move.Left(0); case \"s\": return new Move.Down(0); case \"d\": return new Move.Right(0); case \"h\": return new Move.Left(1); case \"j\": return new Move.Down(1); case \"k\": return new Move.Up(1); case \"l\": return new Move.Right(1); case \"u\": return new Undo(-1); case \"exit\": return new Exit(-1); default: return new InvalidInput(-1, \"Invalid input!\"); } }",
        "label": "P"
    },
    "640": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public void move(Position from, Position to) { entityMap.put(to, entityMap.get(from)); entityMap.put(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "641": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public void move(Position from, Position to) { entityMap.put(to, entityMap.get(from)); entityMap.put(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (var entry : entityMap.entrySet()) { if (entry.getValue() instanceof Player && ((Player) entry.getValue()).getId() == id) { return entry.getKey(); } } return null; }",
        "label": "P"
    },
    "642": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public void move(Position from, Position to) { entityMap.put(to, entityMap.get(from)); entityMap.put(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (var entry : entityMap.entrySet()) { if (entry.getValue() instanceof Player && ((Player) entry.getValue()).getId() == id) { return entry.getKey(); } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return entityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "643": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public Optional<Integer> getUndoQuota() { return undosLeft; }",
        "label": "P"
    },
    "644": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { Set<Position> results = new HashSet<>(); for (var entry : entityMap.entrySet()) { if (entry.getValue() instanceof Player) results.add(entry.getKey()); } return results; }",
        "label": "P"
    },
    "645": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public void move(Position from, Position to) { entityMap.put(to, entityMap.get(from)); entityMap.put(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { checkpoints.add(new HashMap<>(entityMap)); } public void undo() { if (entityMap.equals(map.getEntityMap())) { return; } if (checkpoints.empty()) { entityMap = new HashMap(map.getEntityMap()); } else if (entityMap.equals(checkpoints.peek())) { if (undosLeft.isPresent()) { undosLeft = Optional.of(undosLeft.get()-1); } checkpoints.pop(); undo(); } else { if (undosLeft.isPresent()) { undosLeft = Optional.of(undosLeft.get()-1); } entityMap = checkpoints.pop(); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { for (var entry : entityMap.entrySet()) { if (entry.getValue() instanceof Player && ((Player) entry.getValue()).getId() == id) { return entry.getKey(); } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return entityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { return undosLeft; }",
        "label": "P"
    },
    "646": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); this.renderingEngine.message(\"Sokoban game is ready.\"); this.renderingEngine.render(state); if (state.getUndoQuota().isPresent()) { this.renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get()); } else { this.renderingEngine.message(\"Unlimited\"); } } public void run() { while (!shouldStop()) { this.renderingEngine.message(\">>>\"); var action = inputEngine.fetchAction(); var result = processAction(action); switch (result) { case ActionResult.Failed f: renderingEngine.message(f.getReason()); renderingEngine.render(state); break; case ActionResult.Success ignored: renderingEngine.render(state); } if (shouldStop()) { this.renderingEngine.message(\"Game exits.\"); if (state.isWin()) { this.renderingEngine.message(\"You win.\"); } } else if (state.getUndoQuota().isPresent()) { this.renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get()); } else { this.renderingEngine.message(\"Unlimited\"); } } }",
        "label": "P"
    },
    "647": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); this.renderingEngine.message(\"Sokoban game is ready.\"); this.renderingEngine.render(state); if (state.getUndoQuota().isPresent()) { this.renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get()); } else { this.renderingEngine.message(\"Unlimited\"); } }",
        "label": "P"
    },
    "648": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { outputSteam.println(content); }",
        "label": "P"
    },
    "649": {
        "dataset": "COMP 3021",
        "project": "yhlauak",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; undosLeft = map.getUndoLimit(); entityMap = new HashMap(map.getEntityMap()); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { final var builder = new StringBuilder(); for (int y = 0; y < state.getMapMaxHeight(); y++) { for (int x = 0; x < state.getMapMaxWidth(); x++) { final var entity = state.getEntity(Position.of(x, y)); var charToPrint = switch (entity) { case Wall ignored -> '#'; case Box b -> (char) (b.getPlayerId()+'a'); case Player p -> (char) (p.getId()+'A'); case Empty ignored -> state.getDestinations().contains(Position.of(x,y)) ? '@' : '.'; case null -> ' '; }; builder.append(charToPrint); } builder.append('\\n'); } outputSteam.print(builder); }",
        "label": "P"
    },
    "650": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undolimit); }",
        "label": "P"
    },
    "651": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "652": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "653": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "654": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "655": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "656": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] lines = state.split(System.lineSeparator()); // Arrays.stream(lines).forEach(System.out::println); if (lines[position.y() + 1].length() < getMapMaxWidth() && position.x() >= lines[position.y() + 1].length()) { return null; } char entity = lines[position.y() + 1].charAt(position.x()); if (entity == '@' || entity == '.') { return new Empty(); } else if (entity == '#') { return new Wall(); } else if (Character.isLowerCase(entity)) { int id = (entity - 'a'); // System.out.println(id); return new Box(id); } else if (Character.isUpperCase(entity)) { int id = (entity - 'A'); // System.out.println(id); return new Player(id); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "657": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] lines = state.split(System.lineSeparator()); // Arrays.stream(lines).forEach(System.out::println); if (lines[position.y() + 1].length() < getMapMaxWidth() && position.x() >= lines[position.y() + 1].length()) { return null; } char entity = lines[position.y() + 1].charAt(position.x()); if (entity == '@' || entity == '.') { return new Empty(); } else if (entity == '#') { return new Wall(); } else if (Character.isLowerCase(entity)) { int id = (entity - 'a'); // System.out.println(id); return new Box(id); } else if (Character.isUpperCase(entity)) { int id = (entity - 'A'); // System.out.println(id); return new Player(id); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "658": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "659": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "660": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.map.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] lines = state.split(System.lineSeparator()); // Arrays.stream(lines).forEach(System.out::println); if (lines[position.y() + 1].length() < getMapMaxWidth() && position.x() >= lines[position.y() + 1].length()) { return null; } char entity = lines[position.y() + 1].charAt(position.x()); if (entity == '@' || entity == '.') { return new Empty(); } else if (entity == '#') { return new Wall(); } else if (Character.isLowerCase(entity)) { int id = (entity - 'a'); // System.out.println(id); return new Box(id); } else if (Character.isUpperCase(entity)) { int id = (entity - 'A'); // System.out.println(id); return new Player(id); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "661": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] lines = state.split(System.lineSeparator()); // Arrays.stream(lines).forEach(System.out::println); if (lines[position.y() + 1].length() < getMapMaxWidth() && position.x() >= lines[position.y() + 1].length()) { return null; } char entity = lines[position.y() + 1].charAt(position.x()); if (entity == '@' || entity == '.') { return new Empty(); } else if (entity == '#') { return new Wall(); } else if (Character.isLowerCase(entity)) { int id = (entity - 'a'); // System.out.println(id); return new Box(id); } else if (Character.isUpperCase(entity)) { int id = (entity - 'A'); // System.out.println(id); return new Player(id); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "662": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] lines = state.split(System.lineSeparator()); // Arrays.stream(lines).forEach(System.out::println); if (lines[position.y() + 1].length() < getMapMaxWidth() && position.x() >= lines[position.y() + 1].length()) { return null; } char entity = lines[position.y() + 1].charAt(position.x()); if (entity == '@' || entity == '.') { return new Empty(); } else if (entity == '#') { return new Wall(); } else if (Character.isLowerCase(entity)) { int id = (entity - 'a'); // System.out.println(id); return new Box(id); } else if (Character.isUpperCase(entity)) { int id = (entity - 'A'); // System.out.println(id); return new Player(id); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "663": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] lines = state.split(System.lineSeparator()); // Arrays.stream(lines).forEach(System.out::println); if (lines[position.y() + 1].length() < getMapMaxWidth() && position.x() >= lines[position.y() + 1].length()) { return null; } char entity = lines[position.y() + 1].charAt(position.x()); if (entity == '@' || entity == '.') { return new Empty(); } else if (entity == '#') { return new Wall(); } else if (Character.isLowerCase(entity)) { int id = (entity - 'a'); // System.out.println(id); return new Box(id); } else if (Character.isUpperCase(entity)) { int id = (entity - 'A'); // System.out.println(id); return new Player(id); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "664": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO if (inputLine.equals(StringResources.EXIT_COMMAND_TEXT)) { return new Exit(0); } else if (inputLine.equals(\"u\")) { return new Undo(0); } else if (inputLine.equals(\"w\")) { return new Move.Up(0); } else if (inputLine.equals(\"a\")) { return new Move.Left(0); } else if (inputLine.equals(\"s\")) { return new Move.Down(0); } else if (inputLine.equals(\"d\")) { return new Move.Right(0); } else if (inputLine.equals(\"k\")) { return new Move.Up(1); } else if (inputLine.equals(\"h\")) { return new Move.Left(1); } else if (inputLine.equals(\"j\")) { return new Move.Down(1); } else if (inputLine.equals(\"l\")) { return new Move.Right(1); } else { return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "665": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public void move(Position from, Position to) { // TODO String[] lines = state.split(System.lineSeparator()); int indexTo = lines[0].length() + 1; int indexFrom = lines[0].length() + 1; for (int i = 0; i < to.y(); i++) { indexTo = indexTo + lines[i + 1].length() + 1; } for (int i = 0; i < from.y(); i++) { indexFrom = indexFrom + lines[i + 1].length() + 1; } indexTo = indexTo + to.x(); indexFrom = indexFrom + from.x(); // System.out.println(state.charAt(indexFrom)); // System.out.println(state.charAt(indexTo)); StringBuilder sb = new StringBuilder(state); sb.setCharAt(indexTo, state.charAt(indexFrom)); sb.setCharAt(indexFrom, '.'); this.state = sb.toString(); // System.out.println(state); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "666": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public void move(Position from, Position to) { // TODO String[] lines = state.split(System.lineSeparator()); int indexTo = lines[0].length() + 1; int indexFrom = lines[0].length() + 1; for (int i = 0; i < to.y(); i++) { indexTo = indexTo + lines[i + 1].length() + 1; } for (int i = 0; i < from.y(); i++) { indexFrom = indexFrom + lines[i + 1].length() + 1; } indexTo = indexTo + to.x(); indexFrom = indexFrom + from.x(); // System.out.println(state.charAt(indexFrom)); // System.out.println(state.charAt(indexTo)); StringBuilder sb = new StringBuilder(state); sb.setCharAt(indexTo, state.charAt(indexFrom)); sb.setCharAt(indexFrom, '.'); this.state = sb.toString(); // System.out.println(state); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO char player = (char) (id + 'A'); String[] lines = state.split(System.lineSeparator()); for (int i = 0; i < state.length(); i++) { if (state.charAt(i) == player) { int j = i; int k = 0; while (j - lines[k].length() - 1 >= 0) { j = j - lines[k].length() - 1; k = k + 1; } int y = k - 1; int x = j; return new Position(x, y); } } return new Position(0, 0); }",
        "label": "P"
    },
    "667": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public void move(Position from, Position to) { // TODO String[] lines = state.split(System.lineSeparator()); int indexTo = lines[0].length() + 1; int indexFrom = lines[0].length() + 1; for (int i = 0; i < to.y(); i++) { indexTo = indexTo + lines[i + 1].length() + 1; } for (int i = 0; i < from.y(); i++) { indexFrom = indexFrom + lines[i + 1].length() + 1; } indexTo = indexTo + to.x(); indexFrom = indexFrom + from.x(); // System.out.println(state.charAt(indexFrom)); // System.out.println(state.charAt(indexTo)); StringBuilder sb = new StringBuilder(state); sb.setCharAt(indexTo, state.charAt(indexFrom)); sb.setCharAt(indexFrom, '.'); this.state = sb.toString(); // System.out.println(state); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO char player = (char) (id + 'A'); String[] lines = state.split(System.lineSeparator()); for (int i = 0; i < state.length(); i++) { if (state.charAt(i) == player) { int j = i; int k = 0; while (j - lines[k].length() - 1 >= 0) { j = j - lines[k].length() - 1; k = k + 1; } int y = k - 1; int x = j; return new Position(x, y); } } return new Position(0, 0); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] lines = state.split(System.lineSeparator()); // Arrays.stream(lines).forEach(System.out::println); if (lines[position.y() + 1].length() < getMapMaxWidth() && position.x() >= lines[position.y() + 1].length()) { return null; } char entity = lines[position.y() + 1].charAt(position.x()); if (entity == '@' || entity == '.') { return new Empty(); } else if (entity == '#') { return new Wall(); } else if (Character.isLowerCase(entity)) { int id = (entity - 'a'); // System.out.println(id); return new Box(id); } else if (Character.isUpperCase(entity)) { int id = (entity - 'A'); // System.out.println(id); return new Player(id); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "668": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public Optional<Integer> getUndoQuota() { // TODO if (this.map.undolimit == -1) { return Optional.empty(); } else { return Optional.of(undoQuota); } }",
        "label": "P"
    },
    "669": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> playerPositions = new HashSet<Position>(); Set<Integer> ids = this.map.getPlayerIds(); for (Integer i : ids) { playerPositions.add(getPlayerPositionById(i)); } return playerPositions; }",
        "label": "P"
    },
    "670": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public void move(Position from, Position to) { // TODO String[] lines = state.split(System.lineSeparator()); int indexTo = lines[0].length() + 1; int indexFrom = lines[0].length() + 1; for (int i = 0; i < to.y(); i++) { indexTo = indexTo + lines[i + 1].length() + 1; } for (int i = 0; i < from.y(); i++) { indexFrom = indexFrom + lines[i + 1].length() + 1; } indexTo = indexTo + to.x(); indexFrom = indexFrom + from.x(); // System.out.println(state.charAt(indexFrom)); // System.out.println(state.charAt(indexTo)); StringBuilder sb = new StringBuilder(state); sb.setCharAt(indexTo, state.charAt(indexFrom)); sb.setCharAt(indexFrom, '.'); this.state = sb.toString(); // System.out.println(state); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO if (cp.isEmpty()) { cp.add(new GameState(this.map)); cp.get(0).state = GameMap.map; cp.get(0).undoQuota = this.map.undolimit; cp.add(new GameState(this.map)); cp.get(1).state = this.state; cp.get(1).undoQuota = this.undoQuota; } else { cp.add(new GameState(this.map)); cp.get(cp.size() - 1).state = this.state; cp.get(cp.size() - 1).undoQuota = this.undoQuota; } } public void undo() { // TODO if (this.cp.size() > 1) { this.state = this.cp.get(cp.size() - 2).state; this.cp.remove(cp.size() - 1); if (undoQuota == -1) { this.undoQuota = undoQuota; } else { this.undoQuota = undoQuota - 1; } } else if (this.cp.size() == 1) { this.state = this.cp.get(0).state; } // System.out.println(undoQuota); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO char player = (char) (id + 'A'); String[] lines = state.split(System.lineSeparator()); for (int i = 0; i < state.length(); i++) { if (state.charAt(i) == player) { int j = i; int k = 0; while (j - lines[k].length() - 1 >= 0) { j = j - lines[k].length() - 1; k = k + 1; } int y = k - 1; int x = j; return new Position(x, y); } } return new Position(0, 0); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] lines = state.split(System.lineSeparator()); // Arrays.stream(lines).forEach(System.out::println); if (lines[position.y() + 1].length() < getMapMaxWidth() && position.x() >= lines[position.y() + 1].length()) { return null; } char entity = lines[position.y() + 1].charAt(position.x()); if (entity == '@' || entity == '.') { return new Empty(); } else if (entity == '#') { return new Wall(); } else if (Character.isLowerCase(entity)) { int id = (entity - 'a'); // System.out.println(id); return new Box(id); } else if (Character.isUpperCase(entity)) { int id = (entity - 'A'); // System.out.println(id); return new Player(id); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (this.map.undolimit == -1) { return Optional.empty(); } else { return Optional.of(undoQuota); } }",
        "label": "P"
    },
    "671": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } } public void run() { // TODO renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(state); if (this.state.getUndoQuota().isEmpty()) { renderingEngine.message(StringResources.UNDO_QUOTA_UNLIMITED); } if (this.state.getUndoQuota().isPresent()) { String message = String.format(StringResources.UNDO_QUOTA_TEMPLATE, this.state.getUndoQuota().get()); renderingEngine.message(message); } renderingEngine.message(\">>>\"); this.state.initialCheckpoint(); while (!this.shouldStop()) { Action action = inputEngine.fetchAction(); ActionResult result = this.processAction(action); if (action instanceof Exit) { renderingEngine.render(state); renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); return; } if (result instanceof ActionResult.Failed) { String message = ((ActionResult.Failed) result).getReason(); renderingEngine.message(message); } renderingEngine.render(state); if (!this.shouldStop()) { if (this.state.getUndoQuota().isEmpty()) { renderingEngine.message(StringResources.UNDO_QUOTA_UNLIMITED); } if (this.state.getUndoQuota().isPresent()) { String message = String.format(StringResources.UNDO_QUOTA_TEMPLATE, this.state.getUndoQuota().get()); renderingEngine.message(message); } } renderingEngine.message(\">>>\"); } renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); renderingEngine.message(StringResources.WIN_MESSAGE); return; }",
        "label": "P"
    },
    "672": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "673": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "674": {
        "dataset": "COMP 3021",
        "project": "mdychengbeng",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.undolimit; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "675": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; } public int getMaxHeight() { // TODO return height; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undoLimit); }",
        "label": "P"
    },
    "676": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "677": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "678": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "679": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "680": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "681": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "682": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "683": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; }",
        "label": "P"
    },
    "684": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; }",
        "label": "P"
    },
    "685": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO // the location of destination should be fixed, so use the one from the gamemap directly return map.getDestinations(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "686": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "687": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "688": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "689": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO // dummy id int id = -1; int playerOneId = 0; int playerTwoId = 1; String lowerCaseInput = inputLine.toLowerCase(); if (lowerCaseInput.equals(EXIT_COMMAND_TEXT)) { return new Exit(id); } else if (lowerCaseInput.equals(\"u\")) { return new Undo(id); } else if (lowerCaseInput.equals(\"a\")) { // assume wasd movement only made by player 1 return new Move.Left(playerOneId); } else if (lowerCaseInput.equals(\"w\")) { return new Move.Up(playerOneId); } else if (lowerCaseInput.equals(\"s\")) { return new Move.Down(playerOneId); } else if (lowerCaseInput.equals(\"d\")) { return new Move.Right(playerOneId); } else if (lowerCaseInput.equals(\"h\")) { // assume hjkl movement only made by player 2 return new Move.Left(playerTwoId); } else if (lowerCaseInput.equals(\"j\")) { return new Move.Down(playerTwoId); } else if (lowerCaseInput.equals(\"k\")) { return new Move.Up(playerTwoId); } else if (lowerCaseInput.equals(\"l\")) { return new Move.Right(playerTwoId); } else { return new InvalidInput(id, INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "690": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public void move(Position from, Position to) { // TODO // no need to check anything, just move it (checking should be done in processAction inside the AbstractSokobanGame class) Entity movingEntity = getEntity(from); mapInfo.put(from, new Empty()); mapInfo.put(to, movingEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "691": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public void move(Position from, Position to) { // TODO // no need to check anything, just move it (checking should be done in processAction inside the AbstractSokobanGame class) Entity movingEntity = getEntity(from); mapInfo.put(from, new Empty()); mapInfo.put(to, movingEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getValue() instanceof Player player) { if (player.getId() == id) { return entry.getKey(); } } } return null; }",
        "label": "P"
    },
    "692": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public void move(Position from, Position to) { // TODO // no need to check anything, just move it (checking should be done in processAction inside the AbstractSokobanGame class) Entity movingEntity = getEntity(from); mapInfo.put(from, new Empty()); mapInfo.put(to, movingEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getValue() instanceof Player player) { if (player.getId() == id) { return entry.getKey(); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "693": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public Optional<Integer> getUndoQuota() { // TODO // if undo limit is not -1 (which is unlimted) if (!map.getUndoLimit().get().equals(-1)) { return undoLeft; } else { return Optional.empty(); } }",
        "label": "P"
    },
    "694": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> playerPositions = new HashSet<>(); for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getValue() instanceof Player) { playerPositions.add(entry.getKey()); } } return playerPositions; }",
        "label": "P"
    },
    "695": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public void move(Position from, Position to) { // TODO // no need to check anything, just move it (checking should be done in processAction inside the AbstractSokobanGame class) Entity movingEntity = getEntity(from); mapInfo.put(from, new Empty()); mapInfo.put(to, movingEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO // save the last state to the stack snapshot.add(new HashMap<>(mapInfo)); } public void undo() { // TODO // 1 snapshot is of the original map is created when the game start // if the snapshot size is larger than 1, that means there is at least 1 checkpoint made by movement if (snapshot.size() > 1) { // remove the last check point snapshot.pop(); // undo quota will be used when the checkpoint is made by movement // if undo quota is not unlimited if (!undoLeft.isEmpty()) { // assume quota left, reduce 1 quota undoLeft = Optional.of(undoLeft.get() - 1); } } // do the revert mapInfo = new HashMap<>(snapshot.peek()); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getValue() instanceof Player player) { if (player.getId() == id) { return entry.getKey(); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entry : mapInfo.entrySet()) { if (entry.getKey().equals(position)) { return entry.getValue(); } } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO // if undo limit is not -1 (which is unlimted) if (!map.getUndoLimit().get().equals(-1)) { return undoLeft; } else { return Optional.empty(); } }",
        "label": "P"
    },
    "696": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players // should not be larger than 2 ( should not be less than 1 too, but the test case seem to be allow for such case) if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(INVALID_INPUT_MESSAGE); } } public void run() { // TODO renderingEngine.message(GAME_READY_MESSAGE); renderingEngine.render(state); while (!shouldStop()) { showQuotaText(); Action action = inputEngine.fetchAction(); ActionResult result = processAction(action); if(result instanceof ActionResult.Failed){ renderingEngine.message(((ActionResult.Failed) result).getReason()); } renderingEngine.render(state); } renderingEngine.message(GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(WIN_MESSAGE); } }",
        "label": "P"
    },
    "697": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players // should not be larger than 2 ( should not be less than 1 too, but the test case seem to be allow for such case) if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "698": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "699": {
        "dataset": "COMP 3021",
        "project": "achengad",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; // make a copy of mapInfo so changing in here wont affect the mapInfo in gamemap class mapInfo = new HashMap<>(map.getMapInfo()); undoLeft = map.getUndoLimit(); // make the init state to be the last state for undo action snapshot.add(new HashMap<>(mapInfo)); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "700": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; } public int getMaxHeight() { // TODO return height; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(limit); }",
        "label": "P"
    },
    "701": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "702": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "703": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "704": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "705": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "706": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return maps.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "707": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return maps.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "708": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; }",
        "label": "P"
    },
    "709": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; }",
        "label": "P"
    },
    "710": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return destination; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return maps.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "711": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return maps.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "712": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return maps.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "713": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return maps.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "714": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO if (inputLine.equals(\"w\")|| inputLine.equals(\"W\")) { return new Move.Up(0); } else if (inputLine.equals(\"s\")|| inputLine.equals(\"S\")) { return new Move.Down(0); } else if (inputLine.equals(\"a\")|| inputLine.equals(\"A\")) { return new Move.Left(0); } else if (inputLine.equals(\"d\")|| inputLine.equals(\"D\")) { return new Move.Right(0); } else if (inputLine.equals(\"h\")|| inputLine.equals(\"H\")) { return new Move.Left(1); } else if (inputLine.equals(\"j\")|| inputLine.equals(\"J\")) { return new Move.Down(1); } else if (inputLine.equals(\"k\")|| inputLine.equals(\"K\")) { return new Move.Up(1); } else if (inputLine.equals(\"l\")|| inputLine.equals(\"L\")) { return new Move.Right(1); } else if (inputLine.equals(\"U\")|| inputLine.equals(\"u\")) { return new Undo(1); } else if (inputLine.equals(\"EXIT\")|| inputLine.equals(\"ExIT\")||inputLine.equals(\"EXiT\")|| inputLine.equals(\"EXIt\") ||inputLine.equals(\"eXIT\")|| inputLine.equals(\"exit\")||inputLine.equals(\"exiT\")|| inputLine.equals(\"ExiT\")) { return new Exit(1); }else { return new InvalidInput(0,\"invalid input\"); } }",
        "label": "P"
    },
    "715": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public void move(Position from, Position to) { // TODO maps.putEntity(new Position(to.x(), to.y()), maps.getEntity(new Position(from.x(), from.y()))); maps.putEntity(new Position(from.x(), from.y()), new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "716": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public void move(Position from, Position to) { // TODO maps.putEntity(new Position(to.x(), to.y()), maps.getEntity(new Position(from.x(), from.y()))); maps.putEntity(new Position(from.x(), from.y()), new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO String[] localSTS = maps.getGameMap().clone(); char player = (char)(id+'A'); for(int i=0;i<localSTS.length;i++){ for(int j=0;j<localSTS[i].length();j++){ if(localSTS[i].charAt(j)==player){ return new Position(j,i); } } } return null; }",
        "label": "P"
    },
    "717": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public void move(Position from, Position to) { // TODO maps.putEntity(new Position(to.x(), to.y()), maps.getEntity(new Position(from.x(), from.y()))); maps.putEntity(new Position(from.x(), from.y()), new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO String[] localSTS = maps.getGameMap().clone(); char player = (char)(id+'A'); for(int i=0;i<localSTS.length;i++){ for(int j=0;j<localSTS[i].length();j++){ if(localSTS[i].charAt(j)==player){ return new Position(j,i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return maps.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "718": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public Optional<Integer> getUndoQuota() { // TODO int unlimited = -1; if (limit.get()>0) { return Optional.of(limit.get()); } if (limit.equals(unlimited)){ return Optional.empty(); } return null; }",
        "label": "P"
    },
    "719": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> playerpositions = new HashSet<Position>(); for(int i = 0; i< sts.length; i++){ for(int j = 0; j< sts[i].length(); j++){ char ch= sts[i].charAt(j); if (ch >= 'A' && ch <= 'Z') { if (!playerpositions.contains(ch)){ playerpositions.add(new Position(j,i)); } } } } return playerpositions; }",
        "label": "P"
    },
    "720": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public void move(Position from, Position to) { // TODO maps.putEntity(new Position(to.x(), to.y()), maps.getEntity(new Position(from.x(), from.y()))); maps.putEntity(new Position(from.x(), from.y()), new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO String[] localSTS = sts.clone(); countCP=countCP+1; map1.put(countCP,localSTS); } public void undo() { // TODO int undoQuota = getUndoQuota().get(); if (countCP>0) { //the game has an undo limit if (undoQuota > 0) { undoQuota--; sts = map1.get(map1.size()-1); map1.remove(map1.size()); countCP--; } } limit = Optional.of(undoQuota); maps.setGameMap(sts); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO String[] localSTS = maps.getGameMap().clone(); char player = (char)(id+'A'); for(int i=0;i<localSTS.length;i++){ for(int j=0;j<localSTS[i].length();j++){ if(localSTS[i].charAt(j)==player){ return new Position(j,i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return maps.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO int unlimited = -1; if (limit.get()>0) { return Optional.of(limit.get()); } if (limit.equals(unlimited)){ return Optional.empty(); } return null; }",
        "label": "P"
    },
    "721": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO this.renderingEngine.render(state); renderingEngine.message(\"Undo Quota: \"+ (state.getUndoQuota().isPresent() ? state.getUndoQuota().get() : 0)); // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(\"more than two players in the map\"); } public void run() { // TODO while(!shouldStop()) { renderingEngine.message(\"Undo Quota:\"+ (state.getUndoQuota().isPresent() ? state.getUndoQuota().get() : 0)); var ac = inputEngine.fetchAction(); ActionResult result = processAction(ac); if (ActionResult.Failed.class.isAssignableFrom(result.getClass())) { renderingEngine.message(((ActionResult.Failed) result).getReason()); } renderingEngine.render(state); } renderingEngine.message(\"Game exits.\"); }",
        "label": "P"
    },
    "722": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO this.renderingEngine.render(state); renderingEngine.message(\"Undo Quota: \"+ (state.getUndoQuota().isPresent() ? state.getUndoQuota().get() : 0)); // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(\"more than two players in the map\"); }",
        "label": "P"
    },
    "723": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "724": {
        "dataset": "COMP 3021",
        "project": "tplauaa",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.width = map.getMaxWidth(); this.height = map.getMaxHeight(); this.destination = map.getDestinations(); this.limit = map.getUndoLimit(); this.sts = map.getGameMap().clone(); maps = map; map1.put(countCP, sts.clone()); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "725": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO // throw new NotImplementedException(); Optional<Integer> result = Optional.ofNullable(undoLimit); return result; }",
        "label": "P"
    },
    "726": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "727": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "728": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public Down(int initiator) { super(initiator); }",
        "label": "F"
    },
    "729": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public Down(int initiator) { super(initiator); }",
        "label": "F"
    },
    "730": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public Down(int initiator) { super(initiator); }",
        "label": "F"
    },
    "731": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "732": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "733": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "734": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "735": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "736": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "737": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "738": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "739": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO throw new NotImplementedException(); }",
        "label": "F"
    },
    "740": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public void move(Position from, Position to) { // TODO throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "F"
    },
    "741": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public void move(Position from, Position to) { // TODO throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO int lastVersion = mapHistory.size() -1; int width = mapHistory.get(lastVersion).getMaxWidth(); int height = mapHistory.get(lastVersion).getMaxHeight(); boolean found = false; int x = 0, y = 0; for(int i = 0; i < width; i++) { for(int j = 0; j < height; j++) { Position p = new Position(j,i); if(mapHistory.get(lastVersion).getEntity(p) instanceof Player) { if(((Player) mapHistory.get(lastVersion).getEntity(p)).getId() == id) { x = j; y = i; found = true; break; } } } if(found == true) {break;} } Position result = new Position(x,y); return result; }",
        "label": "F"
    },
    "742": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public void move(Position from, Position to) { // TODO throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO int lastVersion = mapHistory.size() -1; int width = mapHistory.get(lastVersion).getMaxWidth(); int height = mapHistory.get(lastVersion).getMaxHeight(); boolean found = false; int x = 0, y = 0; for(int i = 0; i < width; i++) { for(int j = 0; j < height; j++) { Position p = new Position(j,i); if(mapHistory.get(lastVersion).getEntity(p) instanceof Player) { if(((Player) mapHistory.get(lastVersion).getEntity(p)).getId() == id) { x = j; y = i; found = true; break; } } } if(found == true) {break;} } Position result = new Position(x,y); return result; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "F"
    },
    "743": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public Optional<Integer> getUndoQuota() { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getUndoLimit(); }",
        "label": "P"
    },
    "744": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO int lastVersion = mapHistory.size() -1; int width = mapHistory.get(lastVersion).getMaxWidth(); int height = mapHistory.get(lastVersion).getMaxHeight(); Set<Position> setOfPlayer = new HashSet<>(); for(int i = 0; i < width; i++) { for(int j = 0; j < height; j++) { Position p = new Position(j,i); if(mapHistory.get(lastVersion).getEntity(p) instanceof Player) { setOfPlayer.add(p); } } } return setOfPlayer; }",
        "label": "F"
    },
    "745": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public void move(Position from, Position to) { // TODO throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO int lastVersion = mapHistory.size() -1; GameMap newRecord = new GameMap(mapHistory.get(lastVersion).maxWidth,mapHistory.get(lastVersion).getMaxHeight(), mapHistory.get(lastVersion).destinations,mapHistory.get(lastVersion).undoLimit); mapHistory.add(newRecord); } public void undo() { // TODO int lastVersion = mapHistory.size() -1; if(lastVersion == 0) { } else { mapHistory.remove(lastVersion); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO int lastVersion = mapHistory.size() -1; int width = mapHistory.get(lastVersion).getMaxWidth(); int height = mapHistory.get(lastVersion).getMaxHeight(); boolean found = false; int x = 0, y = 0; for(int i = 0; i < width; i++) { for(int j = 0; j < height; j++) { Position p = new Position(j,i); if(mapHistory.get(lastVersion).getEntity(p) instanceof Player) { if(((Player) mapHistory.get(lastVersion).getEntity(p)).getId() == id) { x = j; y = i; found = true; break; } } } if(found == true) {break;} } Position result = new Position(x,y); return result; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO int lastVersion = mapHistory.size() -1; return mapHistory.get(lastVersion).getUndoLimit(); }",
        "label": "F"
    },
    "746": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players throw new NotImplementedException(); } public void run() { // TODO while (!shouldStop()) { renderingEngine.render(this.state); processAction(inputEngine.fetchAction()); } }",
        "label": "F"
    },
    "747": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players throw new NotImplementedException(); }",
        "label": "F"
    },
    "748": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. System.out.print(content); }",
        "label": "F"
    },
    "749": {
        "dataset": "COMP 3021",
        "project": "cflukaa",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO mapHistory = new ArrayList<GameMap>(); mapHistory.add(map); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "F"
    },
    "750": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return _width; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO return _height; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(_undoLimit); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "751": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "752": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "753": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "754": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "755": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "756": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int x = position.x(); int y = position.y()+1; if(x>= Width || y>= Height)return null; // System.out.print(_mapString[y].length()+'\\n'); char _char = MapString[y].charAt(x); // System.out.print(_char+\"\\n\"); if (_char>= 'A' && _char<='Z' ){ return new Player(_char -'A'); }else if(_char>='a' && _char <='z'){ return new Box(Character.toLowerCase(_char)-'A'); } else if(_char =='.' || _char =='@'){ return new Empty(); }else if(_char == '#'){ return new Wall(); } else return null; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "757": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int x = position.x(); int y = position.y()+1; if(x>= Width || y>= Height)return null; // System.out.print(_mapString[y].length()+'\\n'); char _char = MapString[y].charAt(x); // System.out.print(_char+\"\\n\"); if (_char>= 'A' && _char<='Z' ){ return new Player(_char -'A'); }else if(_char>='a' && _char <='z'){ return new Box(Character.toLowerCase(_char)-'A'); } else if(_char =='.' || _char =='@'){ return new Empty(); }else if(_char == '#'){ return new Wall(); } else return null; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "758": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return _height; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "759": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return _width; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "760": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return Dest; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO int x = position.x(); int y = position.y()+1; if(x>= Width || y>= Height)return null; // System.out.print(_mapString[y].length()+'\\n'); char _char = MapString[y].charAt(x); // System.out.print(_char+\"\\n\"); if (_char>= 'A' && _char<='Z' ){ return new Player(_char -'A'); }else if(_char>='a' && _char <='z'){ return new Box(Character.toLowerCase(_char)-'A'); } else if(_char =='.' || _char =='@'){ return new Empty(); }else if(_char == '#'){ return new Wall(); } else return null; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "761": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int x = position.x(); int y = position.y()+1; if(x>= Width || y>= Height)return null; // System.out.print(_mapString[y].length()+'\\n'); char _char = MapString[y].charAt(x); // System.out.print(_char+\"\\n\"); if (_char>= 'A' && _char<='Z' ){ return new Player(_char -'A'); }else if(_char>='a' && _char <='z'){ return new Box(Character.toLowerCase(_char)-'A'); } else if(_char =='.' || _char =='@'){ return new Empty(); }else if(_char == '#'){ return new Wall(); } else return null; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "762": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int x = position.x(); int y = position.y()+1; if(x>= Width || y>= Height)return null; // System.out.print(_mapString[y].length()+'\\n'); char _char = MapString[y].charAt(x); // System.out.print(_char+\"\\n\"); if (_char>= 'A' && _char<='Z' ){ return new Player(_char -'A'); }else if(_char>='a' && _char <='z'){ return new Box(Character.toLowerCase(_char)-'A'); } else if(_char =='.' || _char =='@'){ return new Empty(); }else if(_char == '#'){ return new Wall(); } else return null; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "763": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO int x = position.x(); int y = position.y()+1; if(x>= Width || y>= Height)return null; // System.out.print(_mapString[y].length()+'\\n'); char _char = MapString[y].charAt(x); // System.out.print(_char+\"\\n\"); if (_char>= 'A' && _char<='Z' ){ return new Player(_char -'A'); }else if(_char>='a' && _char <='z'){ return new Box(Character.toLowerCase(_char)-'A'); } else if(_char =='.' || _char =='@'){ return new Empty(); }else if(_char == '#'){ return new Wall(); } else return null; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "764": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // Key A,S,W,D and H,J,K,L are used to move Player with ID 0 and 1 to Left,Down,Up,Right direction by 1 step, respectively // TODO switch (inputLine.toUpperCase()){ case \"A\": return new Move.Left(0); case \"S\": return new Move.Down(0); case \"W\": return new Move.Up(0); case \"D\": return new Move.Right(0); case \"H\": return new Move.Left(1); case \"J\": return new Move.Down(1); case \"K\": return new Move.Up(1); case \"L\": return new Move.Right(1); case \"U\": return new Undo(0); case \"EXIT\": return new Exit(0); default: return new InvalidInput(fetchAction().getInitiator(), \"\"); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "765": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO int x_from = from.x(); int y_from = from.y()+1; int x_to = to.x(); int y_to = to.y()+1; char charFrom = MapString[y_from].charAt(x_from); char charTo = MapString[y_to].charAt(x_to); // _historyMovements.add(from); // _historyMovements.add(to); if(charFrom>='a' && charFrom<='z'){ LastStepMap = MapString.clone(); } if(charTo =='@') charTo = '.'; MapString[y_from] = MapString[y_from].substring(0,x_from)+charTo+ MapString[y_from].substring(x_from+1); MapString[y_to] = MapString[y_to].substring(0,x_to)+charFrom+ MapString[y_to].substring(x_to+1); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "766": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO int x_from = from.x(); int y_from = from.y()+1; int x_to = to.x(); int y_to = to.y()+1; char charFrom = MapString[y_from].charAt(x_from); char charTo = MapString[y_to].charAt(x_to); // _historyMovements.add(from); // _historyMovements.add(to); if(charFrom>='a' && charFrom<='z'){ LastStepMap = MapString.clone(); } if(charTo =='@') charTo = '.'; MapString[y_from] = MapString[y_from].substring(0,x_from)+charTo+ MapString[y_from].substring(x_from+1); MapString[y_to] = MapString[y_to].substring(0,x_to)+charFrom+ MapString[y_to].substring(x_to+1); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 1; i< MapString.length; i++){ for(int j = 0; j< MapString[i].length(); j++){ if(MapString[i].charAt(j)-'A' == id){ return new Position(j,i-1); } } } throw new IllegalArgumentException(\"There is no player with the given Id\"); }",
        "label": "P"
    },
    "767": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO int x_from = from.x(); int y_from = from.y()+1; int x_to = to.x(); int y_to = to.y()+1; char charFrom = MapString[y_from].charAt(x_from); char charTo = MapString[y_to].charAt(x_to); // _historyMovements.add(from); // _historyMovements.add(to); if(charFrom>='a' && charFrom<='z'){ LastStepMap = MapString.clone(); } if(charTo =='@') charTo = '.'; MapString[y_from] = MapString[y_from].substring(0,x_from)+charTo+ MapString[y_from].substring(x_from+1); MapString[y_to] = MapString[y_to].substring(0,x_to)+charFrom+ MapString[y_to].substring(x_to+1); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 1; i< MapString.length; i++){ for(int j = 0; j< MapString[i].length(); j++){ if(MapString[i].charAt(j)-'A' == id){ return new Position(j,i-1); } } } throw new IllegalArgumentException(\"There is no player with the given Id\"); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO int x = position.x(); int y = position.y()+1; if(x>= Width || y>= Height)return null; // System.out.print(_mapString[y].length()+'\\n'); char _char = MapString[y].charAt(x); // System.out.print(_char+\"\\n\"); if (_char>= 'A' && _char<='Z' ){ return new Player(_char -'A'); }else if(_char>='a' && _char <='z'){ return new Box(Character.toLowerCase(_char)-'A'); } else if(_char =='.' || _char =='@'){ return new Empty(); }else if(_char == '#'){ return new Wall(); } else return null; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "768": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO int remain = UndoLimit - Undo; return Optional.of(remain); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "769": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO PlayerPosition = new HashSet<>(); for(int i = 1; i< MapString.length; i++){ for(int j = 0; j< MapString[i].length(); j++){ if(MapString[i].charAt(j) >='A'&& MapString[i].charAt(j) <='Z'){ PlayerPosition.add(new Position(j,i-1)); } } } return PlayerPosition; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "770": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO int x_from = from.x(); int y_from = from.y()+1; int x_to = to.x(); int y_to = to.y()+1; char charFrom = MapString[y_from].charAt(x_from); char charTo = MapString[y_to].charAt(x_to); // _historyMovements.add(from); // _historyMovements.add(to); if(charFrom>='a' && charFrom<='z'){ LastStepMap = MapString.clone(); } if(charTo =='@') charTo = '.'; MapString[y_from] = MapString[y_from].substring(0,x_from)+charTo+ MapString[y_from].substring(x_from+1); MapString[y_to] = MapString[y_to].substring(0,x_to)+charFrom+ MapString[y_to].substring(x_to+1); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO HasCheckPoint = true; CheckpointMap = LastStepMap; // System.out.print( \"_lastStepMap2\" + _lastStepMap[2].toString()+'\\n'); // Position from = _historyMovements.get(_historyMovements.size()-2); // Position to = _historyMovements.get(_historyMovements.size()-1); // int x_from = from.x(); // int y_from = from.y()+1; // int x_to = to.x(); // int y_to = to.y()+1; // char charFrom = _checkpointMap[y_from].charAt(x_from); // char charTo = _checkpointMap[y_to].charAt(x_to); // _checkpointMap[y_from] = _checkpointMap[y_from].substring(0,x_from)+charTo+ _checkpointMap[y_from].substring(x_from+1); // _checkpointMap[y_to] = _checkpointMap[y_to].substring(0,x_to)+charFrom+_checkpointMap[y_to].substring(x_to+1); // _undo++; // _historyMovements.remove(_historyMovements.size()-2); // _historyMovements.remove(_historyMovements.size()-1); // throw new NotImplementedException(); } public void undo() { // TODO if(HasCheckPoint){ // System.out.print(\"has check point\"); // System.out.print(\"_mapString\"+ _mapString[2].toString()); // System.out.print(\"_checkpointMap\"+ _checkpointMap[2].toString()); MapString = CheckpointMap.clone(); Undo++; HasCheckPoint = false; }else{ MapString = InitialMap; Undo =0; } // throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 1; i< MapString.length; i++){ for(int j = 0; j< MapString[i].length(); j++){ if(MapString[i].charAt(j)-'A' == id){ return new Position(j,i-1); } } } throw new IllegalArgumentException(\"There is no player with the given Id\"); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO int x = position.x(); int y = position.y()+1; if(x>= Width || y>= Height)return null; // System.out.print(_mapString[y].length()+'\\n'); char _char = MapString[y].charAt(x); // System.out.print(_char+\"\\n\"); if (_char>= 'A' && _char<='Z' ){ return new Player(_char -'A'); }else if(_char>='a' && _char <='z'){ return new Box(Character.toLowerCase(_char)-'A'); } else if(_char =='.' || _char =='@'){ return new Empty(); }else if(_char == '#'){ return new Wall(); } else return null; // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO int remain = UndoLimit - Undo; return Optional.of(remain); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "771": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(); // throw new NotImplementedException(); } public void run() { // TODO while(!shouldStop()){ var result = processAction(this.inputEngine.fetchAction()); if(result.getClass() == ActionResult.Failed.class){ renderingEngine.render(this.state); renderingEngine.message(INVALID_INPUT_MESSAGE); }else { renderingEngine.render(this.state); } } // throw new NotImplementedException(); }",
        "label": "F"
    },
    "772": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "773": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.print(content+System.lineSeparator()); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "774": {
        "dataset": "COMP 3021",
        "project": "ychenhq",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // curPosition = map._initialBoxDest.get(map._initialBoxDest.size()-1); Height = map._height; Width = map._width; HistoryMovements = new ArrayList<>(); Players = new ArrayList<>(); BoxDest = new HashSet<>(); InitialMap = map._mapStringNonStatic.clone(); UndoLimit = map._undoLimit; MapString = map._mapStringNonStatic.clone(); Players = map._playersNonStatic; Wall = map._wallNonStatic; Undo =0; BoxDest = map._initialBoxDest; // throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "F"
    },
    "775": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO if (undoLimit == -1) { return Optional.empty(); } else { return Optional.of(undoLimit); } }",
        "label": "P"
    },
    "776": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "777": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "778": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "779": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "780": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "781": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= mapEntities.get(position.y()).size()) { return null; } return mapEntities.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "782": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= mapEntities.get(position.y()).size()) { return null; } return mapEntities.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "783": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "784": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "785": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= mapEntities.get(position.y()).size()) { return null; } return mapEntities.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "786": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= mapEntities.get(position.y()).size()) { return null; } return mapEntities.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "787": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= mapEntities.get(position.y()).size()) { return null; } return mapEntities.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "788": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= mapEntities.get(position.y()).size()) { return null; } return mapEntities.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "789": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); if (inputLine.equals(\"\")) { InvalidInput a = new InvalidInput(0, \"Invalid input\"); return a; } char inputChar = inputLine.charAt(0); // TODO if (inputChar == 'u' || inputChar == 'U') { Undo a = new Undo(0); return a; } else if (inputChar == 'w' || inputChar == 'W') { Move.Up a = new Move.Up(0); return a; } else if (inputChar == 'a' || inputChar == 'A') { Move.Left a = new Move.Left(0); return a; } else if (inputChar == 's' || inputChar == 'S') { Move.Down a = new Move.Down(0); return a; } else if (inputChar == 'd' || inputChar == 'D') { Move.Right a = new Move.Right(0); return a; } else if (inputChar == 'k' || inputChar == 'K') { Move.Up a = new Move.Up(1); return a; } else if (inputChar == 'h' || inputChar == 'H') { Move.Left a = new Move.Left(1); return a; } else if (inputChar == 'j' || inputChar == 'J') { Move.Down a = new Move.Down(1); return a; } else if (inputChar == 'l' || inputChar == 'L') { Move.Right a = new Move.Right(1); return a; } else if (inputLine.equalsIgnoreCase(\"exit\")) { Exit a = new Exit(0); return a; } else { InvalidInput a = new InvalidInput(0, \"Invalid input\"); return a; } }",
        "label": "P"
    },
    "790": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public void move(Position from, Position to) { // TODO putStateEntity(to,getStateEntity(from)); if (getStateEntity(from).getClass().getSimpleName().equals(\"Player\")) { int iD = ((Player)getStateEntity(from)).getId(); for (int i = 0; i < playerIDPos.size(); ++i) { if (iD == playerIDPos.get(i).getId()) { playerIDPos.get(i).changePos(to); } } } if (map.getDestinations().contains(from)) { putStateEntity(from, new Empty()); } else putStateEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "791": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public void move(Position from, Position to) { // TODO putStateEntity(to,getStateEntity(from)); if (getStateEntity(from).getClass().getSimpleName().equals(\"Player\")) { int iD = ((Player)getStateEntity(from)).getId(); for (int i = 0; i < playerIDPos.size(); ++i) { if (iD == playerIDPos.get(i).getId()) { playerIDPos.get(i).changePos(to); } } } if (map.getDestinations().contains(from)) { putStateEntity(from, new Empty()); } else putStateEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i < playerIDPos.size(); ++i) { if (playerIDPos.get(i).getId() == id) { return playerIDPos.get(i).getP(); } } throw new NoSuchElementException(); }",
        "label": "P"
    },
    "792": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public void move(Position from, Position to) { // TODO putStateEntity(to,getStateEntity(from)); if (getStateEntity(from).getClass().getSimpleName().equals(\"Player\")) { int iD = ((Player)getStateEntity(from)).getId(); for (int i = 0; i < playerIDPos.size(); ++i) { if (iD == playerIDPos.get(i).getId()) { playerIDPos.get(i).changePos(to); } } } if (map.getDestinations().contains(from)) { putStateEntity(from, new Empty()); } else putStateEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i < playerIDPos.size(); ++i) { if (playerIDPos.get(i).getId() == id) { return playerIDPos.get(i).getP(); } } throw new NoSuchElementException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= mapEntities.get(position.y()).size()) { return null; } return mapEntities.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "793": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public Optional<Integer> getUndoQuota() { // TODO if (undoQuota == -1) { return Optional.empty(); } else { return Optional.of(undoQuota); } }",
        "label": "P"
    },
    "794": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> x = new HashSet<Position>(); for (int i = 0; i < playerIDPos.size(); ++i) { x.add(playerIDPos.get(i).getP()); } return x; }",
        "label": "P"
    },
    "795": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public void move(Position from, Position to) { // TODO putStateEntity(to,getStateEntity(from)); if (getStateEntity(from).getClass().getSimpleName().equals(\"Player\")) { int iD = ((Player)getStateEntity(from)).getId(); for (int i = 0; i < playerIDPos.size(); ++i) { if (iD == playerIDPos.get(i).getId()) { playerIDPos.get(i).changePos(to); } } } if (map.getDestinations().contains(from)) { putStateEntity(from, new Empty()); } else putStateEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO ArrayList<PlayerIdPos> newIP = new ArrayList<PlayerIdPos>(); for (int i = 0; i < this.playerIDPos.size(); ++i) { newIP.add(this.playerIDPos.get(i)); } ArrayList<ArrayList<Entity>> newMapEntities = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < this.mapEntities.size(); ++i) { var x = new ArrayList<Entity>(); for (int j = 0; j < this.mapEntities.get(i).size(); ++j) { Entity y = this.mapEntities.get(i).get(j); x.add(y); } newMapEntities.add(x); } UndoState undostate = new UndoState(newIP, newMapEntities, this.moves); this.undoStates.add(undostate); } public void undo() { // TODO int undoIdx; if (undoStates.size() == 1) { undoIdx = 0; } else { undoIdx= undoStates.size() - 2; } ArrayList<PlayerIdPos> newIP = new ArrayList<PlayerIdPos>(); for (int i = 0; i < undoStates.get(undoIdx).getPlayerIDPos().size(); ++i) { PlayerIdPos temp = undoStates.get(undoIdx).getPlayerIDPos().get(i); var pIP = new PlayerIdPos(temp.getId(),temp.getP()); newIP.add(pIP); } this.playerIDPos = newIP; ArrayList<ArrayList<Entity>> newMapEntities = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < undoStates.get(undoIdx).getMapEntities().size(); ++i) { var x = new ArrayList<Entity>(); for (int j = 0; j < undoStates.get(undoIdx).getMapEntities().get(i).size(); ++j) { Entity y = undoStates.get(undoIdx).getMapEntities().get(i).get(j); x.add(y); } newMapEntities.add(x); } this.mapEntities = newMapEntities; if (undoStates.size() > 1) { undoStates.remove(undoStates.size() - 1); reduceUndoQuota(); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i < playerIDPos.size(); ++i) { if (playerIDPos.get(i).getId() == id) { return playerIDPos.get(i).getP(); } } throw new NoSuchElementException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if (position.x() >= mapEntities.get(position.y()).size()) { return null; } return mapEntities.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (undoQuota == -1) { return Optional.empty(); } else { return Optional.of(undoQuota); } }",
        "label": "P"
    },
    "796": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if (gameState.numPlayer > 2) { this.renderingEngine.message(\"This number of players are not supported\"); throw new IllegalArgumentException(); } } public void run() { // TODO this.renderingEngine.message(\"Sokoban game is ready.\"); while (!this.state.isWin()) { this.renderingEngine.render(this.state); if(!state.getUndoQuota().isEmpty()) { this.renderingEngine.message(System.lineSeparator() + \"Undo Quota: \" + state.getUndoQuota().get() + System.lineSeparator() + \">>>\"); } else this.renderingEngine.message(\"Unlimited\"); ActionResult x = this.processAction(this.inputEngine.fetchAction()); if (x.getAction().getClass().getSimpleName().equals(\"Exit\")) { this.renderingEngine.render(this.state); this.renderingEngine.message(System.lineSeparator() + \"Game exits.\"); return; } } this.renderingEngine.render(this.state); this.renderingEngine.message(\"Game exits.\"); this.renderingEngine.message( \"You win.\"); }",
        "label": "P"
    },
    "797": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if (gameState.numPlayer > 2) { this.renderingEngine.message(\"This number of players are not supported\"); throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "798": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.print(content + System.lineSeparator()); }",
        "label": "P"
    },
    "799": {
        "dataset": "COMP 3021",
        "project": "jhwangae",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuota = map.getUndoLimit().get(); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.playerIDPos = map.playerIDPos; this.mapEntities = map.getMapEntities(); this.destinations = map.getDestinations(); this.map = map; this.emptySpace = map.emptySpace; this.numPlayer = map.numPlayer; this.checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "800": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO if(undoLimit >= 0) return Optional.of(undoLimit); else if(undoLimit == - 1) return Optional.ofNullable(null); else throw new IllegalArgumentException(\"Invalid Limit.\"); }",
        "label": "P"
    },
    "801": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "802": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "803": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "804": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "805": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "806": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO switch (CurrentMap.get(position.y()).get(position.x())){ case '@': return new Empty(); case '.': return new Empty(); case '#': return new Wall(); case ' ': //throw new IllegalArgumentException(\"out of boundar.\"); return null; default: if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[A-Z]\")){ return new Player(CurrentMap.get(position.y()).get(position.x()) - 'A'); } else if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[a-z]\")){ return new Box(CurrentMap.get(position.y()).get(position.x()) - 'a'); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "807": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO switch (CurrentMap.get(position.y()).get(position.x())){ case '@': return new Empty(); case '.': return new Empty(); case '#': return new Wall(); case ' ': //throw new IllegalArgumentException(\"out of boundar.\"); return null; default: if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[A-Z]\")){ return new Player(CurrentMap.get(position.y()).get(position.x()) - 'A'); } else if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[a-z]\")){ return new Box(CurrentMap.get(position.y()).get(position.x()) - 'a'); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "808": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "809": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "810": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return new HashSet<>(destination); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO switch (CurrentMap.get(position.y()).get(position.x())){ case '@': return new Empty(); case '.': return new Empty(); case '#': return new Wall(); case ' ': //throw new IllegalArgumentException(\"out of boundar.\"); return null; default: if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[A-Z]\")){ return new Player(CurrentMap.get(position.y()).get(position.x()) - 'A'); } else if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[a-z]\")){ return new Box(CurrentMap.get(position.y()).get(position.x()) - 'a'); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "811": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO switch (CurrentMap.get(position.y()).get(position.x())){ case '@': return new Empty(); case '.': return new Empty(); case '#': return new Wall(); case ' ': //throw new IllegalArgumentException(\"out of boundar.\"); return null; default: if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[A-Z]\")){ return new Player(CurrentMap.get(position.y()).get(position.x()) - 'A'); } else if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[a-z]\")){ return new Box(CurrentMap.get(position.y()).get(position.x()) - 'a'); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "812": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO switch (CurrentMap.get(position.y()).get(position.x())){ case '@': return new Empty(); case '.': return new Empty(); case '#': return new Wall(); case ' ': //throw new IllegalArgumentException(\"out of boundar.\"); return null; default: if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[A-Z]\")){ return new Player(CurrentMap.get(position.y()).get(position.x()) - 'A'); } else if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[a-z]\")){ return new Box(CurrentMap.get(position.y()).get(position.x()) - 'a'); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "813": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO switch (CurrentMap.get(position.y()).get(position.x())){ case '@': return new Empty(); case '.': return new Empty(); case '#': return new Wall(); case ' ': //throw new IllegalArgumentException(\"out of boundar.\"); return null; default: if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[A-Z]\")){ return new Player(CurrentMap.get(position.y()).get(position.x()) - 'A'); } else if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[a-z]\")){ return new Box(CurrentMap.get(position.y()).get(position.x()) - 'a'); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "814": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); //TODO done if(inputLine.isEmpty()){ return new InvalidInput(0, \"empty input\"); } if(inputLine.matches(\"exit\")){ return new Exit(0); } switch(inputLine.toLowerCase().charAt(0)){ case 'w': // if(GameState.current_player % 2 == 0) return new Move.Up(0); // break; case 'a': // if(GameState.current_player % 2 == 0) return new Move.Left(0); // break; case 's': // if(GameState.current_player % 2 == 0) return new Move.Down(0); // break; case 'd': // if(GameState.current_player % 2 == 0) return new Move.Right(0); // break; case 'h': // if(GameState.current_player % 2 == 1) return new Move.Left(1); // break; case 'j': // if(GameState.current_player % 2 == 1) return new Move.Down(1); // break; case 'k': // if(GameState.current_player % 2 == 1) return new Move.Up(1); // break; case 'l': // if(GameState.current_player % 2 == 1) return new Move.Right(1); // break; case 'u': return new Undo(0); default: } return null; }",
        "label": "P"
    },
    "815": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public void move(Position from, Position to) { // TODO var FromEnt = getEntity(from); CurrentMap.get(to.y()).set(to.x(), CurrentMap.get(from.y()).get(from.x())); var TO = gameMap.Map.get(from.y()).get(from.x()); if(TO.toString().matches(\"[A-Za-z]\")) TO = '.'; CurrentMap.get(from.y()).set(from.x(), TO); if((FromEnt).getClass() == Player.class) { player_location.set(((Player) FromEnt).getId(), new Location(((Player) FromEnt).getId(), to)); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "816": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public void move(Position from, Position to) { // TODO var FromEnt = getEntity(from); CurrentMap.get(to.y()).set(to.x(), CurrentMap.get(from.y()).get(from.x())); var TO = gameMap.Map.get(from.y()).get(from.x()); if(TO.toString().matches(\"[A-Za-z]\")) TO = '.'; CurrentMap.get(from.y()).set(from.x(), TO); if((FromEnt).getClass() == Player.class) { player_location.set(((Player) FromEnt).getId(), new Location(((Player) FromEnt).getId(), to)); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < player_location.size(); i++){ if(player_location.get(i).playerid() == id) { return new Position(player_location.get(i).pos().x(), player_location.get(i).pos().y()); } } return null; }",
        "label": "P"
    },
    "817": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public void move(Position from, Position to) { // TODO var FromEnt = getEntity(from); CurrentMap.get(to.y()).set(to.x(), CurrentMap.get(from.y()).get(from.x())); var TO = gameMap.Map.get(from.y()).get(from.x()); if(TO.toString().matches(\"[A-Za-z]\")) TO = '.'; CurrentMap.get(from.y()).set(from.x(), TO); if((FromEnt).getClass() == Player.class) { player_location.set(((Player) FromEnt).getId(), new Location(((Player) FromEnt).getId(), to)); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < player_location.size(); i++){ if(player_location.get(i).playerid() == id) { return new Position(player_location.get(i).pos().x(), player_location.get(i).pos().y()); } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO switch (CurrentMap.get(position.y()).get(position.x())){ case '@': return new Empty(); case '.': return new Empty(); case '#': return new Wall(); case ' ': //throw new IllegalArgumentException(\"out of boundar.\"); return null; default: if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[A-Z]\")){ return new Player(CurrentMap.get(position.y()).get(position.x()) - 'A'); } else if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[a-z]\")){ return new Box(CurrentMap.get(position.y()).get(position.x()) - 'a'); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "818": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public Optional<Integer> getUndoQuota() { // TODO if(undoQuota >= 0) return Optional.of(undoQuota); else if(undoQuota == -1) return Optional.ofNullable(null); else throw new IllegalArgumentException(\"Invalid Limit.\"); }",
        "label": "P"
    },
    "819": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> temp = new HashSet<Position>(); for(int i = 0; i < player_location.size(); i++){ temp.add(player_location.get(i).pos()); } return temp; }",
        "label": "P"
    },
    "820": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public void move(Position from, Position to) { // TODO var FromEnt = getEntity(from); CurrentMap.get(to.y()).set(to.x(), CurrentMap.get(from.y()).get(from.x())); var TO = gameMap.Map.get(from.y()).get(from.x()); if(TO.toString().matches(\"[A-Za-z]\")) TO = '.'; CurrentMap.get(from.y()).set(from.x(), TO); if((FromEnt).getClass() == Player.class) { player_location.set(((Player) FromEnt).getId(), new Location(((Player) FromEnt).getId(), to)); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<Location>(player_location))); } public void undo() { // TODO if(Checkpoints.size() <= 1) return; var checkpoint= Checkpoints.get(Checkpoints.size()-2); Checkpoints.remove(Checkpoints.size()-1); CurrentMap = checkpoint.map(); player_location = checkpoint.player_loc(); undoQuota -= 1; } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < player_location.size(); i++){ if(player_location.get(i).playerid() == id) { return new Position(player_location.get(i).pos().x(), player_location.get(i).pos().y()); } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO switch (CurrentMap.get(position.y()).get(position.x())){ case '@': return new Empty(); case '.': return new Empty(); case '#': return new Wall(); case ' ': //throw new IllegalArgumentException(\"out of boundar.\"); return null; default: if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[A-Z]\")){ return new Player(CurrentMap.get(position.y()).get(position.x()) - 'A'); } else if(CurrentMap.get(position.y()).get(position.x()).toString().matches(\"[a-z]\")){ return new Box(CurrentMap.get(position.y()).get(position.x()) - 'a'); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if(undoQuota >= 0) return Optional.of(undoQuota); else if(undoQuota == -1) return Optional.ofNullable(null); else throw new IllegalArgumentException(\"Invalid Limit.\"); }",
        "label": "P"
    },
    "821": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if( state.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"invalid number of player\"); } } public void run() { // TODO while(!shouldStop()){ renderingEngine.render(state); Action act = inputEngine.fetchAction(); ActionResult result = processAction(act); if(result instanceof ActionResult.Failed) { System.out.println(((ActionResult.Failed) result).getReason()); } var undoQuota = state.getUndoQuota(); if (undoQuota.orElse(-2) > -1) { renderingEngine.message(\"Undo Quota: \" + undoQuota.orElse(-2)); } else if (undoQuota.isEmpty()) { renderingEngine.message(\"Undo Quota: unlimited\"); } } renderingEngine.render(state); if(state.isWin()) renderingEngine.message(\"you win\"); }",
        "label": "P"
    },
    "822": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO if( state.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"invalid number of player\"); } }",
        "label": "P"
    },
    "823": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "824": {
        "dataset": "COMP 3021",
        "project": "cfjlu",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( List<Character> sublist : map.Map) { CurrentMap.add(new ArrayList<>(sublist)); } undoQuota = map.getUndoLimit().get().intValue(); destination = new HashSet<>(map.getDestinations()); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); gameMap = map; playerId = new HashSet<>(map.getPlayerIds()); //sort the player location List<Location> tem_loc = new ArrayList<Location>( map.getPlayers_loc()); while (!tem_loc.isEmpty()){ int temp = tem_loc.get(0).playerid(); int x = 0; for(int j = 0; j < tem_loc.size(); j++){ if(tem_loc.get(j).playerid() < temp) temp = tem_loc.get(j).playerid(); x = j; } player_location.add(new Location(tem_loc.get(x).playerid(), new Position(tem_loc.get(x).pos().x(), tem_loc.get(x).pos().y()))); tem_loc.remove(x); } List<List<Character>> TMap = new ArrayList<>(); for( List<Character> sublist : CurrentMap) { TMap.add(new ArrayList<>(sublist)); } Checkpoints.add(new Checkpoint(TMap, undoQuota, new ArrayList<>(player_location))); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "825": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; } public int getMaxHeight() { // TODO return height; } } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undolimit); }",
        "label": "P"
    },
    "826": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "827": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "828": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "829": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "830": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "831": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(thismap.wall.contains(position)){ return new Wall(); } for(int i=0;i<26;i++){ if(thismap.box.get(i)==null || thismap.player.get(i)==null){ continue; } else if(thismap.box.get(i).contains(position)){ return new Box(i); } else if(thismap.player.get(i).equals(position)){ return new Player(i); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "832": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(thismap.wall.contains(position)){ return new Wall(); } for(int i=0;i<26;i++){ if(thismap.box.get(i)==null || thismap.player.get(i)==null){ continue; } else if(thismap.box.get(i).contains(position)){ return new Box(i); } else if(thismap.player.get(i).equals(position)){ return new Player(i); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "833": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; } }",
        "label": "P"
    },
    "834": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; }",
        "label": "P"
    },
    "835": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return thismap.destination; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(thismap.wall.contains(position)){ return new Wall(); } for(int i=0;i<26;i++){ if(thismap.box.get(i)==null || thismap.player.get(i)==null){ continue; } else if(thismap.box.get(i).contains(position)){ return new Box(i); } else if(thismap.player.get(i).equals(position)){ return new Player(i); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "836": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(thismap.wall.contains(position)){ return new Wall(); } for(int i=0;i<26;i++){ if(thismap.box.get(i)==null || thismap.player.get(i)==null){ continue; } else if(thismap.box.get(i).contains(position)){ return new Box(i); } else if(thismap.player.get(i).equals(position)){ return new Player(i); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "837": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(thismap.wall.contains(position)){ return new Wall(); } for(int i=0;i<26;i++){ if(thismap.box.get(i)==null || thismap.player.get(i)==null){ continue; } else if(thismap.box.get(i).contains(position)){ return new Box(i); } else if(thismap.player.get(i).equals(position)){ return new Player(i); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "838": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(thismap.wall.contains(position)){ return new Wall(); } for(int i=0;i<26;i++){ if(thismap.box.get(i)==null || thismap.player.get(i)==null){ continue; } else if(thismap.box.get(i).contains(position)){ return new Box(i); } else if(thismap.player.get(i).equals(position)){ return new Player(i); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "839": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO if(inputLine.equals(StringResources.EXIT_COMMAND_TEXT)){ return new Exit(0); } else if(inputLine.equals(\"A\") || inputLine.equals(\"H\")){ return new Move.Left(0); } else if(inputLine.equals(\"S\") || inputLine.equals(\"J\")){ return new Move.Down(0); } else if(inputLine.equals(\"W\") || inputLine.equals(\"K\")){ return new Move.Up(0); } else if(inputLine.equals(\"D\") || inputLine.equals(\"L\")){ return new Move.Right(0); } else if(inputLine.equals(\"U\")){ return new Undo(0); } return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); }",
        "label": "P"
    },
    "840": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public void move(Position from, Position to) { // TODO Entity fr=getEntity(from); thismap.removeEntity(from,fr); thismap.putEntity(to,fr); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "841": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public void move(Position from, Position to) { // TODO Entity fr=getEntity(from); thismap.removeEntity(from,fr); thismap.putEntity(to,fr); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return thismap.player.get(id); }",
        "label": "P"
    },
    "842": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public void move(Position from, Position to) { // TODO Entity fr=getEntity(from); thismap.removeEntity(from,fr); thismap.putEntity(to,fr); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return thismap.player.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(thismap.wall.contains(position)){ return new Wall(); } for(int i=0;i<26;i++){ if(thismap.box.get(i)==null || thismap.player.get(i)==null){ continue; } else if(thismap.box.get(i).contains(position)){ return new Box(i); } else if(thismap.player.get(i).equals(position)){ return new Player(i); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "843": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public Optional<Integer> getUndoQuota() { // TODO return Optional.of(thismap.undolimit); }",
        "label": "P"
    },
    "844": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> t=new HashSet<>(); for(int i=0;i<26;i++){ if((thismap.player.get(i)!=null)){ t.add(getPlayerPositionById(i)); } } return t; }",
        "label": "P"
    },
    "845": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public void move(Position from, Position to) { // TODO Entity fr=getEntity(from); thismap.removeEntity(from,fr); thismap.putEntity(to,fr); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO p.add(thismap); } public void undo() { // TODO if(p.size()==2){ thismap=p.get(0); } else{ thismap=p.get(p.size()-2); } thismap.undolimit--; } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO return thismap.player.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(thismap.wall.contains(position)){ return new Wall(); } for(int i=0;i<26;i++){ if(thismap.box.get(i)==null || thismap.player.get(i)==null){ continue; } else if(thismap.box.get(i).contains(position)){ return new Box(i); } else if(thismap.player.get(i).equals(position)){ return new Player(i); } } return new Empty(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return Optional.of(thismap.undolimit); }",
        "label": "P"
    },
    "846": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine=inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(this.state.getAllPlayerPositions().size()>2){ throw new IllegalArgumentException(); } } public void run() { // TODO renderingEngine.render(state); while(!this.state.isWin()){ var t=inputEngine.fetchAction(); renderingEngine.render(this.state); if(t instanceof Exit){ renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); break; } if(t instanceof InvalidInput){ renderingEngine.message(StringResources.INVALID_INPUT_MESSAGE); } if(processAction(t) instanceof ActionResult.Failed){ renderingEngine.message(StringResources.INVALID_INPUT_MESSAGE); } if(state.getUndoQuota()==Optional.of(0)){ renderingEngine.message(StringResources.UNDO_QUOTA_RUN_OUT); } } renderingEngine.message(StringResources.WIN_MESSAGE); }",
        "label": "P"
    },
    "847": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine=inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(this.state.getAllPlayerPositions().size()>2){ throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "848": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "849": {
        "dataset": "COMP 3021",
        "project": "tliangac",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO for( char c = 'a'; c <= 'z'; ++c){ player.put((int)(c-'a'),null); box.put((int)(c-'a'),null); } width=map.width; height=map.height; undolimit=map.undolimit; for(Position t:map.destination){ destination.add(new Position(t.x(),t.y())); } for(Position t:map.wall){ wall.add(new Position(t.x(),t.y())); } for(Position t:map.empty){ empty.add(new Position(t.x(),t.y())); } for(int i=0;i<26;i++){ if(map.player.get(i)!=null){ player.put(i,new Position(map.player.get(i).x(),map.player.get(i).y())); } if(map.box.get(i)!=null){ box.put(i,new ArrayList<>()); for(int j=0;j<map.box.get(i).size();j++){ box.get(i).add(new Position(map.box.get(i).get(j).x(),map.box.get(i).get(j).y())); } } } thismap=map; p.add(new GameMap(width,height,destination,undolimit,wall,player,box,empty)); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "850": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO return this.maxHeight; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "851": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "852": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "853": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "854": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "855": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "856": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "857": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "858": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "859": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "860": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.map.getDestinations(); // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "861": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "862": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "863": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "864": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO String strInputLine = ((String) inputLine).strip(); // Return exit action if exit is prompted: Special case if(strInputLine.toLowerCase().compareTo(StringResources.EXIT_COMMAND_TEXT) == 0){ return new Exit(0); } // Else, input is deemed invalid if length more than 1 character if(strInputLine.length() != 1) { return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); } char charInputLine = strInputLine.charAt(0); // Invalid if character is not letter if(!Character.isLetter(charInputLine)) { return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); } if(Character.toLowerCase(charInputLine) - 'a' == 0){ return new Move.Left(0); } if(Character.toLowerCase(charInputLine) - 's' == 0){ return new Move.Down(0); } if(Character.toLowerCase(charInputLine) - 'w' == 0){ return new Move.Up(0); } if(Character.toLowerCase(charInputLine) - 'd' == 0){ return new Move.Right(0); } if(Character.toLowerCase(charInputLine) - 'h' == 0){ return new Move.Left(1); } if(Character.toLowerCase(charInputLine) - 'j' == 0){ return new Move.Down(1); } if(Character.toLowerCase(charInputLine) - 'k' == 0){ return new Move.Up(1); } if(Character.toLowerCase(charInputLine) - 'l' == 0){ return new Move.Right(1); } if(Character.toLowerCase(charInputLine) - 'u' == 0){ return new Undo(0); } return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "865": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity fromEntity = this.map.getEntity(from); Entity toEntity = this.map.getEntity(to); this.map.putEntity(from, toEntity); this.map.putEntity(to, fromEntity); Position[] moveArr = {from, to}; this.latestMoves.add(0, moveArr); // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "866": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity fromEntity = this.map.getEntity(from); Entity toEntity = this.map.getEntity(to); this.map.putEntity(from, toEntity); this.map.putEntity(to, fromEntity); Position[] moveArr = {from, to}; this.latestMoves.add(0, moveArr); // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO int maxWidth = this.map.getMaxWidth(); int maxHeight = this.map.getMaxHeight(); for(int i = 0; i < maxWidth; i++){ for(int j = 0; j < maxHeight; j++){ Position pos = Position.of(i, j); Entity thisEntity = this.map.getEntity(pos); if(thisEntity instanceof Player){ if(((Player) thisEntity).getId() == id) { return pos; } } } } return null; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "867": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity fromEntity = this.map.getEntity(from); Entity toEntity = this.map.getEntity(to); this.map.putEntity(from, toEntity); this.map.putEntity(to, fromEntity); Position[] moveArr = {from, to}; this.latestMoves.add(0, moveArr); // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO int maxWidth = this.map.getMaxWidth(); int maxHeight = this.map.getMaxHeight(); for(int i = 0; i < maxWidth; i++){ for(int j = 0; j < maxHeight; j++){ Position pos = Position.of(i, j); Entity thisEntity = this.map.getEntity(pos); if(thisEntity instanceof Player){ if(((Player) thisEntity).getId() == id) { return pos; } } } } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "868": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "869": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> result = new HashSet<Position>(); int maxWidth = this.map.getMaxWidth(); int maxHeight = this.map.getMaxHeight(); for(int i = 0; i < maxWidth; i++){ for(int j = 0; j < maxHeight; j++){ Position pos = Position.of(i, j); if(this.map.getEntity(pos) instanceof Player){ result.add(pos); } } } return result; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "870": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity fromEntity = this.map.getEntity(from); Entity toEntity = this.map.getEntity(to); this.map.putEntity(from, toEntity); this.map.putEntity(to, fromEntity); Position[] moveArr = {from, to}; this.latestMoves.add(0, moveArr); // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO ArrayList<Position[]> savedMoves = new ArrayList<Position[]>(); for(Position[] move: this.latestMoves){ savedMoves.add(new Position[]{move[0], move[1]}); } this.historicalMoves.add(savedMoves); this.latestMoves.clear(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public void undo() { // TODO if(this.historicalMoves.size() > 0){ ArrayList<Position[]> moves = this.historicalMoves.remove(this.historicalMoves.size() - 1); for(Position[] move : moves){ this.moveWithoutRecord(move[1], move[0]); } if(this.undoQuota.isPresent()) { this.undoQuota = Optional.of(this.getUndoQuota().get() - 1); } } else{ // No checkpoints, revert to initial gamestate if(this.latestMoves.size() > 0){ ArrayList<Position[]> moves = this.latestMoves; for(Position[] move : moves){ this.moveWithoutRecord(move[1], move[0]); } this.latestMoves.clear(); // if(this.undoQuota.isPresent()) { // this.undoQuota = Optional.of(this.getUndoQuota().get() - 1); // } } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO int maxWidth = this.map.getMaxWidth(); int maxHeight = this.map.getMaxHeight(); for(int i = 0; i < maxWidth; i++){ for(int j = 0; j < maxHeight; j++){ Position pos = Position.of(i, j); Entity thisEntity = this.map.getEntity(pos); if(thisEntity instanceof Player){ if(((Player) thisEntity).getId() == id) { return pos; } } } } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "871": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } // throw new NotImplementedException(); } public void run() { // TODO // Initial message printing renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(this.state); // Enter game loop while(!this.shouldStop()){ // Print undoQuota // Unlimited undoQuota if(!this.state.getUndoQuota().isPresent()){ this.renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, StringResources.UNDO_QUOTA_UNLIMITED)); } else { // Pre-set undoQuota this.renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, String.valueOf(this.state.getUndoQuota().get()))); } // Prompt user input this.renderingEngine.message(new String(\">>>\")); // Fetch user input, process result Action action = this.inputEngine.fetchAction(); ActionResult result = this.processAction(action); if(result instanceof ActionResult.Failed){ renderingEngine.message(((ActionResult.Failed)result).getReason()); } // Print State renderingEngine.render(this.state); renderingEngine.message(\"\\n\"); } if(this.state.isWin()){ renderingEngine.message(StringResources.WIN_MESSAGE); } else{ renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "872": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "873": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "874": {
        "dataset": "COMP 3021",
        "project": "phchauaa",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.historicalMoves = new ArrayList<ArrayList<Position[]>>(); this.latestMoves = new ArrayList<Position[]>(); // this.historicalStates = new ArrayList<GameState>(); // this.historicalStates.add(this); // throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { final var builder = new StringBuilder(); Set<Position> destinations = state.getDestinations(); for (int y = 0; y < state.getMapMaxHeight(); y++) { for (int x = 0; x < state.getMapMaxWidth(); x++) { final var entity = state.getEntity(Position.of(x, y)); boolean isDestination = false; for(Position des : destinations){ if(des.x() == x && des.y() == y){ isDestination = true; break; } } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public String toString(){ String result = \"\"; for(int i = 0; i < maxHeight; i++){ for(int j = 0; j < maxWidth; j++){ switch(this.map[j][i]) { case Wall w -> result += '#'; case Box b -> result += (char)(Integer.valueOf('a') + b.getPlayerId()); case Player p -> result += (char)(Integer.valueOf('A') + p.getId()); case Empty e -> result += '.'; default -> result = result; } } result += '\\n'; } return result; }",
        "label": "P"
    },
    "875": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; } public int getMaxHeight() { // TODO return maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return undoLimit; }",
        "label": "P"
    },
    "876": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "877": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "878": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "879": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "880": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "881": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return getCurrentState().getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "882": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return getCurrentState().getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "883": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; }",
        "label": "P"
    },
    "884": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; }",
        "label": "P"
    },
    "885": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return getCurrentState().getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return getCurrentState().getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "886": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return getCurrentState().getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "887": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return getCurrentState().getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "888": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return getCurrentState().getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "889": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. var inputLine = terminalScanner.nextLine(); inputLine = inputLine.toLowerCase(); // TODO Action action = switch(inputLine){ case \"a\" -> new Move.Left(0); case \"h\" -> new Move.Left(1); case \"s\" -> new Move.Down(0); case \"j\" -> new Move.Down(1); case \"w\" -> new Move.Up(0); case \"k\" -> new Move.Up(1); case \"d\" -> new Move.Right(0); case \"l\" -> new Move.Right(1); case \"u\" -> new Undo(0); case EXIT_COMMAND_TEXT -> new Exit(0); default -> new InvalidInput(0, INVALID_INPUT_MESSAGE); }; return action; }",
        "label": "P"
    },
    "890": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public void move(Position from, Position to) { // TODO var currentGameMap = getCurrentState(); currentGameMap.putEntity(to, currentGameMap.getEntity(from)); currentGameMap.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "891": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public void move(Position from, Position to) { // TODO var currentGameMap = getCurrentState(); currentGameMap.putEntity(to, currentGameMap.getEntity(from)); currentGameMap.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO var currentGameMap = getCurrentState(); var currentEntityMap = currentGameMap.getEntityMap(); for (int i = 0; i < currentGameMap.getMaxHeight(); i++){ for (int j = 0; j < currentGameMap.getMaxWidth(); j++){ if (currentEntityMap[i][j] instanceof Player){ if (((Player) currentEntityMap[i][j]).getId() == id) return new Position(j, i); } } } return null; }",
        "label": "P"
    },
    "892": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public void move(Position from, Position to) { // TODO var currentGameMap = getCurrentState(); currentGameMap.putEntity(to, currentGameMap.getEntity(from)); currentGameMap.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO var currentGameMap = getCurrentState(); var currentEntityMap = currentGameMap.getEntityMap(); for (int i = 0; i < currentGameMap.getMaxHeight(); i++){ for (int j = 0; j < currentGameMap.getMaxWidth(); j++){ if (currentEntityMap[i][j] instanceof Player){ if (((Player) currentEntityMap[i][j]).getId() == id) return new Position(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return getCurrentState().getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "893": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public Optional<Integer> getUndoQuota() { // TODO return getCurrentState().getUndoLimit(); }",
        "label": "P"
    },
    "894": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO var currentGameMap = getCurrentState(); var currentEntityMap = currentGameMap.getEntityMap(); Set<Position> playerPositions = new HashSet<>(); for (int i = 0; i < currentGameMap.getMaxHeight(); i++){ for (int j = 0; j < currentGameMap.getMaxWidth(); j++){ if (currentEntityMap[i][j] instanceof Player) playerPositions.add(new Position(j, i)); } } return playerPositions; }",
        "label": "P"
    },
    "895": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public void move(Position from, Position to) { // TODO var currentGameMap = getCurrentState(); currentGameMap.putEntity(to, currentGameMap.getEntity(from)); currentGameMap.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO gameStates.add(new GameMap(getCurrentState())); currentState++; } public void undo() { // TODO int temp = -1; if (getCurrentState().getUndoLimit().isPresent()){ temp = getCurrentState().getUndoLimit().get(); } gameStates.remove(currentState); currentState -= 1; if (currentState >= 1){ gameStates.remove(currentState); currentState -= 1; if (temp != -1){ // int temp = getCurrentState().getUndoLimit().get(); temp -= 1; getCurrentState().setUndoLimit(Optional.of(temp)); } } checkpoint(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO var currentGameMap = getCurrentState(); var currentEntityMap = currentGameMap.getEntityMap(); for (int i = 0; i < currentGameMap.getMaxHeight(); i++){ for (int j = 0; j < currentGameMap.getMaxWidth(); j++){ if (currentEntityMap[i][j] instanceof Player){ if (((Player) currentEntityMap[i][j]).getId() == id) return new Position(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return getCurrentState().getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return getCurrentState().getUndoLimit(); }",
        "label": "P"
    },
    "896": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); } public void run() { // TODO renderingEngine.message(GAME_READY_MESSAGE); renderingEngine.render(state); /*if (state.getUndoQuota().isPresent()) renderingEngine.message(String.format(UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get())); else renderingEngine.message(UNDO_QUOTA_UNLIMITED);*/ while(!shouldStop()){ if (state.getUndoQuota().isPresent()) renderingEngine.message(String.format(UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get())); else renderingEngine.message(UNDO_QUOTA_UNLIMITED); renderingEngine.message(\">>>\"); final var result = processAction(inputEngine.fetchAction()); if (result instanceof ActionResult.Failed) renderingEngine.message(((ActionResult.Failed) result).getReason()); renderingEngine.render(state); } renderingEngine.message(GAME_EXIT_MESSAGE); if (state.isWin()) renderingEngine.message(WIN_MESSAGE); // System.exit(0); }",
        "label": "P"
    },
    "897": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "898": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); // System.out.println(content); }",
        "label": "P"
    },
    "899": {
        "dataset": "COMP 3021",
        "project": "hywongcj",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO gameStates.add(map); checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "900": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; //throw new NotImplementedException(); } public int getMaxHeight() { // TODO return this.maxHeight; //throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "901": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "902": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "903": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "904": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "905": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "906": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return mapHashMap.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "907": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return mapHashMap.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "908": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "909": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "910": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); //throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return mapHashMap.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "911": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return mapHashMap.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "912": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return mapHashMap.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "913": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return mapHashMap.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "914": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO Action actions = null; if (inputLine.equals(\"W\") || inputLine.equals(\"w\") ) { actions = new Move.Up(0); } if (inputLine.equals(\"A\") || inputLine.equals(\"a\") ) { actions = new Move.Left(0); } if (inputLine.equals(\"S\") || inputLine.equals(\"s\") ) { actions = new Move.Down(0); } if (inputLine.equals(\"D\") || inputLine.equals(\"d\") ) { actions = new Move.Right(0); } if (inputLine.equals(\"H\") || inputLine.equals(\"h\") ) { actions = new Move.Left(1); } if (inputLine.equals(\"J\") || inputLine.equals(\"j\") ) { actions = new Move.Down(1); } if (inputLine.equals(\"K\") || inputLine.equals(\"k\") ) { actions = new Move.Up(1); } if (inputLine.equals(\"L\") || inputLine.equals(\"l\") ) { actions = new Move.Right(1); } if (inputLine.equals(\"U\") || inputLine.equals(\"u\") ) { actions = new Undo(0); } if (inputLine.equals(\"exit\")) { actions = new Exit(0); } return actions; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "915": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity entityFrom = mapHashMap.get(from); Entity entityTo = mapHashMap.get(to); mapHashMap.remove(from,entityFrom); mapHashMap.remove(to,entityTo); mapHashMap.put(to, entityFrom); mapHashMap.put(from, new Empty()); // if (entityFrom.getClass() == Player.class) { // checkpoint(); // } return; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "916": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity entityFrom = mapHashMap.get(from); Entity entityTo = mapHashMap.get(to); mapHashMap.remove(from,entityFrom); mapHashMap.remove(to,entityTo); mapHashMap.put(to, entityFrom); mapHashMap.put(from, new Empty()); // if (entityFrom.getClass() == Player.class) { // checkpoint(); // } return; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO Position temp = null; for (int i = 0; i < getMapMaxWidth(); i++) { for (int j = 0; j < getMapMaxHeight(); j++) { temp = Position.of(i,j); Entity tempEntity = mapHashMap.get(temp); if ((tempEntity != null) && (tempEntity.getClass() == Player.class)) { if (((Player) tempEntity).getId() == id) { return temp; } } } } return null; }",
        "label": "P"
    },
    "917": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity entityFrom = mapHashMap.get(from); Entity entityTo = mapHashMap.get(to); mapHashMap.remove(from,entityFrom); mapHashMap.remove(to,entityTo); mapHashMap.put(to, entityFrom); mapHashMap.put(from, new Empty()); // if (entityFrom.getClass() == Player.class) { // checkpoint(); // } return; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO Position temp = null; for (int i = 0; i < getMapMaxWidth(); i++) { for (int j = 0; j < getMapMaxHeight(); j++) { temp = Position.of(i,j); Entity tempEntity = mapHashMap.get(temp); if ((tempEntity != null) && (tempEntity.getClass() == Player.class)) { if (((Player) tempEntity).getId() == id) { return temp; } } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return mapHashMap.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "918": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO if (undoQuota >= 0) { return Optional.of(this.undoQuota); } else if (undoQuota == -1) { return Optional.empty(); } else { return null; } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "919": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> players = new HashSet<Position>(); for (int i = 0; i < getMapMaxWidth(); i++) { for (int j = 0; j < getMapMaxHeight(); j++) { Position tempPosition = Position.of(i,j); Entity tempEntity = mapHashMap.get(tempPosition); if ((tempEntity != null) && (tempEntity.getClass() == Player.class)) { players.add(tempPosition); } } } return players; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "920": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity entityFrom = mapHashMap.get(from); Entity entityTo = mapHashMap.get(to); mapHashMap.remove(from,entityFrom); mapHashMap.remove(to,entityTo); mapHashMap.put(to, entityFrom); mapHashMap.put(from, new Empty()); // if (entityFrom.getClass() == Player.class) { // checkpoint(); // } return; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO HashMap<Position, Entity> cloned = new HashMap<>(mapHashMap); checkpoints.put(numOfCheckpoints,cloned); //System.out.println(cloned); // checkpoint_2 = checkpoint; // checkpoint.clear(); // for (int i = 0; i < getMapMaxWidth(); i++) { // for (int j = 0; j < getMapMaxHeight(); j++) { // Position tempPosition = Position.of(i,j); // Entity tempEntity = mapHashMap.get(tempPosition); // checkpoint.put(tempPosition, tempEntity); // } // } numOfCheckpoints++; undoQuotacheckpoint = undoQuota; return; //throw new NotImplementedException(); } public void undo() { // TODO if (numOfCheckpoints == 1) { HashMap<Position, Entity> cloned = new HashMap<>(checkpoints.get(numOfCheckpoints-1)); this.mapHashMap = cloned; } if (numOfCheckpoints-2>=0) { if (!getUndoQuota().isEmpty()){ undoQuota--; } HashMap<Position, Entity> cloned = new HashMap<>(checkpoints.get(numOfCheckpoints-2)); numOfCheckpoints--; this.mapHashMap = cloned; } return; //throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO Position temp = null; for (int i = 0; i < getMapMaxWidth(); i++) { for (int j = 0; j < getMapMaxHeight(); j++) { temp = Position.of(i,j); Entity tempEntity = mapHashMap.get(temp); if ((tempEntity != null) && (tempEntity.getClass() == Player.class)) { if (((Player) tempEntity).getId() == id) { return temp; } } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return mapHashMap.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (undoQuota >= 0) { return Optional.of(this.undoQuota); } else if (undoQuota == -1) { return Optional.empty(); } else { return null; } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "921": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO this.gameState = gameState; if (gameState.getAllPlayerPositions().size()>2) { throw new IllegalArgumentException(); } // Check the number of players //throw new NotImplementedException(); } public void run() { // TODO renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(state); //int temp = state.getUndoQuota().get(); if (state.getUndoQuota().isEmpty()) { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, StringResources.UNDO_QUOTA_UNLIMITED)); } else { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get()).toString()); } while (!shouldStop()) { Action input = inputEngine.fetchAction(); ActionResult result = processAction(input); renderingEngine.render(state); if (result.getClass() == ActionResult.Failed.class) { renderingEngine.message(((ActionResult.Failed) result).getReason()); } if (state.getUndoQuota().isEmpty()) { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, StringResources.UNDO_QUOTA_UNLIMITED)); } else { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get()).toString() ); } renderingEngine.message(\">>>\"); // renderingEngine.render(state); // if (!(input == null)) { // ActionResult result = processAction(input); // if (result.getClass() == ActionResult.Success.class) { // renderingEngine.render(state); // } else { // renderingEngine.message(\"Invalid Input\"); // } // } } if (gameState.isWin()) { renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); renderingEngine.message(StringResources.WIN_MESSAGE); } else { renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); } return; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "922": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO this.gameState = gameState; if (gameState.getAllPlayerPositions().size()>2) { throw new IllegalArgumentException(); } // Check the number of players //throw new NotImplementedException(); }",
        "label": "P"
    },
    "923": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); return; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "924": {
        "dataset": "COMP 3021",
        "project": "rvtanuwijaya",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.mapHashMap = map.mapHashMap; this.undoQuota = map.undoLimit; this.crateLocations = map.crateLocations; checkpoint(); //getUndoQuota(); //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { final var builder = new StringBuilder(); for (int y = 0; y < state.getMapMaxHeight(); y++) { for (int x = 0; x < state.getMapMaxWidth(); x++) { final var entity = state.getEntity(Position.of(x, y)); var charToPrint = switch (entity) { // TODO case Wall ignored -> '#';//throw new NotImplementedException(); case Box b -> (char)(b.getPlayerId()+'a');//throw new NotImplementedException(); case Player p -> (char)(p.getId()+'A'); //throw new NotImplementedException(); case Empty ignored -> '.';//throw new NotImplementedException(); case null -> ' '; }; if (charToPrint == '.') { if (state.getDestinations().contains(Position.of(x,y))) { charToPrint = '@'; } } builder.append(charToPrint); } builder.append('\\n'); } outputSteam.print(builder); }",
        "label": "P"
    },
    "925": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { return Optional.of(undoLimit); }",
        "label": "P"
    },
    "926": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "927": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "928": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public Down(int initiator) { super(initiator); } public static void verify(String mapText) { // helper function Scanner scanner = new Scanner(mapText); int undoLimit = Integer.parseInt(scanner.nextLine()); if (undoLimit < 0 && undoLimit != -1) { throw new IllegalArgumentException(); } boolean playerCheck = false; for(int i = 65; i < 91; i++) { if (count(mapText, (char)i) > 1) { throw new IllegalArgumentException(); } if (count(mapText, (char)i) == 1) { playerCheck = true; } } if (!playerCheck) { throw new IllegalArgumentException(); } int destinationCount = count(mapText, '@'); int boxCount = 0; for(int i = 97; i < 123; ++i) { boxCount += count(mapText, (char)i); if (mapText.contains(Character.toString((char)i)) ^ mapText.contains(Character.toString((char)(i - 32)))) { throw new IllegalArgumentException(); } } if (destinationCount != boxCount) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "929": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public Down(int initiator) { super(initiator); } public static void verify(String mapText) { // helper function Scanner scanner = new Scanner(mapText); int undoLimit = Integer.parseInt(scanner.nextLine()); if (undoLimit < 0 && undoLimit != -1) { throw new IllegalArgumentException(); } boolean playerCheck = false; for(int i = 65; i < 91; i++) { if (count(mapText, (char)i) > 1) { throw new IllegalArgumentException(); } if (count(mapText, (char)i) == 1) { playerCheck = true; } } if (!playerCheck) { throw new IllegalArgumentException(); } int destinationCount = count(mapText, '@'); int boxCount = 0; for(int i = 97; i < 123; ++i) { boxCount += count(mapText, (char)i); if (mapText.contains(Character.toString((char)i)) ^ mapText.contains(Character.toString((char)(i - 32)))) { throw new IllegalArgumentException(); } } if (destinationCount != boxCount) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "930": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public Down(int initiator) { super(initiator); } public static void verify(String mapText) { // helper function Scanner scanner = new Scanner(mapText); int undoLimit = Integer.parseInt(scanner.nextLine()); if (undoLimit < 0 && undoLimit != -1) { throw new IllegalArgumentException(); } boolean playerCheck = false; for(int i = 65; i < 91; i++) { if (count(mapText, (char)i) > 1) { throw new IllegalArgumentException(); } if (count(mapText, (char)i) == 1) { playerCheck = true; } } if (!playerCheck) { throw new IllegalArgumentException(); } int destinationCount = count(mapText, '@'); int boxCount = 0; for(int i = 97; i < 123; ++i) { boxCount += count(mapText, (char)i); if (mapText.contains(Character.toString((char)i)) ^ mapText.contains(Character.toString((char)(i - 32)))) { throw new IllegalArgumentException(); } } if (destinationCount != boxCount) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "931": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "932": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "933": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "934": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "935": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "936": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "937": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "938": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "939": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // actual input var lowerCaseInput = inputLine.toLowerCase(); // input in lowercase to ignore cases Action result = switch(lowerCaseInput) { case \"w\": { yield new Move.Up(0); } case \"a\": { yield new Move.Left(0); } case \"s\": { yield new Move.Down(0); } case \"d\": { yield new Move.Right(0); } case \"h\": { yield new Move.Left(1); } case \"j\": { yield new Move.Down(1); } case \"k\": { yield new Move.Up(1); } case \"l\": { yield new Move.Right(1); } case \"exit\": { yield new Exit(0); } case \"u\": { yield new Undo(0); } default: { yield new InvalidInput(0, \"Invaild input\"); } }; return result; }",
        "label": "P"
    },
    "940": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public void move(Position from, Position to) { if (getEntity(from) instanceof Player) { playerPositions.add(to); this.map.putEntity(to, new Player(((Player) getEntity(from)).getId())); playerPositions.remove(from); this.map.putEntity(from, new Empty()); } if (getEntity(from) instanceof Box) { boxPositions.add(to); this.map.putEntity(to, new Box(((Box) getEntity(from)).getPlayerId())); boxPositions.remove(from); this.map.putEntity(from, new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "941": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public void move(Position from, Position to) { if (getEntity(from) instanceof Player) { playerPositions.add(to); this.map.putEntity(to, new Player(((Player) getEntity(from)).getId())); playerPositions.remove(from); this.map.putEntity(from, new Empty()); } if (getEntity(from) instanceof Box) { boxPositions.add(to); this.map.putEntity(to, new Box(((Box) getEntity(from)).getPlayerId())); boxPositions.remove(from); this.map.putEntity(from, new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (Position pos : playerPositions) { if (((Player)getEntity(pos)).getId() == id) return pos; } return null; }",
        "label": "P"
    },
    "942": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public void move(Position from, Position to) { if (getEntity(from) instanceof Player) { playerPositions.add(to); this.map.putEntity(to, new Player(((Player) getEntity(from)).getId())); playerPositions.remove(from); this.map.putEntity(from, new Empty()); } if (getEntity(from) instanceof Box) { boxPositions.add(to); this.map.putEntity(to, new Box(((Box) getEntity(from)).getPlayerId())); boxPositions.remove(from); this.map.putEntity(from, new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (Position pos : playerPositions) { if (((Player)getEntity(pos)).getId() == id) return pos; } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "943": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public Optional<Integer> getUndoQuota() { if (map.getUndoLimit() == Optional.of(-1)) return Optional.empty(); else return map.getUndoLimit(); }",
        "label": "P"
    },
    "944": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { return playerPositions; }",
        "label": "P"
    },
    "945": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public void move(Position from, Position to) { if (getEntity(from) instanceof Player) { playerPositions.add(to); this.map.putEntity(to, new Player(((Player) getEntity(from)).getId())); playerPositions.remove(from); this.map.putEntity(from, new Empty()); } if (getEntity(from) instanceof Box) { boxPositions.add(to); this.map.putEntity(to, new Box(((Box) getEntity(from)).getPlayerId())); boxPositions.remove(from); this.map.putEntity(from, new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { ArrayList<ArrayList<Entity>> newMap = null; newMap = new ArrayList<>(this.map.map.stream().map(x -> new ArrayList<>(x)).collect(Collectors.toList())); saveStates.add(newMap); // save_states is the list of all save states } public void undo() { if (saveStates.size() > 1) { saveStates.remove((saveStates.size() - 1)); // removes save state if (getUndoQuota().orElse(0) != -1) { this.map.undoLimit--; } } this.map.map = saveStates.get(saveStates.size() - 1); playerPositions.clear(); boxPositions.clear(); // resets all locations for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { for (Position pos : playerPositions) { if (((Player)getEntity(pos)).getId() == id) return pos; } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { if (map.getUndoLimit() == Optional.of(-1)) return Optional.empty(); else return map.getUndoLimit(); }",
        "label": "P"
    },
    "946": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; int playerCount = state.getAllPlayerPositions().size(); if (playerCount > 2) throw new IllegalArgumentException(); } public void run() { renderingEngine.message(\"Sokoban game is ready.\"); renderingEngine.render(state); if (state.getUndoQuota().orElse(0) >= 0) { renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().orElse(0)); } else { renderingEngine.message(\"Unlimited\"); } while (!super.shouldStop()) { Action action = inputEngine.fetchAction(); if (!(action instanceof InvalidInput)) { ActionResult result = super.processAction(action); if (result instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) result).getReason()); } } else { renderingEngine.message(((InvalidInput) action).getMessage()); } renderingEngine.render(state); if (state.getUndoQuota().orElse(0) >= 0) { renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().orElse(0)); } else { renderingEngine.message(\"Unlimited\"); } renderingEngine.message(\"\"); } renderingEngine.message(\"Game exits.\"); if (state.isWin()) { renderingEngine.message(\"You win.\"); } } public static void verify(String mapText) { // helper function Scanner scanner = new Scanner(mapText); int undoLimit = Integer.parseInt(scanner.nextLine()); if (undoLimit < 0 && undoLimit != -1) { throw new IllegalArgumentException(); } boolean playerCheck = false; for(int i = 65; i < 91; i++) { if (count(mapText, (char)i) > 1) { throw new IllegalArgumentException(); } if (count(mapText, (char)i) == 1) { playerCheck = true; } } if (!playerCheck) { throw new IllegalArgumentException(); } int destinationCount = count(mapText, '@'); int boxCount = 0; for(int i = 97; i < 123; ++i) { boxCount += count(mapText, (char)i); if (mapText.contains(Character.toString((char)i)) ^ mapText.contains(Character.toString((char)(i - 32)))) { throw new IllegalArgumentException(); } } if (destinationCount != boxCount) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "947": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; int playerCount = state.getAllPlayerPositions().size(); if (playerCount > 2) throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "948": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputStream = outputSteam; } public void message(@NotNull String content) { outputStream.print(content + \"\\r\\n\"); }",
        "label": "F"
    },
    "949": {
        "dataset": "COMP 3021",
        "project": "kcmaad",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); for (int y = 0; y < this.map.getMaxHeight(); y++) { for (int x = 0; x < this.map.map.get(y).size(); x++) { Position pos = new Position(x, y); if (getEntity(pos) instanceof Player) { playerPositions.add(pos); } if (getEntity(pos) instanceof Box) { boxPositions.add(pos); } } } checkpoint(); // creates a checkpoint of the original values } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputStream = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputStream = outputSteam; }",
        "label": "P"
    },
    "950": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // DONE return this.maxWidth; } public int getMaxHeight() { // DONE return this.maxHeight; } public Optional<Integer> getUndoLimit() { // DONE return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "951": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "952": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "953": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "954": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "955": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "956": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return this.currentMap[position.x()][position.y()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "957": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return this.currentMap[position.x()][position.y()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "958": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // DONE return this.maxHeight; }",
        "label": "P"
    },
    "959": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // DONE return this.maxWidth; }",
        "label": "P"
    },
    "960": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // DONE return this.originalGameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // DONE return this.currentMap[position.x()][position.y()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "961": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return this.currentMap[position.x()][position.y()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "962": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return this.currentMap[position.x()][position.y()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "963": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return this.currentMap[position.x()][position.y()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "964": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // DONE String instruction = inputLine.toUpperCase(); // EXIT: exit game if (instruction.equals(\"EXIT\")) { return new Exit(-1); } // ASWD: move Player with ID 0 to Left, Down, Up, Right if (instruction.equals(\"A\")) { return new Move.Left(0); } else if (instruction.equals(\"S\")) { return new Move.Down(0); } else if (instruction.equals(\"W\")) { return new Move.Up(0); } else if (instruction.equals(\"D\")) { return new Move.Right(0); } // HJKL: move Player with ID 1 to Left, Down, Up, Right if (instruction.equals(\"H\")) { return new Move.Left(1); } else if (instruction.equals(\"J\")) { return new Move.Down(1); } else if (instruction.equals(\"K\")) { return new Move.Up(1); } else if (instruction.equals(\"L\")) { return new Move.Right(1); } // U: undo to previous GameState if (instruction.equals(\"U\")) { return new Undo(-1); } return new InvalidInput(-1, \"Invalid Input.\"); }",
        "label": "P"
    },
    "965": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public void move(Position from, Position to) { // DONE // Perform swapping 2 Entities Positions Entity entityFrom = this.currentMap[from.x()][from.y()]; switch (entityFrom) { case Player player -> this.currentPlayersLocations.put(player.getId(), to); case Box box -> { this.currentCratesLocations.remove(from); this.currentCratesLocations.put(to, box.getPlayerId()); } case null, default -> {} } this.currentMap[from.x()][from.y()] = this.currentMap[to.x()][to.y()]; this.currentMap[to.x()][to.y()] = entityFrom; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "966": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public void move(Position from, Position to) { // DONE // Perform swapping 2 Entities Positions Entity entityFrom = this.currentMap[from.x()][from.y()]; switch (entityFrom) { case Player player -> this.currentPlayersLocations.put(player.getId(), to); case Box box -> { this.currentCratesLocations.remove(from); this.currentCratesLocations.put(to, box.getPlayerId()); } case null, default -> {} } this.currentMap[from.x()][from.y()] = this.currentMap[to.x()][to.y()]; this.currentMap[to.x()][to.y()] = entityFrom; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // DONE return this.currentPlayersLocations.get(id); }",
        "label": "P"
    },
    "967": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public void move(Position from, Position to) { // DONE // Perform swapping 2 Entities Positions Entity entityFrom = this.currentMap[from.x()][from.y()]; switch (entityFrom) { case Player player -> this.currentPlayersLocations.put(player.getId(), to); case Box box -> { this.currentCratesLocations.remove(from); this.currentCratesLocations.put(to, box.getPlayerId()); } case null, default -> {} } this.currentMap[from.x()][from.y()] = this.currentMap[to.x()][to.y()]; this.currentMap[to.x()][to.y()] = entityFrom; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // DONE return this.currentPlayersLocations.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // DONE return this.currentMap[position.x()][position.y()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "968": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public Optional<Integer> getUndoQuota() { // DONE if (this.undoQuotaLeft == -1) { return Optional.empty(); } else { return Optional.of(this.undoQuotaLeft); } }",
        "label": "P"
    },
    "969": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // DONE return new HashSet<>(this.currentPlayersLocations.values()); }",
        "label": "P"
    },
    "970": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public void move(Position from, Position to) { // DONE // Perform swapping 2 Entities Positions Entity entityFrom = this.currentMap[from.x()][from.y()]; switch (entityFrom) { case Player player -> this.currentPlayersLocations.put(player.getId(), to); case Box box -> { this.currentCratesLocations.remove(from); this.currentCratesLocations.put(to, box.getPlayerId()); } case null, default -> {} } this.currentMap[from.x()][from.y()] = this.currentMap[to.x()][to.y()]; this.currentMap[to.x()][to.y()] = entityFrom; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // DONE this.checkpoints.add(Checkpoint.of(this.currentPlayersLocations, this.currentCratesLocations)); } public void undo() { // DONE if (this.getUndoQuota().isPresent() && !this.checkpoints.isEmpty()) { this.undoQuotaLeft--; } this.mostRecentAction = null; if (!this.checkpoints.isEmpty()) { this.checkpoints.remove(this.checkpoints.size() - 1); } if (this.checkpoints.isEmpty()) { // Revert to initial game state this.currentMap = this.initializeMapFromOriginalGameMap(); } else { // Revert to previous checkpoint Checkpoint checkpoint = this.checkpoints.get(this.checkpoints.size() - 1); // Remove Players and Boxes from currentMap for (int playerId: checkpoint.playerLocations.keySet()) { // Remove Player from currentMap Position playerPosition = this.getPlayerPositionById(playerId); this.currentMap[playerPosition.x()][playerPosition.y()] = new Empty(); } for (Position cratePosition: this.currentCratesLocations.keySet()) { // Remove Box from currentMap this.currentMap[cratePosition.x()][cratePosition.y()] = new Empty(); } // Add Players and Boxes to currentMap by Checkpoint Positions for (int playerId: checkpoint.playerLocations.keySet()) { // Add Player to currentMap Position playerPosition = checkpoint.playerLocations.get(playerId); this.currentMap[playerPosition.x()][playerPosition.y()] = new Player(playerId); } for (Position cratePosition: checkpoint.cratesLocations.keySet()) { // Add Box to currentMap int playerId = checkpoint.cratesLocations.get(cratePosition); this.currentMap[cratePosition.x()][cratePosition.y()] = new Box(playerId); } } this.updateStatesFromCurrentMap(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // DONE return this.currentPlayersLocations.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // DONE return this.currentMap[position.x()][position.y()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // DONE if (this.undoQuotaLeft == -1) { return Optional.empty(); } else { return Optional.of(this.undoQuotaLeft); } }",
        "label": "P"
    },
    "971": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // DONE // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"There cannot be more than two players in the map!\"); } } public void run() { // DONE this.renderingEngine.message(\"Sokoban game is ready.\"); this.renderingEngine.render(this.state); // Game terminates when the game is won or the player performs Exit action // Deadlock checking is not required while (!this.shouldStop()) { // Game loop if (this.state.getUndoQuota().isPresent()) { this.renderingEngine.message(\"Undo Quota: %d\".formatted(this.state.getUndoQuota().get())); } else { this.renderingEngine.message(\"Unlimited\"); } this.renderingEngine.message(\">>>\"); switch (this.processAction(this.inputEngine.fetchAction())) { case ActionResult.Success success -> {} case ActionResult.Failed failed -> { this.renderingEngine.message(failed.getReason()); } } this.renderingEngine.render(this.state); } this.renderingEngine.message(\"Game exits.\"); if (this.state.isWin()) { this.renderingEngine.message(\"You win.\"); } }",
        "label": "P"
    },
    "972": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // DONE // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"There cannot be more than two players in the map!\"); } }",
        "label": "P"
    },
    "973": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // DONE // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "974": {
        "dataset": "COMP 3021",
        "project": "hwolee",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.originalGameMap = map; this.undoQuotaLeft = originalGameMap.getUndoLimit().isPresent() ? originalGameMap.getUndoLimit().get() : -1; this.checkpoints = new ArrayList<>(); this.currentMap = this.initializeMapFromOriginalGameMap(); this.updateStatesFromCurrentMap(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "975": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO return this.maxHeight; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "976": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "977": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "978": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "979": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "980": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "981": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entity : currentEntityLocations.entrySet()) { if (entity.getKey().x() == position.x() && entity.getKey().y() == position.y()) { return entity.getValue(); } } return null; // how? if there is a static class at GameMap storing all the entities position then its possible // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "982": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entity : currentEntityLocations.entrySet()) { if (entity.getKey().x() == position.x() && entity.getKey().y() == position.y()) { return entity.getValue(); } } return null; // how? if there is a static class at GameMap storing all the entities position then its possible // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "983": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "984": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "985": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return destinations; // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entity : currentEntityLocations.entrySet()) { if (entity.getKey().x() == position.x() && entity.getKey().y() == position.y()) { return entity.getValue(); } } return null; // how? if there is a static class at GameMap storing all the entities position then its possible // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "986": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entity : currentEntityLocations.entrySet()) { if (entity.getKey().x() == position.x() && entity.getKey().y() == position.y()) { return entity.getValue(); } } return null; // how? if there is a static class at GameMap storing all the entities position then its possible // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "987": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entity : currentEntityLocations.entrySet()) { if (entity.getKey().x() == position.x() && entity.getKey().y() == position.y()) { return entity.getValue(); } } return null; // how? if there is a static class at GameMap storing all the entities position then its possible // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "988": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entity : currentEntityLocations.entrySet()) { if (entity.getKey().x() == position.x() && entity.getKey().y() == position.y()) { return entity.getValue(); } } return null; // how? if there is a static class at GameMap storing all the entities position then its possible // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "989": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // System.out.println(\"fetched action\"); // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. // terminalScanner.next(); final var inputLine = terminalScanner.nextLine(); // TODO // Check how to check the initiator int initiator = 0; if (inputLine.equals(StringResources.EXIT_COMMAND_TEXT)) return new Exit(-1); if (inputLine.length() != 1) { return new InvalidInput(initiator, StringResources.INVALID_INPUT_MESSAGE); } String lowerInputLine = inputLine.toLowerCase(); Character inputChar = lowerInputLine.charAt(0); switch (inputChar) { case 'a': return new Move.Left(initiator); case 'w': return new Move.Up(initiator); case 's': return new Move.Down(initiator); case 'd': return new Move.Right(initiator); case 'h': return new Move.Left(1); case 'j': return new Move.Down(1); case 'k': return new Move.Up(1); case 'l': return new Move.Right(1); case 'u': return new Undo(-1); default: return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "990": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // System.out.println(currentEntityLocations); // System.out.println(currentPlayerLocation); // System.out.println(currentBoxesLocations); // TODO Entity entityAtFrom = getEntity(from); moveHistory.put(to, entityAtFrom); currentEntityLocations.replace(from, new Empty()); currentEntityLocations.replace(to, entityAtFrom); // check if this works properly // if (test == null) { // System.out.println(\"doesnt work\"); // throw new NotImplementedException(); // } // Works for currentEntityLocations, since getEntity returns the instance from currentEntityLocations if (entityAtFrom instanceof Box) { // var test2 = currentBoxesLocations.replace((Box) entityAtFrom, to); Boolean found = false; Box foundBox = new Box(0); Position foundBoxPosition = new Position(2,0); for (Map.Entry<Position, Box> entry : currentBoxesLocations.entrySet()) { // if (entry.getValue().equals(from)) { if (entry.getKey().y() == from.y() && entry.getKey().x() == from.x()) { // Found entity in the 'from' location found = true; foundBox = entry.getValue(); foundBoxPosition = entry.getKey(); break; // var testing = currentEntityLocations.replace(entityAtFrom, to); // if (testing == null) { // System.out.println(\"testing failed\"); // } else { // System.out.println(\"testing \" + testing); // } // System.out.println(\"moved \" + from + \" to \" + to); } } if (found) { currentBoxesLocations.put(to, foundBox); currentBoxesLocations.remove(foundBoxPosition); } // System.out.println(\"current boxes locations \" + currentBoxesLocations); // if (test2 != null) { // System.out.println(\"WORKS\"); // } else { // System.out.println(\"DOESNT WORK\"); // } } else if (entityAtFrom instanceof Player) { Boolean found = false; Player foundPlayer = new Player(0); Position foundPlayerPosition = new Position(1,0); // currentPlayerLocation.replace((Player) entityAtFrom, to); for (Map.Entry<Position, Player> entry : currentPlayerLocation.entrySet()) { if (entry.getKey().y() == from.y() && entry.getKey().x() == from.x()) { // Found entity in the 'from' location found = true; foundPlayer = entry.getValue(); foundPlayerPosition = entry.getKey(); break; // var testing = currentEntityLocations.replace(entityAtFrom, to); // if (testing == null) { // System.out.println(\"testing failed\"); // } else { // System.out.println(\"testing \" + testing + \". from : \" + from + \" beocmes \" + to); // } // System.out.println(\"player moved \" + from + \" to \" + to); } } if (found) { currentPlayerLocation.put(to, foundPlayer); currentPlayerLocation.remove(foundPlayerPosition); } } // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "991": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // System.out.println(currentEntityLocations); // System.out.println(currentPlayerLocation); // System.out.println(currentBoxesLocations); // TODO Entity entityAtFrom = getEntity(from); moveHistory.put(to, entityAtFrom); currentEntityLocations.replace(from, new Empty()); currentEntityLocations.replace(to, entityAtFrom); // check if this works properly // if (test == null) { // System.out.println(\"doesnt work\"); // throw new NotImplementedException(); // } // Works for currentEntityLocations, since getEntity returns the instance from currentEntityLocations if (entityAtFrom instanceof Box) { // var test2 = currentBoxesLocations.replace((Box) entityAtFrom, to); Boolean found = false; Box foundBox = new Box(0); Position foundBoxPosition = new Position(2,0); for (Map.Entry<Position, Box> entry : currentBoxesLocations.entrySet()) { // if (entry.getValue().equals(from)) { if (entry.getKey().y() == from.y() && entry.getKey().x() == from.x()) { // Found entity in the 'from' location found = true; foundBox = entry.getValue(); foundBoxPosition = entry.getKey(); break; // var testing = currentEntityLocations.replace(entityAtFrom, to); // if (testing == null) { // System.out.println(\"testing failed\"); // } else { // System.out.println(\"testing \" + testing); // } // System.out.println(\"moved \" + from + \" to \" + to); } } if (found) { currentBoxesLocations.put(to, foundBox); currentBoxesLocations.remove(foundBoxPosition); } // System.out.println(\"current boxes locations \" + currentBoxesLocations); // if (test2 != null) { // System.out.println(\"WORKS\"); // } else { // System.out.println(\"DOESNT WORK\"); // } } else if (entityAtFrom instanceof Player) { Boolean found = false; Player foundPlayer = new Player(0); Position foundPlayerPosition = new Position(1,0); // currentPlayerLocation.replace((Player) entityAtFrom, to); for (Map.Entry<Position, Player> entry : currentPlayerLocation.entrySet()) { if (entry.getKey().y() == from.y() && entry.getKey().x() == from.x()) { // Found entity in the 'from' location found = true; foundPlayer = entry.getValue(); foundPlayerPosition = entry.getKey(); break; // var testing = currentEntityLocations.replace(entityAtFrom, to); // if (testing == null) { // System.out.println(\"testing failed\"); // } else { // System.out.println(\"testing \" + testing + \". from : \" + from + \" beocmes \" + to); // } // System.out.println(\"player moved \" + from + \" to \" + to); } } if (found) { currentPlayerLocation.put(to, foundPlayer); currentPlayerLocation.remove(foundPlayerPosition); } } // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Player> player : currentPlayerLocation.entrySet()) { if (player.getValue().getId() == id) return player.getKey(); } return null; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "992": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // System.out.println(currentEntityLocations); // System.out.println(currentPlayerLocation); // System.out.println(currentBoxesLocations); // TODO Entity entityAtFrom = getEntity(from); moveHistory.put(to, entityAtFrom); currentEntityLocations.replace(from, new Empty()); currentEntityLocations.replace(to, entityAtFrom); // check if this works properly // if (test == null) { // System.out.println(\"doesnt work\"); // throw new NotImplementedException(); // } // Works for currentEntityLocations, since getEntity returns the instance from currentEntityLocations if (entityAtFrom instanceof Box) { // var test2 = currentBoxesLocations.replace((Box) entityAtFrom, to); Boolean found = false; Box foundBox = new Box(0); Position foundBoxPosition = new Position(2,0); for (Map.Entry<Position, Box> entry : currentBoxesLocations.entrySet()) { // if (entry.getValue().equals(from)) { if (entry.getKey().y() == from.y() && entry.getKey().x() == from.x()) { // Found entity in the 'from' location found = true; foundBox = entry.getValue(); foundBoxPosition = entry.getKey(); break; // var testing = currentEntityLocations.replace(entityAtFrom, to); // if (testing == null) { // System.out.println(\"testing failed\"); // } else { // System.out.println(\"testing \" + testing); // } // System.out.println(\"moved \" + from + \" to \" + to); } } if (found) { currentBoxesLocations.put(to, foundBox); currentBoxesLocations.remove(foundBoxPosition); } // System.out.println(\"current boxes locations \" + currentBoxesLocations); // if (test2 != null) { // System.out.println(\"WORKS\"); // } else { // System.out.println(\"DOESNT WORK\"); // } } else if (entityAtFrom instanceof Player) { Boolean found = false; Player foundPlayer = new Player(0); Position foundPlayerPosition = new Position(1,0); // currentPlayerLocation.replace((Player) entityAtFrom, to); for (Map.Entry<Position, Player> entry : currentPlayerLocation.entrySet()) { if (entry.getKey().y() == from.y() && entry.getKey().x() == from.x()) { // Found entity in the 'from' location found = true; foundPlayer = entry.getValue(); foundPlayerPosition = entry.getKey(); break; // var testing = currentEntityLocations.replace(entityAtFrom, to); // if (testing == null) { // System.out.println(\"testing failed\"); // } else { // System.out.println(\"testing \" + testing + \". from : \" + from + \" beocmes \" + to); // } // System.out.println(\"player moved \" + from + \" to \" + to); } } if (found) { currentPlayerLocation.put(to, foundPlayer); currentPlayerLocation.remove(foundPlayerPosition); } } // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Player> player : currentPlayerLocation.entrySet()) { if (player.getValue().getId() == id) return player.getKey(); } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entity : currentEntityLocations.entrySet()) { if (entity.getKey().x() == position.x() && entity.getKey().y() == position.y()) { return entity.getValue(); } } return null; // how? if there is a static class at GameMap storing all the entities position then its possible // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "993": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO if (undoLimitLeft == -1) return Optional.empty(); return Optional.of(undoLimitLeft); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "994": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO return new HashSet<Position>(currentPlayerLocation.keySet()); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "995": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public void move(Position from, Position to) { // System.out.println(currentEntityLocations); // System.out.println(currentPlayerLocation); // System.out.println(currentBoxesLocations); // TODO Entity entityAtFrom = getEntity(from); moveHistory.put(to, entityAtFrom); currentEntityLocations.replace(from, new Empty()); currentEntityLocations.replace(to, entityAtFrom); // check if this works properly // if (test == null) { // System.out.println(\"doesnt work\"); // throw new NotImplementedException(); // } // Works for currentEntityLocations, since getEntity returns the instance from currentEntityLocations if (entityAtFrom instanceof Box) { // var test2 = currentBoxesLocations.replace((Box) entityAtFrom, to); Boolean found = false; Box foundBox = new Box(0); Position foundBoxPosition = new Position(2,0); for (Map.Entry<Position, Box> entry : currentBoxesLocations.entrySet()) { // if (entry.getValue().equals(from)) { if (entry.getKey().y() == from.y() && entry.getKey().x() == from.x()) { // Found entity in the 'from' location found = true; foundBox = entry.getValue(); foundBoxPosition = entry.getKey(); break; // var testing = currentEntityLocations.replace(entityAtFrom, to); // if (testing == null) { // System.out.println(\"testing failed\"); // } else { // System.out.println(\"testing \" + testing); // } // System.out.println(\"moved \" + from + \" to \" + to); } } if (found) { currentBoxesLocations.put(to, foundBox); currentBoxesLocations.remove(foundBoxPosition); } // System.out.println(\"current boxes locations \" + currentBoxesLocations); // if (test2 != null) { // System.out.println(\"WORKS\"); // } else { // System.out.println(\"DOESNT WORK\"); // } } else if (entityAtFrom instanceof Player) { Boolean found = false; Player foundPlayer = new Player(0); Position foundPlayerPosition = new Position(1,0); // currentPlayerLocation.replace((Player) entityAtFrom, to); for (Map.Entry<Position, Player> entry : currentPlayerLocation.entrySet()) { if (entry.getKey().y() == from.y() && entry.getKey().x() == from.x()) { // Found entity in the 'from' location found = true; foundPlayer = entry.getValue(); foundPlayerPosition = entry.getKey(); break; // var testing = currentEntityLocations.replace(entityAtFrom, to); // if (testing == null) { // System.out.println(\"testing failed\"); // } else { // System.out.println(\"testing \" + testing + \". from : \" + from + \" beocmes \" + to); // } // System.out.println(\"player moved \" + from + \" to \" + to); } } if (found) { currentPlayerLocation.put(to, foundPlayer); currentPlayerLocation.remove(foundPlayerPosition); } } // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO // System.out.println(\"checkpoint: checkpointPlayerLocations before = \" + checkpointPlayerLocations); checkpointPlayerLocations.add(new HashMap<Position,Player>(currentPlayerLocation)); // System.out.println(\"checkpoint currentplayerLocation = \" + currentPlayerLocation); // System.out.println(\"checkpoint: checkpointPlayerLocations = \" + checkpointPlayerLocations); checkpointBoxesLocations.add(new HashMap<>(currentBoxesLocations)); checkpointEntityLocations.add(new HashMap<>(currentEntityLocations)); checkpointToGo += 1; // throw new NotImplementedException(); } public void undo() { // TODO // System.out.println(\"undo called\"); if (checkpointToGo == -1) { // no checkpoints stored. Do nothing. // Return to first (initial) checkpoint currentPlayerLocation = new HashMap<>(checkpointPlayerLocations.get(0)); currentBoxesLocations = new HashMap<>(checkpointBoxesLocations.get(0)); currentEntityLocations = new HashMap<>(checkpointEntityLocations.get(0)); return; } undoLimitLeft -= 1; currentPlayerLocation = new HashMap<>(checkpointPlayerLocations.get(checkpointToGo)); currentBoxesLocations = new HashMap<>(checkpointBoxesLocations.get(checkpointToGo)); currentEntityLocations = new HashMap<>(checkpointEntityLocations.get(checkpointToGo)); checkpointPlayerLocations.remove(checkpointToGo+1); checkpointBoxesLocations.remove(checkpointToGo+1); checkpointEntityLocations.remove(checkpointToGo+1); checkpointToGo -= 1; // System.out.println(\"currentplayer location in undo \" + currentPlayerLocation); // throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Player> player : currentPlayerLocation.entrySet()) { if (player.getValue().getId() == id) return player.getKey(); } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO for (Map.Entry<Position, Entity> entity : currentEntityLocations.entrySet()) { if (entity.getKey().x() == position.x() && entity.getKey().y() == position.y()) { return entity.getValue(); } } return null; // how? if there is a static class at GameMap storing all the entities position then its possible // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (undoLimitLeft == -1) return Optional.empty(); return Optional.of(undoLimitLeft); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "996": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (this.state.getNumberOfPlayers() > 2) { throw new IllegalArgumentException(); } // throw new NotImplementedException(); } public void run() { // TODO renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(state); if (!state.getUndoQuota().isPresent()) { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, StringResources.UNDO_QUOTA_UNLIMITED)); } else { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get())); } while (!this.shouldStop()) { Action userAction = inputEngine.fetchAction(); ActionResult userActionResult = this.processAction(userAction); if (userActionResult instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) userActionResult).getReason()); } renderingEngine.render(state); if (userAction instanceof Exit) { renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); return; } if (!state.getUndoQuota().isPresent()) { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, StringResources.UNDO_QUOTA_UNLIMITED)); } else { renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get())); } renderingEngine.message(\">>>\"); } if (this.shouldStop()) { // Player won the game renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); renderingEngine.message(StringResources.WIN_MESSAGE); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "997": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (this.state.getNumberOfPlayers() > 2) { throw new IllegalArgumentException(); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "998": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "999": {
        "dataset": "COMP 3021",
        "project": "hwlim",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.currentBoxesLocations = map.getInitialBoxesLocations(); this.currentPlayerLocation = map.getInitialPlayerLocations(); this.undoLimitLeft = map.getUndoLimit().get(); this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.currentEntityLocations = map.getInitialEntityLocations(); this.checkpointBoxesLocations.add(new HashMap<>(map.getInitialBoxesLocations())); this.checkpointPlayerLocations.add(new HashMap<>(map.getInitialPlayerLocations())); this.checkpointEntityLocations.add(new HashMap<>(map.getInitialEntityLocations())); // System.out.println(\"checkpoint before: checkpointPlayerLocations = \" + checkpointPlayerLocations); // this.checkpointToGo; // Starts at -1 this.numberOfPlayers = map.getNumberOfPlayers(); //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1000": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO return maxHeight; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undoLimit); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1001": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1002": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1003": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1004": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1005": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1006": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1007": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1008": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1009": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1010": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return stateMap.getDestinations(); // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1011": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1012": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1013": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1014": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. // TODO final var inputLine = terminalScanner.nextLine(); if (inputLine.equalsIgnoreCase(\"EXIT\")) { return new Exit(0); } else if (inputLine.equalsIgnoreCase(\"A\")) { return new Move.Left(0); } else if (inputLine.equalsIgnoreCase(\"S\")) { return new Move.Down(0); } else if (inputLine.equalsIgnoreCase(\"W\")) { return new Move.Up(0); } else if (inputLine.equalsIgnoreCase(\"D\")) { return new Move.Right(0); } else if (inputLine.equalsIgnoreCase(\"H\")) { return new Move.Left(1); } else if (inputLine.equalsIgnoreCase(\"J\")) { return new Move.Down(1); } else if (inputLine.equalsIgnoreCase(\"K\")) { return new Move.Right(1); } else if (inputLine.equalsIgnoreCase(\"L\")) { return new Move.Up(1); } else if (inputLine.equalsIgnoreCase(\"U\")) { // undo return new Undo(0); } return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1015": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // if (getEntity(from) instanceof Box || getEntity(to) instanceof Box) { // moveHistory.push(from); // moveHistory.push(to); // if (to.x()-from.x()==1) { // moveHistory.push(Position.of(from.x()-1, from.y())); // moveHistory.push(Position.of(to.x()-1, to.y())); // } else if (to.x()-from.x()==-1) { // moveHistory.push(Position.of(from.x()+1, from.y())); // moveHistory.push(Position.of(to.x()+1, to.y())); // } else if (to.y()-from.y()==1) { // moveHistory.push(Position.of(from.x(), from.y()-1)); // moveHistory.push(Position.of(to.x(), to.y()-1)); // } else if (to.y()-from.y()==-1) { // moveHistory.push(Position.of(from.x(), from.y()+1)); // moveHistory.push(Position.of(to.x(), to.y()+1)); // } // } stateMap.putEntity(to, getEntity(from)); stateMap.putEntity(from, new Empty()); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1016": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // if (getEntity(from) instanceof Box || getEntity(to) instanceof Box) { // moveHistory.push(from); // moveHistory.push(to); // if (to.x()-from.x()==1) { // moveHistory.push(Position.of(from.x()-1, from.y())); // moveHistory.push(Position.of(to.x()-1, to.y())); // } else if (to.x()-from.x()==-1) { // moveHistory.push(Position.of(from.x()+1, from.y())); // moveHistory.push(Position.of(to.x()+1, to.y())); // } else if (to.y()-from.y()==1) { // moveHistory.push(Position.of(from.x(), from.y()-1)); // moveHistory.push(Position.of(to.x(), to.y()-1)); // } else if (to.y()-from.y()==-1) { // moveHistory.push(Position.of(from.x(), from.y()+1)); // moveHistory.push(Position.of(to.x(), to.y()+1)); // } // } stateMap.putEntity(to, getEntity(from)); stateMap.putEntity(from, new Empty()); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO // return stateMap.initialPlayerMap.get(id); // throw new NotImplementedException(); for (int i=0; i<stateMap.entityMap.size(); i++) { for (int j=0; j<stateMap.entityMap.get(i).size(); j++) { if (stateMap.entityMap.get(i).get(j) instanceof Player && ((Player) stateMap.entityMap.get(i).get(j)).getId()==id) { // System.out.println(\"hello\"); return Position.of(j, i); } } } return null; }",
        "label": "P"
    },
    "1017": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // if (getEntity(from) instanceof Box || getEntity(to) instanceof Box) { // moveHistory.push(from); // moveHistory.push(to); // if (to.x()-from.x()==1) { // moveHistory.push(Position.of(from.x()-1, from.y())); // moveHistory.push(Position.of(to.x()-1, to.y())); // } else if (to.x()-from.x()==-1) { // moveHistory.push(Position.of(from.x()+1, from.y())); // moveHistory.push(Position.of(to.x()+1, to.y())); // } else if (to.y()-from.y()==1) { // moveHistory.push(Position.of(from.x(), from.y()-1)); // moveHistory.push(Position.of(to.x(), to.y()-1)); // } else if (to.y()-from.y()==-1) { // moveHistory.push(Position.of(from.x(), from.y()+1)); // moveHistory.push(Position.of(to.x(), to.y()+1)); // } // } stateMap.putEntity(to, getEntity(from)); stateMap.putEntity(from, new Empty()); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO // return stateMap.initialPlayerMap.get(id); // throw new NotImplementedException(); for (int i=0; i<stateMap.entityMap.size(); i++) { for (int j=0; j<stateMap.entityMap.get(i).size(); j++) { if (stateMap.entityMap.get(i).get(j) instanceof Player && ((Player) stateMap.entityMap.get(i).get(j)).getId()==id) { // System.out.println(\"hello\"); return Position.of(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1018": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO if (stateMap.getUndoLimit().get() == -1) return Optional.empty(); return stateMap.getUndoLimit(); // undo\uac00 unlimited\uac00 \ub420 \uc218 \uc788\uc74c?? // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1019": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> playerPositions = new HashSet<Position>(); Set<Integer> temp = stateMap.getPlayerIds(); for (Integer x : temp) { playerPositions.add(getPlayerPositionById(x)); } return playerPositions; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1020": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO // if (getEntity(from) instanceof Box || getEntity(to) instanceof Box) { // moveHistory.push(from); // moveHistory.push(to); // if (to.x()-from.x()==1) { // moveHistory.push(Position.of(from.x()-1, from.y())); // moveHistory.push(Position.of(to.x()-1, to.y())); // } else if (to.x()-from.x()==-1) { // moveHistory.push(Position.of(from.x()+1, from.y())); // moveHistory.push(Position.of(to.x()+1, to.y())); // } else if (to.y()-from.y()==1) { // moveHistory.push(Position.of(from.x(), from.y()-1)); // moveHistory.push(Position.of(to.x(), to.y()-1)); // } else if (to.y()-from.y()==-1) { // moveHistory.push(Position.of(from.x(), from.y()+1)); // moveHistory.push(Position.of(to.x(), to.y()+1)); // } // } stateMap.putEntity(to, getEntity(from)); stateMap.putEntity(from, new Empty()); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO mapCheckPoint = new GameState(stateMap); // mapCheckPointList.add(mapCheckPoint); // cp1 (previous // int size = moveHistory.size()/2; // for (int i=0; i<size; i++) { // mapCheckPoint.move(moveHistory.pop(), moveHistory.pop()); // } // mapCheckPointList.add(new GameState(stateMap)); // cp2 (current) // throw new NotImplementedException(); } public void undo() { // TODO // \uc870\uae08 \ub354 \ud6a8\uc728\uc801\uc778 \ubc29\ubc95\uc774 \uc788\uc744\uae4c? if (!(mapCheckPoint == null)) { stateMap = mapCheckPoint.stateMap; mapCheckPoint.stateMap.undoLimit--; } // throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO // return stateMap.initialPlayerMap.get(id); // throw new NotImplementedException(); for (int i=0; i<stateMap.entityMap.size(); i++) { for (int j=0; j<stateMap.entityMap.get(i).size(); j++) { if (stateMap.entityMap.get(i).get(j) instanceof Player && ((Player) stateMap.entityMap.get(i).get(j)).getId()==id) { // System.out.println(\"hello\"); return Position.of(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (stateMap.getUndoLimit().get() == -1) return Optional.empty(); return stateMap.getUndoLimit(); // undo\uac00 unlimited\uac00 \ub420 \uc218 \uc788\uc74c?? // throw new NotImplementedException(); }",
        "label": "F"
    },
    "1021": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } // throw new NotImplementedException(); } public void run() { // TODO System.out.println(StringResources.GAME_READY_MESSAGE); // renderingEngine.render(state); // if (state.getUndoQuota().isPresent()) { // int undoLimit = state.getUndoQuota().get(); // System.out.printf(StringResources.UNDO_QUOTA_TEMPLATE, // (undoLimit == -1) ? StringResources.UNDO_QUOTA_UNLIMITED : Integer.toString(undoLimit)); // System.out.println(); // } // System.out.println(\">>>\"); while (!super.shouldStop()) { // and !exit renderingEngine.render(state); if (state.getUndoQuota().isPresent()) { int undoLimit = state.getUndoQuota().get(); System.out.printf(StringResources.UNDO_QUOTA_TEMPLATE, (undoLimit == -1) ? StringResources.UNDO_QUOTA_UNLIMITED : Integer.toString(undoLimit)); System.out.println(); System.out.println(\">>>\"); } ActionResult actionResult = processAction(inputEngine.fetchAction()); if (actionResult instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) actionResult).getReason()); } } renderingEngine.render(state); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1022": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1023": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. // outputSteam.print(content); String temp = content + System.lineSeparator(); outputSteam.print(temp); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1024": {
        "dataset": "COMP 3021",
        "project": "jsung",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.stateMap = new GameMap(map.getMaxWidth(), map.getMaxHeight(), map.getDestinations(), map.undoLimit); this.stateMap = map; // throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1025": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; } public int getMaxHeight() { // TODO return maxHeight; } public Optional<Integer> getUndoLimit() { // TODO if(undoLimit == -1) return Optional.empty(); return Optional.of(undoLimit); }",
        "label": "P"
    },
    "1026": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1027": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1028": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1029": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1030": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1031": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1032": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1033": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; }",
        "label": "P"
    },
    "1034": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; }",
        "label": "P"
    },
    "1035": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1036": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1037": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1038": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1039": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO Action res = switch (inputLine.toLowerCase()) { case \"a\" -> new Move.Left(0); case \"s\" -> new Move.Down(0); case \"w\" -> new Move.Up(0); case \"d\" -> new Move.Right(0); case \"h\" -> new Move.Left(1); case \"j\" -> new Move.Down(1); case \"k\" -> new Move.Up(1); case \"l\" -> new Move.Right(1); case \"u\" -> new Undo(0); case EXIT_COMMAND_TEXT -> new Exit(0); default -> new InvalidInput(0, INVALID_INPUT_MESSAGE); }; return res; }",
        "label": "P"
    },
    "1040": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public void move(Position from, Position to) { // TODO Entity tmp = getEntity(from); curMap[from.y()][from.x()] = curMap[to.y()][to.x()]; curMap[to.y()][to.x()] = tmp; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1041": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public void move(Position from, Position to) { // TODO Entity tmp = getEntity(from); curMap[from.y()][from.x()] = curMap[to.y()][to.x()]; curMap[to.y()][to.x()] = tmp; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if(!playerId.contains(id)) return null; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { if(curMap[y][x] instanceof Player && ((Player) curMap[y][x]).getId() == id) { return Position.of(x, y); } } } return null; }",
        "label": "P"
    },
    "1042": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public void move(Position from, Position to) { // TODO Entity tmp = getEntity(from); curMap[from.y()][from.x()] = curMap[to.y()][to.x()]; curMap[to.y()][to.x()] = tmp; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if(!playerId.contains(id)) return null; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { if(curMap[y][x] instanceof Player && ((Player) curMap[y][x]).getId() == id) { return Position.of(x, y); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1043": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public Optional<Integer> getUndoQuota() { // TODO if(infQuota) { return Optional.empty(); } else return Optional.of(undoQuota); }",
        "label": "P"
    },
    "1044": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set res = new HashSet<Position>(); for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { if(curMap[y][x] instanceof Player) { res.add(Position.of(x, y)); } } } return res; }",
        "label": "P"
    },
    "1045": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public void move(Position from, Position to) { // TODO Entity tmp = getEntity(from); curMap[from.y()][from.x()] = curMap[to.y()][to.x()]; curMap[to.y()][to.x()] = tmp; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO var ck = new Entity[maxHeight][maxWidth]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { ck[y][x] = switch (curMap[y][x]) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt.add(ck); } public void undo() { // TODO curMap = new Entity[maxHeight][maxWidth]; int id; if(ckpt.size() == 1) id = 0; else { undoQuota--; id = ckpt.size() - 2; ckpt.remove(ckpt.size() - 1); } for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { curMap[y][x] = switch (ckpt.get(id)[y][x]) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO if(!playerId.contains(id)) return null; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { if(curMap[y][x] instanceof Player && ((Player) curMap[y][x]).getId() == id) { return Position.of(x, y); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return curMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if(infQuota) { return Optional.empty(); } else return Optional.of(undoQuota); }",
        "label": "P"
    },
    "1046": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players var t = state.getAllPlayerPositions(); if(t.size() > 2) throw new IllegalArgumentException(); } public void run() { // TODO renderingEngine.message(GAME_READY_MESSAGE); renderingEngine.render(state); while (!shouldStop()) { if(state.getUndoQuota().isPresent()) renderingEngine.message(String.format(UNDO_QUOTA_TEMPLATE,String.valueOf(state.getUndoQuota().get()))); else renderingEngine.message(UNDO_QUOTA_UNLIMITED); renderingEngine.message(\">>>\"); var action = inputEngine.fetchAction(); var result = processAction(action); if(result instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) result).getReason()); } renderingEngine.render(state); } renderingEngine.message(GAME_EXIT_MESSAGE); if(state.isWin()) renderingEngine.message(WIN_MESSAGE); }",
        "label": "P"
    },
    "1047": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players var t = state.getAllPlayerPositions(); if(t.size() > 2) throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "1048": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1049": {
        "dataset": "COMP 3021",
        "project": "jhecf",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO playerId = map.getPlayerIds(); destinations = map.getDestinations(); maxHeight = map.getMaxHeight(); maxWidth = map.getMaxWidth(); var init = new Entity[map.getMaxHeight()][map.getMaxWidth()]; curMap = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for(int y = 0; y < maxHeight; ++y) { for(int x = 0; x < maxWidth; ++x) { init[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; curMap[y][x] = switch (map.getEntity(Position.of(x, y))) { case Wall ignored -> new Wall(); case Box b -> new Box(b.getPlayerId()); case Player p -> new Player(p.getId()); case Empty ignored -> new Empty(); case null -> null; }; } } ckpt = new ArrayList<Entity[][]>(); ckpt.add(init); if(!map.getUndoLimit().isPresent()) { infQuota = true; } else { undoQuota = map.getUndoLimit().get(); } } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { var des = state.getDestinations(); final var builder = new StringBuilder(); for (int y = 0; y < state.getMapMaxHeight(); y++) { for (int x = 0; x < state.getMapMaxWidth(); x++) { final var entity = state.getEntity(Position.of(x, y)); boolean flagDes = false; if(des.contains(Position.of(x, y))) { flagDes = true; } var charToPrint = switch (entity) { //changed final // TODO case Wall ignored -> '#'; case Box b -> (char) (b.getPlayerId() + 'a'); case Player p -> (char) (p.getId() + 'A'); case Empty ignored -> '.'; case null -> ' '; }; if(flagDes && charToPrint == '.') charToPrint = '@'; builder.append(charToPrint); } builder.append('\\n'); } outputSteam.print(builder); }",
        "label": "P"
    },
    "1050": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "1051": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1052": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1053": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1054": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1055": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1056": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return positionEntityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1057": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return positionEntityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1058": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "1059": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "1060": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return positionEntityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1061": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return positionEntityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1062": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return positionEntityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1063": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return positionEntityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1064": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO switch(inputLine.toUpperCase()){ case \"A\" :{ return new Move.Left(0); } case \"S\":{ return new Move.Down(0); } case \"W\":{ return new Move.Up(0); } case \"D\":{ return new Move.Right(0); } case \"H\":{ return new Move.Left(1); } case \"J\":{ return new Move.Down(1); } case \"K\":{ return new Move.Up(1); } case \"L\":{ return new Move.Right(1); } case \"U\":{ return new Undo(-1); } case \"EXIT\":{ return new Exit(-1); } default:{ return new InvalidInput(-1, \"Invalid Input!\"); } } }",
        "label": "P"
    },
    "1065": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public void move(Position from, Position to) { // TODO Entity fromEntity = getEntity(from); if(fromEntity instanceof Player){ this.positionEntityMap.put(to, fromEntity); this.positionEntityMap.put(from, new Empty()); allPlayerPositions.remove(from); allPlayerPositions.add(to); playerPositionsById.put(((Player) fromEntity).getId(), to); } else if(fromEntity instanceof Box){ boxLocations.remove(from); boxLocations.add(to); this.positionEntityMap.put(to, fromEntity); this.positionEntityMap.put(from, new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1066": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public void move(Position from, Position to) { // TODO Entity fromEntity = getEntity(from); if(fromEntity instanceof Player){ this.positionEntityMap.put(to, fromEntity); this.positionEntityMap.put(from, new Empty()); allPlayerPositions.remove(from); allPlayerPositions.add(to); playerPositionsById.put(((Player) fromEntity).getId(), to); } else if(fromEntity instanceof Box){ boxLocations.remove(from); boxLocations.add(to); this.positionEntityMap.put(to, fromEntity); this.positionEntityMap.put(from, new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.playerPositionsById.get(id); }",
        "label": "P"
    },
    "1067": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public void move(Position from, Position to) { // TODO Entity fromEntity = getEntity(from); if(fromEntity instanceof Player){ this.positionEntityMap.put(to, fromEntity); this.positionEntityMap.put(from, new Empty()); allPlayerPositions.remove(from); allPlayerPositions.add(to); playerPositionsById.put(((Player) fromEntity).getId(), to); } else if(fromEntity instanceof Box){ boxLocations.remove(from); boxLocations.add(to); this.positionEntityMap.put(to, fromEntity); this.positionEntityMap.put(from, new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.playerPositionsById.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return positionEntityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1068": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public Optional<Integer> getUndoQuota() { // TODO if(undoQuota == -1) return Optional.empty(); else{ return Optional.of(this.undoQuota); } }",
        "label": "P"
    },
    "1069": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO return this.allPlayerPositions; }",
        "label": "P"
    },
    "1070": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public void move(Position from, Position to) { // TODO Entity fromEntity = getEntity(from); if(fromEntity instanceof Player){ this.positionEntityMap.put(to, fromEntity); this.positionEntityMap.put(from, new Empty()); allPlayerPositions.remove(from); allPlayerPositions.add(to); playerPositionsById.put(((Player) fromEntity).getId(), to); } else if(fromEntity instanceof Box){ boxLocations.remove(from); boxLocations.add(to); this.positionEntityMap.put(to, fromEntity); this.positionEntityMap.put(from, new Empty()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO this.checkPoint.add(this); } public void undo() { // TODO if(this.checkPoint.size() > 0 ) { GameState previousState = this.checkPoint.get(this.checkPoint.size() - 1); if(this.positionEntityMap != previousState.positionEntityMap) { this.positionEntityMap = previousState.positionEntityMap; this.checkPoint = previousState.checkPoint; this.boxLocations = previousState.boxLocations; this.allPlayerPositions = previousState.allPlayerPositions; this.playerPositionsById = previousState.playerPositionsById; } else{ GameState initialState = new GameState(this.map); this.positionEntityMap = initialState.positionEntityMap; this.boxLocations = initialState.boxLocations; this.allPlayerPositions = initialState.allPlayerPositions; this.playerPositionsById = initialState.playerPositionsById; } this.undoQuota -= 1; } else{ GameState initialState = new GameState(this.map); this.positionEntityMap = initialState.positionEntityMap; this.boxLocations = initialState.boxLocations; this.allPlayerPositions = initialState.allPlayerPositions; this.playerPositionsById = initialState.playerPositionsById; } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO return this.playerPositionsById.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return positionEntityMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if(undoQuota == -1) return Optional.empty(); else{ return Optional.of(this.undoQuota); } }",
        "label": "P"
    },
    "1071": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2) throw new NotImplementedException(); else { this.renderingEngine.render(gameState); this.renderingEngine.message(\"Undo Quota: \" + gameState.getUndoQuota()); } } public void run() { // TODO this.processAction(this.inputEngine.fetchAction()); this.renderingEngine.render(state); if(!this.shouldStop()) { this.renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota()); this.run(); } }",
        "label": "P"
    },
    "1072": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2) throw new NotImplementedException(); else { this.renderingEngine.render(gameState); this.renderingEngine.message(\"Undo Quota: \" + gameState.getUndoQuota()); } }",
        "label": "P"
    },
    "1073": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1074": {
        "dataset": "COMP 3021",
        "project": "chngbk",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.positionEntityMap.putAll(map.getPositionEntityMap()); for(Map.Entry<Position, Entity> entry : positionEntityMap.entrySet()){ if(entry.getValue() instanceof Player){ Player temp = (Player) entry.getValue(); playerPositionsById.put(temp.getId(), entry.getKey()); allPlayerPositions.add(entry.getKey()); } else if (entry.getValue() instanceof Box) { boxLocations.add(entry.getKey()); } } this.destinations = map.getDestinations(); this.maxMapWidth = map.getMaxWidth(); this.maxMapHeight = map.getMaxHeight(); this.undoQuota = map.getUndoLimit().get(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1075": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.Width; } public int getMaxHeight() { // TODO return this.Height; } public Optional<Integer> getUndoLimit() { // TODO if(undolimit==-1){ return Optional.empty(); } return Optional.ofNullable(undolimit); }",
        "label": "P"
    },
    "1076": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1077": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1078": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1079": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1080": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1081": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(this.getMapMaxHeight()<= position.y()||this.map[position.y()+1].length()<=position.x()){ return null; } var entity = this.map[position.y()+1].charAt(position.x()); if(entity == '#'){ return new Wall(); } else if (Character.isUpperCase(entity)) { return new Player((int)entity-'A'); } else if (Character.isLowerCase(entity)) { return new Box((int)entity-'a'); } else if(entity == '.' || entity=='@'){ return new Empty(); } else { return null; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1082": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(this.getMapMaxHeight()<= position.y()||this.map[position.y()+1].length()<=position.x()){ return null; } var entity = this.map[position.y()+1].charAt(position.x()); if(entity == '#'){ return new Wall(); } else if (Character.isUpperCase(entity)) { return new Player((int)entity-'A'); } else if (Character.isLowerCase(entity)) { return new Box((int)entity-'a'); } else if(entity == '.' || entity=='@'){ return new Empty(); } else { return null; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1083": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.Height; }",
        "label": "P"
    },
    "1084": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.Width; }",
        "label": "P"
    },
    "1085": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(this.getMapMaxHeight()<= position.y()||this.map[position.y()+1].length()<=position.x()){ return null; } var entity = this.map[position.y()+1].charAt(position.x()); if(entity == '#'){ return new Wall(); } else if (Character.isUpperCase(entity)) { return new Player((int)entity-'A'); } else if (Character.isLowerCase(entity)) { return new Box((int)entity-'a'); } else if(entity == '.' || entity=='@'){ return new Empty(); } else { return null; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1086": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(this.getMapMaxHeight()<= position.y()||this.map[position.y()+1].length()<=position.x()){ return null; } var entity = this.map[position.y()+1].charAt(position.x()); if(entity == '#'){ return new Wall(); } else if (Character.isUpperCase(entity)) { return new Player((int)entity-'A'); } else if (Character.isLowerCase(entity)) { return new Box((int)entity-'a'); } else if(entity == '.' || entity=='@'){ return new Empty(); } else { return null; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1087": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(this.getMapMaxHeight()<= position.y()||this.map[position.y()+1].length()<=position.x()){ return null; } var entity = this.map[position.y()+1].charAt(position.x()); if(entity == '#'){ return new Wall(); } else if (Character.isUpperCase(entity)) { return new Player((int)entity-'A'); } else if (Character.isLowerCase(entity)) { return new Box((int)entity-'a'); } else if(entity == '.' || entity=='@'){ return new Empty(); } else { return null; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1088": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(this.getMapMaxHeight()<= position.y()||this.map[position.y()+1].length()<=position.x()){ return null; } var entity = this.map[position.y()+1].charAt(position.x()); if(entity == '#'){ return new Wall(); } else if (Character.isUpperCase(entity)) { return new Player((int)entity-'A'); } else if (Character.isLowerCase(entity)) { return new Box((int)entity-'a'); } else if(entity == '.' || entity=='@'){ return new Empty(); } else { return null; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1089": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO if(inputLine.equalsIgnoreCase(\"W\")){ return new Move.Up(0); } else if (inputLine.equalsIgnoreCase(\"A\")) { return new Move.Left(0); } else if (inputLine.equalsIgnoreCase(\"S\")) { return new Move.Down(0); } else if (inputLine.equalsIgnoreCase(\"D\")) { return new Move.Right(0); } else if (inputLine.equalsIgnoreCase(\"H\")) { return new Move.Left(1); } else if (inputLine.equalsIgnoreCase(\"J\")) { return new Move.Down(1); } else if (inputLine.equalsIgnoreCase(\"K\")) { return new Move.Up(1); } else if (inputLine.equalsIgnoreCase(\"L\")) { return new Move.Right(1); } else if (inputLine.equalsIgnoreCase(\"U\")) { return new Undo(-1); } else if (inputLine.equalsIgnoreCase(\"EXIT\")) { return new Exit(-1); } else { return new InvalidInput(-1,\"Invalid Input.\"); } }",
        "label": "P"
    },
    "1090": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public void move(Position from, Position to) { // TODO Entity entityToMove = this.getEntity(from); switch (entityToMove){ case Player p-> { int pid = p.getId(); if (destinations.contains(from)) { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '@'; map[from.y() + 1] = String.valueOf(chars); } else { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '.'; map[from.y() + 1] = String.valueOf(chars); } var line = map[to.y() + 1]; char[] chars = line.toCharArray(); chars[to.x()] = (char) (pid+'A'); map[to.y() + 1] = String.valueOf(chars); } case Box b->{ int bid = b.getPlayerId(); boxesPosition.remove(from); boxesPosition.add(to); if (destinations.contains(from)) { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '@'; map[from.y() + 1] = String.valueOf(chars); } else { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '.'; map[from.y() + 1] = String.valueOf(chars); } var line = map[to.y() + 1]; char[] chars = line.toCharArray(); chars[to.x()] = (char) (bid+'a'); map[to.y() + 1] = String.valueOf(chars); } default -> {return;} } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1091": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public void move(Position from, Position to) { // TODO Entity entityToMove = this.getEntity(from); switch (entityToMove){ case Player p-> { int pid = p.getId(); if (destinations.contains(from)) { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '@'; map[from.y() + 1] = String.valueOf(chars); } else { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '.'; map[from.y() + 1] = String.valueOf(chars); } var line = map[to.y() + 1]; char[] chars = line.toCharArray(); chars[to.x()] = (char) (pid+'A'); map[to.y() + 1] = String.valueOf(chars); } case Box b->{ int bid = b.getPlayerId(); boxesPosition.remove(from); boxesPosition.add(to); if (destinations.contains(from)) { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '@'; map[from.y() + 1] = String.valueOf(chars); } else { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '.'; map[from.y() + 1] = String.valueOf(chars); } var line = map[to.y() + 1]; char[] chars = line.toCharArray(); chars[to.x()] = (char) (bid+'a'); map[to.y() + 1] = String.valueOf(chars); } default -> {return;} } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i=1; i<=Height; i++){ int widthofthisline = this.map[i].length(); for(int j=0; j<widthofthisline; j++){ if((int)(map[i].charAt(j)-'A')== id){ return new Position(j,i-1); } } } return null; }",
        "label": "P"
    },
    "1092": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public void move(Position from, Position to) { // TODO Entity entityToMove = this.getEntity(from); switch (entityToMove){ case Player p-> { int pid = p.getId(); if (destinations.contains(from)) { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '@'; map[from.y() + 1] = String.valueOf(chars); } else { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '.'; map[from.y() + 1] = String.valueOf(chars); } var line = map[to.y() + 1]; char[] chars = line.toCharArray(); chars[to.x()] = (char) (pid+'A'); map[to.y() + 1] = String.valueOf(chars); } case Box b->{ int bid = b.getPlayerId(); boxesPosition.remove(from); boxesPosition.add(to); if (destinations.contains(from)) { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '@'; map[from.y() + 1] = String.valueOf(chars); } else { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '.'; map[from.y() + 1] = String.valueOf(chars); } var line = map[to.y() + 1]; char[] chars = line.toCharArray(); chars[to.x()] = (char) (bid+'a'); map[to.y() + 1] = String.valueOf(chars); } default -> {return;} } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i=1; i<=Height; i++){ int widthofthisline = this.map[i].length(); for(int j=0; j<widthofthisline; j++){ if((int)(map[i].charAt(j)-'A')== id){ return new Position(j,i-1); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(this.getMapMaxHeight()<= position.y()||this.map[position.y()+1].length()<=position.x()){ return null; } var entity = this.map[position.y()+1].charAt(position.x()); if(entity == '#'){ return new Wall(); } else if (Character.isUpperCase(entity)) { return new Player((int)entity-'A'); } else if (Character.isLowerCase(entity)) { return new Box((int)entity-'a'); } else if(entity == '.' || entity=='@'){ return new Empty(); } else { return null; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1093": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public Optional<Integer> getUndoQuota() { // TODO return undolimit; }",
        "label": "P"
    },
    "1094": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position>allPlayerPositions = new HashSet<Position>(); for(var playerid:this.playerids){ allPlayerPositions.add(getPlayerPositionById(playerid)); } return allPlayerPositions; }",
        "label": "P"
    },
    "1095": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public void move(Position from, Position to) { // TODO Entity entityToMove = this.getEntity(from); switch (entityToMove){ case Player p-> { int pid = p.getId(); if (destinations.contains(from)) { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '@'; map[from.y() + 1] = String.valueOf(chars); } else { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '.'; map[from.y() + 1] = String.valueOf(chars); } var line = map[to.y() + 1]; char[] chars = line.toCharArray(); chars[to.x()] = (char) (pid+'A'); map[to.y() + 1] = String.valueOf(chars); } case Box b->{ int bid = b.getPlayerId(); boxesPosition.remove(from); boxesPosition.add(to); if (destinations.contains(from)) { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '@'; map[from.y() + 1] = String.valueOf(chars); } else { var line = map[from.y() + 1]; char[] chars = line.toCharArray(); chars[from.x()] = '.'; map[from.y() + 1] = String.valueOf(chars); } var line = map[to.y() + 1]; char[] chars = line.toCharArray(); chars[to.x()] = (char) (bid+'a'); map[to.y() + 1] = String.valueOf(chars); } default -> {return;} } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public void undo() { // TODO if(this.undolimit.isEmpty() || this.undolimit.get()>0) { if (this.mapHistory.size() == 1) { this.map = mapHistory.peek().clone(); this.boxesPosition.clear(); this.boxesPosition.addAll(boxPosHistory.peek()); return; } else if (this.mapHistory.size() > 1) { this.mapHistory.pop(); this.boxPosHistory.pop(); this.map = mapHistory.peek().clone(); this.boxesPosition.clear(); this.boxesPosition.addAll(boxPosHistory.peek()); if(!this.undolimit.isEmpty()) { this.undolimit = Optional.of(this.undolimit.get() - 1); } } } return; } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i=1; i<=Height; i++){ int widthofthisline = this.map[i].length(); for(int j=0; j<widthofthisline; j++){ if((int)(map[i].charAt(j)-'A')== id){ return new Position(j,i-1); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(this.getMapMaxHeight()<= position.y()||this.map[position.y()+1].length()<=position.x()){ return null; } var entity = this.map[position.y()+1].charAt(position.x()); if(entity == '#'){ return new Wall(); } else if (Character.isUpperCase(entity)) { return new Player((int)entity-'A'); } else if (Character.isLowerCase(entity)) { return new Box((int)entity-'a'); } else if(entity == '.' || entity=='@'){ return new Empty(); } else { return null; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return undolimit; }",
        "label": "P"
    },
    "1096": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2){ throw new IllegalArgumentException(); } } public void run() { // TODO renderingEngine.message(\"Sokoban game is ready.\"); renderingEngine.render(state); if(state.getUndoQuota().isEmpty()){ renderingEngine.message(\"Unlimited\"); }else { renderingEngine.message(\"Undo Quota: \"+state.getUndoQuota().get()); } while (true){ Action action = inputEngine.fetchAction(); ActionResult actionresult = processAction(action); if(actionresult.getClass().equals(ActionResult.Failed.class)){ renderingEngine.message (((ActionResult.Failed) actionresult).getReason()); } renderingEngine.render(state); if(shouldStop()){ break; } if(state.getUndoQuota().isEmpty()){ renderingEngine.message(\"Unlimited\"); }else { renderingEngine.message(\"Undo Quota: \"+state.getUndoQuota().get()); } } renderingEngine.message(\"Game exits.\"); if(state.isWin()){ renderingEngine.message(\"You win.\"); } return; }",
        "label": "P"
    },
    "1097": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2){ throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "1098": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. this.outputSteam.print(content+ '\\n'); }",
        "label": "P"
    },
    "1099": {
        "dataset": "COMP 3021",
        "project": "hychancm",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.Width = map.getMaxWidth(); this.Height = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undolimit = map.getUndoLimit(); this.map = map.map; this.playerids = map.getPlayerIds(); List<Position> boxesPos = new ArrayList<Position>(); for (int i=1; i<=this.Height; i++){ int widthofthisline = this.map[i].length(); for (int j=0; j<widthofthisline; j++){ if(Character.isLowerCase(this.map[i].charAt(j))){ boxesPos.add(new Position(j,i-1)); } } } this.boxesPosition = boxesPos; this.mapHistory.push(this.map.clone()); List<Position> deepCopyPos =new ArrayList<>(); deepCopyPos.addAll(this.boxesPosition); this.boxPosHistory.push(deepCopyPos); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1100": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; } public int getMaxHeight() { // TODO return maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undoLimit); }",
        "label": "P"
    },
    "1101": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1102": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1103": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1104": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1105": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1106": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1107": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1108": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; }",
        "label": "P"
    },
    "1109": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; }",
        "label": "P"
    },
    "1110": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1111": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1112": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1113": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1114": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO if (inputLine.equalsIgnoreCase(StringResources.EXIT_COMMAND_TEXT)) { return new Exit(-1); } switch (inputLine) { case \"A\": case \"a\": return new Move.Left(0); case \"S\": case \"s\": return new Move.Down(0); case \"W\": case \"w\": return new Move.Up(0); case \"D\": case \"d\": return new Move.Right(0); case \"H\": case \"h\": return new Move.Left(1); case \"J\": case \"j\": return new Move.Down(1); case \"K\": case \"k\": return new Move.Up(1); case \"L\": case \"l\": return new Move.Right(1); case \"U\": case \"u\": return new Undo(-1); default: return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "1115": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public void move(Position from, Position to) { // TODO map.putEntity(to, getEntity(from)); map.putEntity(from, new Empty()); moveHistory.add(new Movement(from, to)); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1116": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public void move(Position from, Position to) { // TODO map.putEntity(to, getEntity(from)); map.putEntity(from, new Empty()); moveHistory.add(new Movement(from, to)); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = getEntity(new Position(j, i)); if (entity instanceof Player && ((Player) entity).getId() == id) { return new Position(j, i); } } } return null; }",
        "label": "P"
    },
    "1117": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public void move(Position from, Position to) { // TODO map.putEntity(to, getEntity(from)); map.putEntity(from, new Empty()); moveHistory.add(new Movement(from, to)); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = getEntity(new Position(j, i)); if (entity instanceof Player && ((Player) entity).getId() == id) { return new Position(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1118": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public Optional<Integer> getUndoQuota() { // TODO if (undoLimit.isEmpty()) { return Optional.empty(); } else { return Optional.of(undoLimit.get()); } }",
        "label": "P"
    },
    "1119": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> allPlayers = new HashSet<>(); for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { if (getEntity(new Position(j, i)) instanceof Player) { allPlayers.add(new Position(j, i)); } } } return allPlayers; }",
        "label": "P"
    },
    "1120": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public void move(Position from, Position to) { // TODO map.putEntity(to, getEntity(from)); map.putEntity(from, new Empty()); moveHistory.add(new Movement(from, to)); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO checkpoints.add(moveHistory.size()); } public void undo() { // TODO int checkpoint; if (checkpoints.isEmpty()) { checkpoint = 0; } else if (checkpoints.size() == 1) { checkpoints.remove(0); checkpoint = 0; } else { checkpoints.remove(checkpoints.size() - 1); checkpoint = checkpoints.get(checkpoints.size() - 1); } while (moveHistory.size() > checkpoint) { move(moveHistory.get(moveHistory.size() - 1).to(), moveHistory.get(moveHistory.size() - 1).from()); moveHistory.remove(moveHistory.size() - 1); moveHistory.remove(moveHistory.size() - 1); } if (!undoLimit.isEmpty()) { undoLimit = Optional.of(undoLimit.get() - 1); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i < getMapMaxHeight(); i++) { for (int j = 0; j < getMapMaxWidth(); j++) { Entity entity = getEntity(new Position(j, i)); if (entity instanceof Player && ((Player) entity).getId() == id) { return new Position(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (undoLimit.isEmpty()) { return Optional.empty(); } else { return Optional.of(undoLimit.get()); } }",
        "label": "P"
    },
    "1121": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } } public void run() { // TODO System.out.println(StringResources.GAME_READY_MESSAGE); renderingEngine.render(state); while (true) { Action action = inputEngine.fetchAction(); ActionResult actionResult = processAction(action); if (actionResult instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) actionResult).getReason()); } renderingEngine.render(state); if (this.shouldStop()) { System.out.println(StringResources.GAME_EXIT_MESSAGE); if (state.isWin()) { System.out.println(StringResources.WIN_MESSAGE); } break; } if (state.getUndoQuota().isEmpty()) { System.out.printf(StringResources.UNDO_QUOTA_TEMPLATE, StringResources.UNDO_QUOTA_UNLIMITED); } else { System.out.printf(StringResources.UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get().toString()); } System.out.println(); System.out.println(\">>>\"); } }",
        "label": "P"
    },
    "1122": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "1123": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1124": {
        "dataset": "COMP 3021",
        "project": "dlibk",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoLimit = map.getUndoLimit(); moveHistory = new ArrayList<>(); checkpoints = new ArrayList<>(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1125": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { return undoLimit; }",
        "label": "P"
    },
    "1126": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1127": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1128": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1129": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1130": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1131": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.mapArr[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1132": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.mapArr[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1133": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "1134": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "1135": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return this.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return this.mapArr[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1136": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.mapArr[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1137": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.mapArr[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1138": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.mapArr[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1139": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); return switch(inputLine.toLowerCase()){ case \"a\" -> new Move.Left(0); case \"s\" -> new Move.Down(0); case \"w\" -> new Move.Up(0); case \"d\" -> new Move.Right(0); case \"h\" -> new Move.Left(1); case \"j\" -> new Move.Down(1); case \"k\" -> new Move.Up(1); case \"l\" -> new Move.Right(1); case \"exit\" -> new Exit(0); case \"u\"-> new Undo(0); case default -> new InvalidInput(0, \"Invalid input\"); }; }",
        "label": "P"
    },
    "1140": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public void move(Position from, Position to) { Entity tempEntity = mapArr[to.y()][to.x()]; mapArr[to.y()][to.x()] = mapArr[from.y()][from.x()]; mapArr[from.y()][from.x()] = tempEntity; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1141": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public void move(Position from, Position to) { Entity tempEntity = mapArr[to.y()][to.x()]; mapArr[to.y()][to.x()] = mapArr[from.y()][from.x()]; mapArr[from.y()][from.x()] = tempEntity; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for(int row = 0; row < maxHeight; row++){ for (int col = 0; col < maxWidth; col++){ if (mapArr[row][col] instanceof Player){ if (((Player)mapArr[row][col]).getId() == id) return new Position(col,row); } } } throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "1142": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public void move(Position from, Position to) { Entity tempEntity = mapArr[to.y()][to.x()]; mapArr[to.y()][to.x()] = mapArr[from.y()][from.x()]; mapArr[from.y()][from.x()] = tempEntity; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for(int row = 0; row < maxHeight; row++){ for (int col = 0; col < maxWidth; col++){ if (mapArr[row][col] instanceof Player){ if (((Player)mapArr[row][col]).getId() == id) return new Position(col,row); } } } throw new IllegalArgumentException(); } public @Nullable Entity getEntity(@NotNull Position position) { return this.mapArr[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1143": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public Optional<Integer> getUndoQuota() { return this.undoQuota; }",
        "label": "P"
    },
    "1144": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { Set<Position> result = new HashSet<Position>(); for (Player player: this.players){ result.add(getPlayerPositionById(player.getId())); } return result; }",
        "label": "P"
    },
    "1145": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public void move(Position from, Position to) { Entity tempEntity = mapArr[to.y()][to.x()]; mapArr[to.y()][to.x()] = mapArr[from.y()][from.x()]; mapArr[from.y()][from.x()] = tempEntity; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { if (last != null){ stateHistory.add(last); } last = deepCopyMap(this.mapArr); } public void undo() { if (this.equals(original)) return; if (stateHistory.isEmpty()){ this.mapArr = deepCopyMap(original); if (last != null) { undoQuota = undoQuota.isPresent() ? Optional.of(undoQuota.get() - 1) : undoQuota; } last = null; } else { int targetIndex = stateHistory.size() - 1; this.mapArr = deepCopyMap(stateHistory.get(targetIndex)); last = deepCopyMap(this.mapArr); stateHistory.remove(targetIndex); undoQuota = undoQuota.isPresent() ? Optional.of(undoQuota.get() - 1) : undoQuota; } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { for(int row = 0; row < maxHeight; row++){ for (int col = 0; col < maxWidth; col++){ if (mapArr[row][col] instanceof Player){ if (((Player)mapArr[row][col]).getId() == id) return new Position(col,row); } } } throw new IllegalArgumentException(); } public @Nullable Entity getEntity(@NotNull Position position) { return this.mapArr[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { return this.undoQuota; }",
        "label": "P"
    },
    "1146": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } public void run() { renderingEngine.message(\"Sokoban game is ready.\"); renderingEngine.render(state); Optional<Integer> undoQuota = state.getUndoQuota(); if (undoQuota.isPresent()) { renderingEngine.message(\"\\nUndo Quota: \" + undoQuota.get()); } else renderingEngine.message(\"\\nUnlimited\"); Action action; ActionResult result; while (true){ action = inputEngine.fetchAction(); result = processAction(action); undoQuota = state.getUndoQuota(); if (result instanceof ActionResult.Failed) renderingEngine.message(((ActionResult.Failed) result).getReason()); renderingEngine.render(state); if (action instanceof Exit) { renderingEngine.message(((ActionResult.Failed) result).getReason()); break; } if (state.isWin()){ renderingEngine.message(\"\\nGame exits.\\nYou win.\"); break; } if (undoQuota.isPresent()) { renderingEngine.message(\"\\nUndo Quota: \" + undoQuota.get()); } else renderingEngine.message(\"\\nUnlimited\"); } }",
        "label": "P"
    },
    "1147": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); }",
        "label": "P"
    },
    "1148": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1149": {
        "dataset": "COMP 3021",
        "project": "slwongah",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.undoQuota = map.undoLimit; this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.mapArr = map.getMap(); this.players = map.players; this.stateHistory = new ArrayList<Entity[][]>(0); original = deepCopyMap(this.mapArr); this.checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { final var builder = new StringBuilder(); for (int y = 0; y < state.getMapMaxHeight(); y++) { for (int x = 0; x < state.getMapMaxWidth(); x++) { final var entity = state.getEntity(Position.of(x, y)); var charToPrint = switch (entity) { case Wall ignored -> '#'; case Box b -> String.valueOf((char)((int)'a'+b.getPlayerId())); case Player p -> String.valueOf((char)((int)'A'+p.getId())); case Empty ignored -> '.'; case null-> ' '; }; if (entity instanceof Empty) { for (Position destination: state.getDestinations()){ if (destination.x() == x & destination.y()==y){ charToPrint = \"@\"; } } } builder.append(charToPrint); } if (y!= state.getMapMaxHeight()-1) builder.append('\\n'); } outputSteam.println(builder); }",
        "label": "P"
    },
    "1150": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; } public int getMaxHeight() { // TODO return maxHeight; } public Optional<Integer> getUndoLimit() { // TODO Optional<Integer> un = Optional.of(undoLimit); return un; }",
        "label": "P"
    },
    "1151": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1152": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1153": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1154": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1155": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1156": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO //return gameMap.getEntity(position); String map = gameMap.getMap(); String[] arr = map.split(\"\\n\", 10); int x = position.x(); int y = position.y(); if (x >= arr[y+1].length()){ return null; } char e = arr[y+1].charAt(x); if (Character.isLowerCase(e)){ return new Box(e-'a'); } else if (Character.isUpperCase(e)){ return new Player(e-'A'); } else if (e == '.' || e == '@'){ return new Empty(); } else if (e == '#'){ return new Wall(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1157": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO //return gameMap.getEntity(position); String map = gameMap.getMap(); String[] arr = map.split(\"\\n\", 10); int x = position.x(); int y = position.y(); if (x >= arr[y+1].length()){ return null; } char e = arr[y+1].charAt(x); if (Character.isLowerCase(e)){ return new Box(e-'a'); } else if (Character.isUpperCase(e)){ return new Player(e-'A'); } else if (e == '.' || e == '@'){ return new Empty(); } else if (e == '#'){ return new Wall(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1158": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; }",
        "label": "P"
    },
    "1159": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; }",
        "label": "P"
    },
    "1160": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO //return gameMap.getEntity(position); String map = gameMap.getMap(); String[] arr = map.split(\"\\n\", 10); int x = position.x(); int y = position.y(); if (x >= arr[y+1].length()){ return null; } char e = arr[y+1].charAt(x); if (Character.isLowerCase(e)){ return new Box(e-'a'); } else if (Character.isUpperCase(e)){ return new Player(e-'A'); } else if (e == '.' || e == '@'){ return new Empty(); } else if (e == '#'){ return new Wall(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1161": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO //return gameMap.getEntity(position); String map = gameMap.getMap(); String[] arr = map.split(\"\\n\", 10); int x = position.x(); int y = position.y(); if (x >= arr[y+1].length()){ return null; } char e = arr[y+1].charAt(x); if (Character.isLowerCase(e)){ return new Box(e-'a'); } else if (Character.isUpperCase(e)){ return new Player(e-'A'); } else if (e == '.' || e == '@'){ return new Empty(); } else if (e == '#'){ return new Wall(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1162": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO //return gameMap.getEntity(position); String map = gameMap.getMap(); String[] arr = map.split(\"\\n\", 10); int x = position.x(); int y = position.y(); if (x >= arr[y+1].length()){ return null; } char e = arr[y+1].charAt(x); if (Character.isLowerCase(e)){ return new Box(e-'a'); } else if (Character.isUpperCase(e)){ return new Player(e-'A'); } else if (e == '.' || e == '@'){ return new Empty(); } else if (e == '#'){ return new Wall(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1163": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO //return gameMap.getEntity(position); String map = gameMap.getMap(); String[] arr = map.split(\"\\n\", 10); int x = position.x(); int y = position.y(); if (x >= arr[y+1].length()){ return null; } char e = arr[y+1].charAt(x); if (Character.isLowerCase(e)){ return new Box(e-'a'); } else if (Character.isUpperCase(e)){ return new Player(e-'A'); } else if (e == '.' || e == '@'){ return new Empty(); } else if (e == '#'){ return new Wall(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1164": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO if (inputLine.equals(\"exit\")){ return new Exit(0); } else if (inputLine.equals(\"a\")){ return new Move.Left(0); } else if (inputLine.equals(\"s\")){ return new Move.Down(0); } else if (inputLine.equals(\"w\")){ return new Move.Up(0); } else if (inputLine.equals(\"d\")){ return new Move.Right(0); } else if (inputLine.equals(\"u\")){ return new Undo(0); } else if (inputLine.equals(\"h\")){ return new Move.Left(1); } else if (inputLine.equals(\"j\")){ return new Move.Down(1); } else if (inputLine.equals(\"k\")){ return new Move.Up(1); } else if (inputLine.equals(\"l\")){ return new Move.Right(1); } return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); }",
        "label": "P"
    },
    "1165": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public void move(Position from, Position to) { // TODO gameMap.putEntity(to, gameMap.getEntity(from)); gameMap.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1166": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public void move(Position from, Position to) { // TODO gameMap.putEntity(to, gameMap.getEntity(from)); gameMap.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO char p = (char) (id + 'A'); String m = gameMap.getMap(); String[] arr = m.split(\"\\n\", 100); for (int i = 1; i < arr.length-1; i++) { for (int j = 0; j < arr[i].length(); j++) { if (arr[i] != \"\"){ if (arr[i].charAt(j) == p){ return new Position(j, i-1); } } } } return null; }",
        "label": "P"
    },
    "1167": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public void move(Position from, Position to) { // TODO gameMap.putEntity(to, gameMap.getEntity(from)); gameMap.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO char p = (char) (id + 'A'); String m = gameMap.getMap(); String[] arr = m.split(\"\\n\", 100); for (int i = 1; i < arr.length-1; i++) { for (int j = 0; j < arr[i].length(); j++) { if (arr[i] != \"\"){ if (arr[i].charAt(j) == p){ return new Position(j, i-1); } } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO //return gameMap.getEntity(position); String map = gameMap.getMap(); String[] arr = map.split(\"\\n\", 10); int x = position.x(); int y = position.y(); if (x >= arr[y+1].length()){ return null; } char e = arr[y+1].charAt(x); if (Character.isLowerCase(e)){ return new Box(e-'a'); } else if (Character.isUpperCase(e)){ return new Player(e-'A'); } else if (e == '.' || e == '@'){ return new Empty(); } else if (e == '#'){ return new Wall(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1168": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public Optional<Integer> getUndoQuota() { // TODO if (Optional.of(gameMap.getUndoLimit().get()) == Optional.of(-1)){ return Optional.empty(); } return Optional.of(gameMap.getUndoLimit().get()); }",
        "label": "P"
    },
    "1169": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> allPlayer = new HashSet<Position>(); Set<Integer> playerId = gameMap.getPlayerIds(); for (Integer id : playerId){ allPlayer.add(getPlayerPositionById(id)); } return allPlayer; }",
        "label": "P"
    },
    "1170": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public void move(Position from, Position to) { // TODO gameMap.putEntity(to, gameMap.getEntity(from)); gameMap.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO cpMap.add(gameMap.getMap()); } public void undo() { // TODO if (cpMap.size() > 1){ cpMap.remove(cpMap.size()-1); gameMap.undoLimit--; gameMap.map = cpMap.get(cpMap.size()-1); } else{ if (gameMap.map != cpMap.get(0)){ gameMap.map = cpMap.get(0); gameMap.undoLimit--; } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO char p = (char) (id + 'A'); String m = gameMap.getMap(); String[] arr = m.split(\"\\n\", 100); for (int i = 1; i < arr.length-1; i++) { for (int j = 0; j < arr[i].length(); j++) { if (arr[i] != \"\"){ if (arr[i].charAt(j) == p){ return new Position(j, i-1); } } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO //return gameMap.getEntity(position); String map = gameMap.getMap(); String[] arr = map.split(\"\\n\", 10); int x = position.x(); int y = position.y(); if (x >= arr[y+1].length()){ return null; } char e = arr[y+1].charAt(x); if (Character.isLowerCase(e)){ return new Box(e-'a'); } else if (Character.isUpperCase(e)){ return new Player(e-'A'); } else if (e == '.' || e == '@'){ return new Empty(); } else if (e == '#'){ return new Wall(); } return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (Optional.of(gameMap.getUndoLimit().get()) == Optional.of(-1)){ return Optional.empty(); } return Optional.of(gameMap.getUndoLimit().get()); }",
        "label": "P"
    },
    "1171": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players this.gameState = gameState; int numPlayer = gameState.getAllPlayerPositions().size(); if (numPlayer > 2){ throw new IllegalArgumentException(); } } public void run() { // TODO renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(gameState); if (state.getUndoQuota().isPresent()){ renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get()); } else { renderingEngine.message(StringResources.UNDO_QUOTA_UNLIMITED); } Action a = null; while (true){ if ((gameState.isWin())){ renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); renderingEngine.message(StringResources.WIN_MESSAGE); break; } a = inputEngine.fetchAction(); ActionResult k = processAction(a); if (k instanceof ActionResult.Failed){ renderingEngine.message(((ActionResult.Failed) k).getReason()); renderingEngine.render(gameState); } else{ renderingEngine.render(gameState); if (a instanceof Exit){ break; } } if (state.getUndoQuota().isPresent()){ renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get()); } else { renderingEngine.message(StringResources.UNDO_QUOTA_UNLIMITED); } } }",
        "label": "P"
    },
    "1172": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players this.gameState = gameState; int numPlayer = gameState.getAllPlayerPositions().size(); if (numPlayer > 2){ throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "1173": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1174": {
        "dataset": "COMP 3021",
        "project": "snab",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.gameMap = map; cpMap.add(map.getMap()); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1175": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { return undoLimit; }",
        "label": "P"
    },
    "1176": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1177": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1178": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1179": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1180": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1181": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1182": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1183": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "1184": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "1185": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return this.gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1186": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1187": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1188": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1189": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); switch (inputLine) { case \"w\": return new Move.Up(0); case \"a\": return new Move.Left(0); case \"s\": return new Move.Down(0); case \"d\": return new Move.Right(0); case \"h\": return new Move.Left(1); case \"j\": return new Move.Down(1); case \"k\": return new Move.Up(1); case \"l\": return new Move.Right(1); case \"u\": return new Undo(0); case EXIT_COMMAND_TEXT: return new Exit(0); default: return new InvalidInput(0, INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "1190": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public void move(Position from, Position to) { Entity temp = gameMap.getEntity(to); gameMap.putEntity(to,gameMap.getEntity(from)); gameMap.putEntity(from,temp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1191": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public void move(Position from, Position to) { Entity temp = gameMap.getEntity(to); gameMap.putEntity(to,gameMap.getEntity(from)); gameMap.putEntity(from,temp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { int x = 0; int y = 0; for (ArrayList<Entity> list : gameMap.getMap()) { x = 0; for (Entity e : list) { if (e instanceof Player) { if (((Player) e).getId() == id) { return (new Position(x,y)); } } x += 1; } y += 1; } return null; }",
        "label": "P"
    },
    "1192": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public void move(Position from, Position to) { Entity temp = gameMap.getEntity(to); gameMap.putEntity(to,gameMap.getEntity(from)); gameMap.putEntity(from,temp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { int x = 0; int y = 0; for (ArrayList<Entity> list : gameMap.getMap()) { x = 0; for (Entity e : list) { if (e instanceof Player) { if (((Player) e).getId() == id) { return (new Position(x,y)); } } x += 1; } y += 1; } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1193": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public Optional<Integer> getUndoQuota() { return undoQuota; }",
        "label": "P"
    },
    "1194": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { Set<Position> result = new HashSet<>(); int x = 0; int y = 0; for (ArrayList<Entity> list : gameMap.getMap()) { x = 0; for (Entity e : list) { if (e instanceof Player) { result.add (new Position(x,y)); } x += 1; } y += 1; } return result; }",
        "label": "P"
    },
    "1195": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public void move(Position from, Position to) { Entity temp = gameMap.getEntity(to); gameMap.putEntity(to,gameMap.getEntity(from)); gameMap.putEntity(from,temp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { checkpointMaps.add(gameMap.getMapCopy()); } public void undo() { if (undoQuota.isPresent()) { undoQuota = undoQuota.map(i->i-1); } if (checkpointMaps.size() <= 1) { gameMap.setMap(initialMap); } else { gameMap.setMap(checkpointMaps.get(checkpointMaps.size()-2)); checkpointMaps.remove(checkpointMaps.size()-1); checkpointMaps.remove(checkpointMaps.size()-1); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { int x = 0; int y = 0; for (ArrayList<Entity> list : gameMap.getMap()) { x = 0; for (Entity e : list) { if (e instanceof Player) { if (((Player) e).getId() == id) { return (new Position(x,y)); } } x += 1; } y += 1; } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return this.gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { return undoQuota; }",
        "label": "P"
    },
    "1196": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; System.out.println(GAME_READY_MESSAGE); System.out.println(\"No. of Players: \" + gameState.getAllPlayerPositions().size()); } public void run() { while (!super.shouldStop()) { renderingEngine.render(state); state.getUndoQuota().ifPresentOrElse( value -> System.out.printf(UNDO_QUOTA_TEMPLATE, Integer.toString(value)), () -> System.out.print(UNDO_QUOTA_UNLIMITED) ); System.out.print(\"\\n>>>\\n\"); Action action = inputEngine.fetchAction(); ActionResult result = super.processAction(action); if (result instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) result).getReason()); } } renderingEngine.render(state); System.out.println(GAME_EXIT_MESSAGE); }",
        "label": "P"
    },
    "1197": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; System.out.println(GAME_READY_MESSAGE); System.out.println(\"No. of Players: \" + gameState.getAllPlayerPositions().size()); }",
        "label": "P"
    },
    "1198": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { outputSteam.println(content); }",
        "label": "P"
    },
    "1199": {
        "dataset": "COMP 3021",
        "project": "mohaa",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.initialMap = map.getMapCopy(); this.checkpointMaps = new ArrayList<>(); undoQuota = map.getUndoLimit(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { final var builder = new StringBuilder(); for (int y = 0; y < state.getMapMaxHeight(); y++) { for (int x = 0; x < state.getMapMaxWidth(); x++) { final var entity = state.getEntity(Position.of(x, y)); char charToPrint; if (entity instanceof Wall) charToPrint = '#'; else if (entity == null) charToPrint = ' '; else //include emtpy, player, box charToPrint = '.'; for (Position p : state.getDestinations()) { if (p.x() == x && p.y() == y) { charToPrint = '@'; } } if (entity instanceof Box) charToPrint = (char) ('a' + ((Box) entity).getPlayerId()); else if (entity instanceof Player) charToPrint = (char) ('A' + ((Player) entity).getId()); builder.append(charToPrint); } builder.append('\\n'); } outputSteam.print(builder); } public GameMap(int maxWidth, int maxHeight, Set<Position> destinations, int undoLimit) { this.maxWidth = maxWidth; this.maxHeight = maxHeight; this.destinations = destinations; if (undoLimit == -1) { this.undoLimit = Optional.empty(); } else { this.undoLimit = Optional.of(undoLimit); } this.map = new ArrayList<>(); } /** * Parses the map from a string representation. * The first line is undo limit. * Starting from the second line, the game map is represented as follows, * <li># represents a {@link Wall}</li> * <li>@ represents a box destination.</li> * <li>Any upper-case letter represents a {@link Player}.</li> * <li> * Any lower-case letter represents a {@link Box} that is only movable by the player with the corresponding upper-case letter. * For instance, box \"a\" can only be moved by player \"A\" and not movable by player \"B\". * </li> * <li>. represents an {@link Empty} position in the map, meaning there is no player or box currently at this position.</li> * <p> * Notes: * <li> * There can be at most 26 players. * All implementations of classes in the hk.ust.comp3021.game package should support up to 26 players. * </li> * <li> * For simplicity, we assume the given map is bounded with a closed boundary. * There is no need to check this point. * </li> * <li> * Example maps can be found in \"src/main/resources\". * </li> * * @param mapText The string representation. * @return The parsed GameMap object. * @throws IllegalArgumentException if undo limit is negative but not -1. * @throws IllegalArgumentException if there are multiple same upper-case letters, i.e., one player can only exist at one position. * @throws IllegalArgumentException if there are no players in the map. * @throws IllegalArgumentException if the number of boxes is not equal to the number of box destinations. * @throws IllegalArgumentException if there are boxes whose {@link Box#getPlayerId()}",
        "label": "P"
    },
    "1200": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO done return this.maxWidth; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO done return this.maxHeight; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO done return Optional.of(this.undoLimit); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1201": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1202": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1203": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1204": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1205": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1206": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO done return currentMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1207": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO done return currentMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1208": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO done return this.maxHeight; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1209": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO done return this.maxWidth; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1210": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO done return currentMap.getDestinations(); // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO done return currentMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1211": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO done return currentMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1212": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO done return currentMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1213": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO done return currentMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1214": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO done var inputLowerCase = inputLine.toLowerCase(); // Support up to 2 player var initiator = 0; // Exit if(inputLowerCase.equals(EXIT_COMMAND_TEXT)){ return new Exit(initiator); } if(inputLowerCase.length() == 1){ var ch = inputLowerCase.charAt(0); switch (ch){ case 'u' ->{ //undo return new Undo(initiator); } case 'w' -> { return new Move.Up(initiator); } case 'a' -> { return new Move.Left(initiator); } case 's' -> { return new Move.Down(initiator); } case 'd' -> { return new Move.Right(initiator); } case 'h' -> { initiator = 1; return new Move.Up(initiator); } case 'j' -> { initiator = 1; return new Move.Left(initiator); } case 'k' -> { initiator = 1; return new Move.Down(initiator); } case 'l' -> { initiator = 1; return new Move.Right(initiator); } default -> { return new InvalidInput(initiator, INVALID_INPUT_MESSAGE); } } } // Invalid Input return new InvalidInput(initiator, INVALID_INPUT_MESSAGE); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1215": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO done var tmp = currentMap.getEntity(from); currentMap.putEntity(from, new Empty()); currentMap.putEntity(to, tmp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1216": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO done var tmp = currentMap.getEntity(from); currentMap.putEntity(from, new Empty()); currentMap.putEntity(to, tmp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO done for(var y = 0; y < currentMap.getMaxHeight(); ++y){ for(var x = 0; x < currentMap.getMaxWidth(); ++x){ var pos = Position.of(x,y); var entity = currentMap.getEntity(pos); if(entity instanceof Player p && p.getId() == id) return pos; } } return null; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1217": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO done var tmp = currentMap.getEntity(from); currentMap.putEntity(from, new Empty()); currentMap.putEntity(to, tmp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO done for(var y = 0; y < currentMap.getMaxHeight(); ++y){ for(var x = 0; x < currentMap.getMaxWidth(); ++x){ var pos = Position.of(x,y); var entity = currentMap.getEntity(pos); if(entity instanceof Player p && p.getId() == id) return pos; } } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO done return currentMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1218": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO done if(undoQuota != -1){ return Optional.of(undoQuota); }else{ return Optional.empty(); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1219": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO done Set<Position> result = new HashSet<Position>(); for(var id: currentMap.getPlayerIds()){ result.add(getPlayerPositionById(id)); } return result; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1220": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO done var tmp = currentMap.getEntity(from); currentMap.putEntity(from, new Empty()); currentMap.putEntity(to, tmp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO done checkpoints.push(new GameMap(currentMap, undoQuota)); // throw new NotImplementedException(); } public void undo() { // TODO done if(undoQuota <= 0 && undoQuota != -1) return; // only 1 checkpt if(!checkpoints.empty()){ checkpoints.pop(); --this.undoQuota; } // empty, or 1 checkpt before use the unmodified map if(checkpoints.empty()){ // revert to the inital game state currentMap = new GameMap(map, undoQuota); return; } currentMap = checkpoints.lastElement(); // throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO done for(var y = 0; y < currentMap.getMaxHeight(); ++y){ for(var x = 0; x < currentMap.getMaxWidth(); ++x){ var pos = Position.of(x,y); var entity = currentMap.getEntity(pos); if(entity instanceof Player p && p.getId() == id) return pos; } } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO done return currentMap.getEntity(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO done if(undoQuota != -1){ return Optional.of(undoQuota); }else{ return Optional.empty(); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1221": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO done if(state.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } public void run() { // TODO done renderingEngine.message(GAME_READY_MESSAGE); while (!super.shouldStop()){ renderingEngine.render(state); renderingEngine.message(\"\"); if(state.getUndoQuota().isPresent()){ var undoMsg = String.format(UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get()); renderingEngine.message(undoMsg); }else{ renderingEngine.message(UNDO_QUOTA_UNLIMITED); } var action = inputEngine.fetchAction(); var result = super.processAction(action); // Print if the action is failed if(result instanceof ActionResult.Failed failed) renderingEngine.message(failed.getReason()); // print the map } renderingEngine.render(state); renderingEngine.message(\"\"); renderingEngine.message(GAME_EXIT_MESSAGE); if(state.isWin()) renderingEngine.message(WIN_MESSAGE); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1222": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO done if(state.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); }",
        "label": "P"
    },
    "1223": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO done // Hint: System.out is also a PrintStream. outputSteam.println(content); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1224": {
        "dataset": "COMP 3021",
        "project": "ktckwan",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO done this.map = map; // The map should not be modifed if(map.getUndoLimit().isPresent()) this.undoQuota = map.getUndoLimit().get(); // Integer value else this.undoQuota = 0; // explict this.currentMap = new GameMap(map, this.undoQuota); // currentMap is a deep copy of map // throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1225": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; // throw new NotImplementedException(); } public int getMaxHeight() { // TODO return maxHeight; // throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO if (this.undoLimit == -1) { return Optional.empty(); }else { return Optional.of(this.undoLimit); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1226": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1227": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1228": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1229": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1230": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1231": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.allEntity.get(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1232": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.allEntity.get(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1233": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1234": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1235": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.allEntity.get(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1236": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.allEntity.get(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1237": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.allEntity.get(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1238": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.allEntity.get(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1239": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO Action result = switch (inputLine) { case \"w\" -> new Move.Up(0); case \"s\" -> new Move.Down(0); case \"a\" -> new Move.Left(0); case \"d\" -> new Move.Right(0); case \"k\" -> new Move.Up(1); case \"j\" -> new Move.Down(1); case \"h\" -> new Move.Left(1); case \"l\" -> new Move.Right(1); case \"u\" -> new Undo(0); case \"exit\" -> new Exit(0); default -> new InvalidInput(0, \"Invalid Input.\"); }; return result; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1240": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO this.allEntity.put(to, this.allEntity.get(from)); this.allEntity.put(from, new Empty()); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1241": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO this.allEntity.put(to, this.allEntity.get(from)); this.allEntity.put(from, new Empty()); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = this.allEntity.get(new Position(j, i)); if (e instanceof Player) { if (((Player) e).getId() == id) { return new Position(j, i); } } } } return null; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1242": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO this.allEntity.put(to, this.allEntity.get(from)); this.allEntity.put(from, new Empty()); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = this.allEntity.get(new Position(j, i)); if (e instanceof Player) { if (((Player) e).getId() == id) { return new Position(j, i); } } } } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.allEntity.get(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1243": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO return this.undoLimit; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1244": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> result = new HashSet<>(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = this.allEntity.get(new Position(j, i)); if (e instanceof Player) { result.add(new Position(j, i)); } } } return result; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1245": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO this.allEntity.put(to, this.allEntity.get(from)); this.allEntity.put(from, new Empty()); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO HashMap<Position, Entity> temp = new HashMap<>(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = this.allEntity.get(new Position(j, i)); temp.put(new Position(j, i), e); } } this.checkpoints.add(temp); // throw new NotImplementedException(); } public void undo() { // TODO int size = this.checkpoints.size(); if (size > 1) { this.allEntity = this.checkpoints.get(size - 2); this.checkpoints.remove(size - 1); this.checkpoints.remove(size - 2); checkpoint(); if (this.undoLimit.isPresent()) { this.undoLimit = Optional.of(this.undoLimit.get() - 1); } } else { this.allEntity = this.checkpoints.get(0); this.checkpoints.remove(0); checkpoint(); } // throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = this.allEntity.get(new Position(j, i)); if (e instanceof Player) { if (((Player) e).getId() == id) { return new Position(j, i); } } } } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.allEntity.get(position); // throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return this.undoLimit; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1246": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (super.state.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } this.renderingEngine.message(\"Sokoban game is ready\"); // throw new NotImplementedException(); } public void run() { // TODO while (!super.shouldStop()) { this.renderingEngine.render(super.state); if (super.state.getUndoQuota().isPresent()) { this.renderingEngine.message(\"Undo Quota: \" + String.valueOf(this.state.getUndoQuota().get())); } else { this.renderingEngine.message(\"Unlimited\"); } this.renderingEngine.message(\">>>\"); var act = super.processAction(this.inputEngine.fetchAction()); if (act instanceof ActionResult.Failed a) { this.renderingEngine.message(a.getReason()); } } this.renderingEngine.render(super.state); this.renderingEngine.message(\"Game exits.\"); if (this.state.isWin()) { this.renderingEngine.message(\"You win.\"); } // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1247": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (super.state.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } this.renderingEngine.message(\"Sokoban game is ready\"); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1248": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. this.outputSteam.println(content); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1249": {
        "dataset": "COMP 3021",
        "project": "ydengbd",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.playerIds = map.getPlayerIds(); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { Entity e = map.getEntity(new Position(j, i)); this.allEntity.put(new Position(j, i), e); } } checkpoint(); // throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1250": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO Optional<Integer> optionalUndoLimit = Optional.of(this.undoLimit); return optionalUndoLimit; }",
        "label": "P"
    },
    "1251": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1252": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1253": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1254": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1255": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1256": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return entityMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1257": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return entityMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1258": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "1259": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "1260": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; // throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return entityMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1261": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return entityMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1262": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return entityMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1263": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return entityMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1264": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. if (terminalScanner.hasNextLine()) { final var inputLine = terminalScanner.nextLine(); switch (inputLine.toLowerCase()) { case \"exit\" -> { return new Exit(-1); } case \"a\" -> { return new Move.Left(0); } case \"s\" -> { return new Move.Down(0); } case \"d\" -> { return new Move.Right(0); } case \"w\" -> { return new Move.Up(0); } case \"h\" -> { return new Move.Left(1); } case \"j\" -> { return new Move.Down(1); } case \"k\" -> { return new Move.Up(1); } case \"l\" -> { return new Move.Right(1); } case \"u\" -> { return new Undo(-1); } default -> { return new InvalidInput(-1, INVALID_INPUT_MESSAGE); } } } else { throw new NoSuchElementException(\"Line not found\"); } // terminalScanner.close(); // return new InvalidInput(-1, INVALID_INPUT_MESSAGE); // TODO // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1265": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO this.entityMap[to.y()][to.x()] = this.entityMap[from.y()][from.x()]; this.entityMap[from.y()][from.x()] = new Empty(); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1266": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO this.entityMap[to.y()][to.x()] = this.entityMap[from.y()][from.x()]; this.entityMap[from.y()][from.x()] = new Empty(); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i<maxHeight; i++) { for (int j = 0; j<maxWidth; j++) { if (entityMap[i][j] instanceof Player) { if (((Player) entityMap[i][j]).getId() == id) { return Position.of(j, i); } } } } return null; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1267": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO this.entityMap[to.y()][to.x()] = this.entityMap[from.y()][from.x()]; this.entityMap[from.y()][from.x()] = new Empty(); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i<maxHeight; i++) { for (int j = 0; j<maxWidth; j++) { if (entityMap[i][j] instanceof Player) { if (((Player) entityMap[i][j]).getId() == id) { return Position.of(j, i); } } } } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return entityMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1268": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { if (this.undoQuotaLeft.get() >= 0) { return Optional.of(this.undoQuotaLeft.get()); } else { return Optional.empty(); } // TODO // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1269": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // this.printEntityMap(); Set<Position> allPlayerPositions = new HashSet<>(); // TODO for (int i = 0; i<maxHeight; i++) { for (int j = 0; j<maxWidth; j++) { if (entityMap[i][j] instanceof Player) { allPlayerPositions.add(Position.of(j, i)); } } } return allPlayerPositions; // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1270": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO this.entityMap[to.y()][to.x()] = this.entityMap[from.y()][from.x()]; this.entityMap[from.y()][from.x()] = new Empty(); // throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO var tempMap = new Entity[maxHeight][maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = this.entityMap[i][j]; if (entity == null) { tempMap[i][j] = null; }else if (entity instanceof Wall) { tempMap[i][j] = new Wall(); } else if (entity instanceof Player) { tempMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { tempMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { tempMap[i][j] = new Empty(); } } } this.checkPoints.add(tempMap); this.currentCheckPoint += 1; // throw new NotImplementedException(); } public void undo() { // TODO if (this.getUndoQuota().isEmpty() || this.undoQuotaLeft.get() > 0) { if (this.currentCheckPoint == 0) { // change everything to initial - no need to decrement undoquota for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { var entity = this.initialEntityMap[i][j]; if (entity == null) { entityMap[i][j] = null; } else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); } } } // this.destinations = new HashSet<>(destinations); } else if (this.currentCheckPoint == 1) { // change everything to initial; undoquotaleft-- , empty checkpoints for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { var entity = this.initialEntityMap[i][j]; if (entity == null) { entityMap[i][j] = null; } else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); } } } this.currentCheckPoint = 0; // this.destinations = new HashSet<>(destinations); this.checkPoints.clear(); if (this.getUndoQuota().isPresent()) { this.undoQuotaLeft = Optional.of(this.undoQuotaLeft.get() - 1); } } else { // Copy entrymap, destinations, checkpoints from checkpoint ; undoquotleft -- var checkPointMap = this.checkPoints.get(checkPoints.size() - 2); for (int i = 0; i < this.maxHeight; i++) { for (int j = 0; j < this.maxWidth; j++) { var entity = checkPointMap[i][j]; if (entity == null) { entityMap[i][j] = null; } else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); } } } this.currentCheckPoint -= 1; this.checkPoints.remove(checkPoints.size() - 1); if (this.getUndoQuota().isPresent()) { this.undoQuotaLeft = Optional.of(this.undoQuotaLeft.get() - 1); } } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (int i = 0; i<maxHeight; i++) { for (int j = 0; j<maxWidth; j++) { if (entityMap[i][j] instanceof Player) { if (((Player) entityMap[i][j]).getId() == id) { return Position.of(j, i); } } } } return null; // throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return entityMap[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { if (this.undoQuotaLeft.get() >= 0) { return Optional.of(this.undoQuotaLeft.get()); } else { return Optional.empty(); } // TODO // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1271": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players // throw new NotImplementedException(); if (gameState.getAllPlayerIds().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } } public void run() { renderingEngine.message(GAME_READY_MESSAGE); // TODO // throw new NotImplementedException(); while (!super.shouldStop()) { // if (i > 5) throw new NotImplementedException(); renderingEngine.render(this.state); if (this.state.getUndoQuota().isEmpty()) { renderingEngine.message(UNDO_QUOTA_UNLIMITED); } else { renderingEngine.message(String.format(UNDO_QUOTA_TEMPLATE,this.state.getUndoQuota().get())); } renderingEngine.message(\">>> \"); // this.state.printEntityMap(); var action = inputEngine.fetchAction(); var actionResult = processAction(action); if (actionResult instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) actionResult).getReason()); } else if (actionResult instanceof ActionResult.Success) { if (action instanceof Exit) { break; } } // renderingEngine. } renderingEngine.render(state); renderingEngine.message(GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(WIN_MESSAGE); } }",
        "label": "P"
    },
    "1272": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players // throw new NotImplementedException(); if (gameState.getAllPlayerIds().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } }",
        "label": "P"
    },
    "1273": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1274": {
        "dataset": "COMP 3021",
        "project": "hchoaf",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoQuotaLeft = map.getUndoLimit(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.destinations = new HashSet<>(map.getDestinations()); this.entityMap = new Entity[this.maxHeight][this.maxWidth]; this.initialEntityMap = new Entity[this.maxHeight][this.maxWidth]; for(int i = 0; i<this.maxHeight; i++) { for(int j = 0; j<this.maxWidth; j++) { Entity entity = map.getEntity(Position.of(j, i)); if (entity == null) { entityMap[i][j] = null; initialEntityMap[i][j] = null; }else if (entity instanceof Wall) { entityMap[i][j] = new Wall(); initialEntityMap[i][j] = new Wall(); } else if (entity instanceof Player) { entityMap[i][j] = new Player(((Player) entity).getId()); initialEntityMap[i][j] = new Player(((Player) entity).getId()); } else if (entity instanceof Box) { entityMap[i][j] = new Box(((Box) entity).getPlayerId()); initialEntityMap[i][j] = new Box(((Box) entity).getPlayerId()); } else if (entity instanceof Empty) { entityMap[i][j] = new Empty(); initialEntityMap[i][j] = new Empty(); } } } this.initialDestinations = new HashSet<>(this.destinations); // throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1275": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // FIXME return maxWidth; } public int getMaxHeight() { // FIXME return maxHeight; } public Optional<Integer> getUndoLimit() { // FIXME return undoLimit; }",
        "label": "P"
    },
    "1276": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1277": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1278": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1279": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1280": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1281": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // FIXME if (0 <= position.x() && position.x() < gameMap.getMaxWidth() && 0 <= position.y() && position.y() < gameMap.getMaxHeight()) return entityArray[position.x()][position.y()]; return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1282": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // FIXME if (0 <= position.x() && position.x() < gameMap.getMaxWidth() && 0 <= position.y() && position.y() < gameMap.getMaxHeight()) return entityArray[position.x()][position.y()]; return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1283": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // FIXME return maxHeight; }",
        "label": "P"
    },
    "1284": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // FIXME return maxWidth; }",
        "label": "P"
    },
    "1285": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // FIXME return gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // FIXME if (0 <= position.x() && position.x() < gameMap.getMaxWidth() && 0 <= position.y() && position.y() < gameMap.getMaxHeight()) return entityArray[position.x()][position.y()]; return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1286": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // FIXME if (0 <= position.x() && position.x() < gameMap.getMaxWidth() && 0 <= position.y() && position.y() < gameMap.getMaxHeight()) return entityArray[position.x()][position.y()]; return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1287": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // FIXME if (0 <= position.x() && position.x() < gameMap.getMaxWidth() && 0 <= position.y() && position.y() < gameMap.getMaxHeight()) return entityArray[position.x()][position.y()]; return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1288": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // FIXME if (0 <= position.x() && position.x() < gameMap.getMaxWidth() && 0 <= position.y() && position.y() < gameMap.getMaxHeight()) return entityArray[position.x()][position.y()]; return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1289": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // FIXME final var inputLine = terminalScanner.nextLine(); final var inputWords = inputLine.split(\"\\\\s+\"); if (inputWords.length == 0) return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); return switch (inputWords[0].toLowerCase()) { case \"a\" -> new Move.Left(0); case \"s\" -> new Move.Down(0); case \"w\" -> new Move.Up(0); case \"d\" -> new Move.Right(0); case \"h\" -> new Move.Left(1); case \"j\" -> new Move.Down(1); case \"k\" -> new Move.Up(1); case \"l\" -> new Move.Right(1); case \"u\" -> new Undo(-1); case StringResources.EXIT_COMMAND_TEXT -> new Exit(-1); default -> new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); }; }",
        "label": "P"
    },
    "1290": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public void move(Position from, Position to) { // FIXME entityArray[to.x()][to.y()] = entityArray[from.x()][from.y()]; entityArray[from.x()][from.y()] = new Empty(); if (entityArray[to.x()][to.y()] instanceof Player p) playerPositions.put(p.getId(), to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1291": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public void move(Position from, Position to) { // FIXME entityArray[to.x()][to.y()] = entityArray[from.x()][from.y()]; entityArray[from.x()][from.y()] = new Empty(); if (entityArray[to.x()][to.y()] instanceof Player p) playerPositions.put(p.getId(), to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // FIXME return playerPositions.get(id); }",
        "label": "P"
    },
    "1292": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public void move(Position from, Position to) { // FIXME entityArray[to.x()][to.y()] = entityArray[from.x()][from.y()]; entityArray[from.x()][from.y()] = new Empty(); if (entityArray[to.x()][to.y()] instanceof Player p) playerPositions.put(p.getId(), to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // FIXME return playerPositions.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // FIXME if (0 <= position.x() && position.x() < gameMap.getMaxWidth() && 0 <= position.y() && position.y() < gameMap.getMaxHeight()) return entityArray[position.x()][position.y()]; return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1293": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public Optional<Integer> getUndoQuota() { // FIXME return undoLimit; }",
        "label": "P"
    },
    "1294": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // FIXME return playerPositions.values().stream().collect(Collectors.toSet()); }",
        "label": "P"
    },
    "1295": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public void move(Position from, Position to) { // FIXME entityArray[to.x()][to.y()] = entityArray[from.x()][from.y()]; entityArray[from.x()][from.y()] = new Empty(); if (entityArray[to.x()][to.y()] instanceof Player p) playerPositions.put(p.getId(), to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // FIXME Entity[][] copy = new Entity[gameMap.getMaxWidth()][gameMap.getMaxHeight()]; for (int x = 0; x < gameMap.getMaxWidth(); ++x) for (int y = 0; y < gameMap.getMaxHeight(); ++y) copy[x][y] = entityArray[x][y]; checkpointStack.push(copy); } public void undo() { // FIXME if (undoLimit.isPresent() && !checkpointStack.isEmpty()) undoLimit = Optional.of(undoLimit.get() - 1); playerPositions.clear(); if (!checkpointStack.isEmpty()) checkpointStack.pop(); final Function<Position, Entity> getSaved = checkpointStack.isEmpty() ? (Position p) -> gameMap.getEntity(p) : (Position p) -> checkpointStack.peek()[p.x()][p.y()]; for (int x = 0; x < gameMap.getMaxWidth(); ++x) for (int y = 0; y < gameMap.getMaxHeight(); ++y) { entityArray[x][y] = getSaved.apply(Position.of(x, y)); if (entityArray[x][y] instanceof Player p) playerPositions.put(p.getId(), Position.of(x, y)); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // FIXME return playerPositions.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // FIXME if (0 <= position.x() && position.x() < gameMap.getMaxWidth() && 0 <= position.y() && position.y() < gameMap.getMaxHeight()) return entityArray[position.x()][position.y()]; return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // FIXME return undoLimit; }",
        "label": "P"
    },
    "1296": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public void run() { // FIXME renderingEngine.message(StringResources.GAME_READY_MESSAGE); while (!shouldStop()) { renderingEngine.render(state); if (state.getUndoQuota().isPresent()) renderingEngine .message(StringResources.UNDO_QUOTA_TEMPLATE.formatted(state.getUndoQuota().get().toString())); else renderingEngine.message(StringResources.UNDO_QUOTA_UNLIMITED); renderingEngine.message(\">>>\"); final var action = inputEngine.fetchAction(); final var result = processAction(action); if (result instanceof ActionResult.Failed f) renderingEngine.message(f.getReason()); } renderingEngine.render(state); renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (state.isWin()) renderingEngine.message(StringResources.WIN_MESSAGE); }",
        "label": "P"
    },
    "1297": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1298": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // FIXME // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1299": {
        "dataset": "COMP 3021",
        "project": "bkwak",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // FIXME this.gameMap = map; this.undoLimit = map.getUndoLimit(); this.checkpointStack = new ArrayDeque<>(); this.entityArray = new Entity[map.getMaxWidth()][map.getMaxHeight()]; this.playerPositions = new HashMap<>(); for (int x = 0; x < map.getMaxWidth(); ++x) for (int y = 0; y < map.getMaxHeight(); ++y){ this.entityArray[x][y] = map.getEntity(Position.of(x, y)); if (this.entityArray[x][y] instanceof Player p) this.playerPositions.put(p.getId(), Position.of(x, y)); } } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1300": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return this.width; } public int getMaxHeight() { return this.height; } public Optional<Integer> getUndoLimit() { // return Optional.of(this.undoLimit); return this.undoLimit < 0 ? Optional.empty() : Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "1301": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1302": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1303": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1304": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1305": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1306": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1307": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1308": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return this.height; }",
        "label": "P"
    },
    "1309": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return this.width; }",
        "label": "P"
    },
    "1310": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return originalMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1311": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1312": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1313": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1314": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); }",
        "label": "P"
    },
    "1315": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public void move(Position from, Position to) { var fromEntity = getEntity(from); var toEntity = getEntity(to); gameMap.get(from.y()).set(from.x(), toEntity); gameMap.get(to.y()).set(to.x(), fromEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1316": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public void move(Position from, Position to) { var fromEntity = getEntity(from); var toEntity = getEntity(to); gameMap.get(from.y()).set(from.x(), toEntity); gameMap.get(to.y()).set(to.x(), fromEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (int y = 0; y < getMapMaxHeight(); y++) { for (int x = 0; x < getMapMaxWidth(); x++) { var currentPosition = Position.of(x, y); var currentEntity = getEntity(currentPosition); if (currentEntity instanceof Player && ((Player) currentEntity).getId() == id) return currentPosition; } } return null; }",
        "label": "P"
    },
    "1317": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public void move(Position from, Position to) { var fromEntity = getEntity(from); var toEntity = getEntity(to); gameMap.get(from.y()).set(from.x(), toEntity); gameMap.get(to.y()).set(to.x(), fromEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (int y = 0; y < getMapMaxHeight(); y++) { for (int x = 0; x < getMapMaxWidth(); x++) { var currentPosition = Position.of(x, y); var currentEntity = getEntity(currentPosition); if (currentEntity instanceof Player && ((Player) currentEntity).getId() == id) return currentPosition; } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1318": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public Optional<Integer> getUndoQuota() { // return undoQuotaLeft < 0 ? Optional.empty() : Optional.of(undoQuotaLeft); return Optional.of(undoQuotaLeft); }",
        "label": "P"
    },
    "1319": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { Set<Position> allPlayerPositions = new HashSet<>(); for (int y = 0; y < getMapMaxHeight(); y++) { for (int x = 0; x < getMapMaxWidth(); x++) { var currentPosition = Position.of(x, y); var currentEntity = getEntity(currentPosition); if (currentEntity instanceof Player) { allPlayerPositions.add(currentPosition); } } } return allPlayerPositions; }",
        "label": "P"
    },
    "1320": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public void move(Position from, Position to) { var fromEntity = getEntity(from); var toEntity = getEntity(to); gameMap.get(from.y()).set(from.x(), toEntity); gameMap.get(to.y()).set(to.x(), fromEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { var checkpoint = copyMap(gameMap); undoStack.push(checkpoint); } public void undo() { if (undoStack.empty()) { pasteMap(copyMap(originalMap)); } else { undoStack.pop(); pasteMap(undoStack.empty() ? copyMap(originalMap) : undoStack.peek()); undoQuotaLeft--; } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { for (int y = 0; y < getMapMaxHeight(); y++) { for (int x = 0; x < getMapMaxWidth(); x++) { var currentPosition = Position.of(x, y); var currentEntity = getEntity(currentPosition); if (currentEntity instanceof Player && ((Player) currentEntity).getId() == id) return currentPosition; } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // return undoQuotaLeft < 0 ? Optional.empty() : Optional.of(undoQuotaLeft); return Optional.of(undoQuotaLeft); }",
        "label": "P"
    },
    "1321": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } } public void run() { // TODO // throw new NotImplementedException(); renderingEngine.message(GAME_READY_MESSAGE); renderingEngine.render(state); while (true) { var undoQuota = state.getUndoQuota(); if (!undoQuota.isPresent()) { renderingEngine.message(UNDO_QUOTA_TEMPLATE.formatted(UNDO_QUOTA_UNLIMITED)); } else { renderingEngine.message(UNDO_QUOTA_TEMPLATE.formatted(undoQuota.get())); } var action = inputEngine.fetchAction(); var result = processAction(action); renderingEngine.render(state); if (result instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) result).getReason()); } if (shouldStop()) { break; } } if (state.isWin()) { renderingEngine.message(WIN_MESSAGE); } else { renderingEngine.message(GAME_EXIT_MESSAGE); } }",
        "label": "P"
    },
    "1322": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } }",
        "label": "P"
    },
    "1323": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { outputSteam.println(content); }",
        "label": "P"
    },
    "1324": {
        "dataset": "COMP 3021",
        "project": "pfyan",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // this.gameMap = map; // this.originalMap = copyMap(); this.originalMap = map; this.gameMap = copyMap(map); this.undoQuotaLeft = map.getUndoLimit().get(); this.undoStack = new Stack<>(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); }",
        "label": "P"
    },
    "1325": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO ok return this.maxWidth; //throw new NotImplementedException(); } public int getMaxHeight() { // TODO ok return this.maxHeight; //throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO ok, but check if equal zero or not if(this.undoLimit >= 0){ return Optional.of(this.undoLimit); }else{ return Optional.empty(); } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1326": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1327": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1328": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1329": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1330": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1331": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO ok return this.tempMove.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1332": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO ok return this.tempMove.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1333": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO ok return this.maxHeight; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1334": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO ok return this.maxWidth; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1335": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO ok return this.destinations; //throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO ok return this.tempMove.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1336": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO ok return this.tempMove.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1337": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO ok return this.tempMove.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1338": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO ok return this.tempMove.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1339": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. String inputLine = terminalScanner.nextLine(); // TODO switch(inputLine.toUpperCase()){ case \"EXIT\" -> { return new Exit(0);} case \"U\" ->{ return new Undo(0);} case \"W\" -> { return new Move.Up(0);} case \"A\" -> { return new Move.Left(0);} case \"S\" -> { return new Move.Down(0);} case \"D\" -> { return new Move.Right(0);} case \"H\" -> { return new Move.Left(1);} case \"J\" -> { return new Move.Down(1);} case \"K\" -> { return new Move.Up(1);} case \"L\" -> { return new Move.Right(1);} default -> new InvalidInput(0,\"Invalid Input.\");} /* * WASD for player 1 and HJKL for player 2. * player ID to be deterimned by (int) casting * if invalid then throw error * */ return new InvalidInput(0,\"Should not reach here\"); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1340": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO ok //use putentity from gamemap this.tempMove.replace(to, getEntity(from)); this.tempMove.replace(from, new Empty()); changed = true; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1341": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO ok //use putentity from gamemap this.tempMove.replace(to, getEntity(from)); this.tempMove.replace(from, new Empty()); changed = true; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO ok for(int i = 1; i < getMapMaxHeight() + 1; i++){ //row for (int j = 0; j < getMapMaxWidth(); j++) { //height if(this.tempMove.get(new Position(j, i)) instanceof Player){ if(((Player) this.tempMove.get(new Position(j, i))).getId() == id) return new Position(j, i); } } } return null; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1342": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO ok //use putentity from gamemap this.tempMove.replace(to, getEntity(from)); this.tempMove.replace(from, new Empty()); changed = true; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO ok for(int i = 1; i < getMapMaxHeight() + 1; i++){ //row for (int j = 0; j < getMapMaxWidth(); j++) { //height if(this.tempMove.get(new Position(j, i)) instanceof Player){ if(((Player) this.tempMove.get(new Position(j, i))).getId() == id) return new Position(j, i); } } } return null; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO ok return this.tempMove.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1343": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO ok if(this.undoNumber >= 0){ return Optional.of(this.undoNumber); }else{ return Optional.empty(); } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1344": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO ok Set<Position> destinations = new HashSet<Position>(); for(int i = 1; i < getMapMaxHeight() + 1; i++){ //row for (int j = 0; j < getMapMaxWidth(); j++) { //height if(this.tempMove.get(new Position(j, i)) instanceof Player){ destinations.add(new Position(j,i)); } } } return destinations; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1345": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO ok //use putentity from gamemap this.tempMove.replace(to, getEntity(from)); this.tempMove.replace(from, new Empty()); changed = true; //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO ok gameHistory.add(new HashMap<Position, Entity>(this.tempMove)); changed = false; //throw new NotImplementedException(); } public void undo(){ // TODO.... IF OPEN GAME THEN UNDO WHAT HAPPEN? if(!changed){ if(gameHistory.size() == 1){ //popping actual checkpoints tempMove = new HashMap<Position, Entity>(gameHistory.peekLast()); changed = true; }else { this.gameHistory.removeLast(); tempMove = new HashMap<Position, Entity>(gameHistory.peekLast()); if(gameHistory.size() == 1){ //popping actual checkpoints changed = true; } } if(undoNumber != -1){ undoNumber -= 1; } }else{ //revert to checkpoint tempMove = new HashMap<Position, Entity>(gameHistory.peekLast()); } //throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO ok for(int i = 1; i < getMapMaxHeight() + 1; i++){ //row for (int j = 0; j < getMapMaxWidth(); j++) { //height if(this.tempMove.get(new Position(j, i)) instanceof Player){ if(((Player) this.tempMove.get(new Position(j, i))).getId() == id) return new Position(j, i); } } } return null; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO ok return this.tempMove.get(position); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO ok if(this.undoNumber >= 0){ return Optional.of(this.undoNumber); }else{ return Optional.empty(); } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1346": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO ok if(gameState.getAllPlayerPositions().size()>2){ throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } // Check the number of players //throw new NotImplementedException(); } public void run() { // TODO renderingEngine.message(\"Sokoban game is ready.\"); renderingEngine.render(this.state); if(this.state.getUndoQuota().equals(Optional.empty())){ renderingEngine.message(\"Unlimited\"); }else{ renderingEngine.message(\"Undo Quota: \" + this.state.getUndoQuota().get()); } while(!this.shouldStop()) { Action userInput = inputEngine.fetchAction(); ActionResult result = this.processAction(userInput); if(result instanceof ActionResult.Failed){ renderingEngine.message(((ActionResult.Failed) result).getReason()); } if(this.state.isWin()){ break; } renderingEngine.render(this.state); if(this.state.getUndoQuota().equals(Optional.empty())){ renderingEngine.message(\"Unlimited\"); }else{ renderingEngine.message(\"Undo Quota: \" + this.state.getUndoQuota().get()); } } renderingEngine.message(\"Game exits.\"); if(this.state.isWin()){ renderingEngine.message(\"You win.\"); } //1. render map //2. get user input (fetch action) //3. check if valid //4. render map // // //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1347": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO ok if(gameState.getAllPlayerPositions().size()>2){ throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } // Check the number of players //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1348": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO need double check outputSteam.print(content); outputSteam.print('\\n'); // Hint: System.out is also a PrintStream. //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1349": {
        "dataset": "COMP 3021",
        "project": "jloac",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO ok but is the undonumber ok? this.gameHistory = new ArrayDeque<Map<Position, Entity>>(); if(map.getUndoLimit().isEmpty()){ this.undoNumber = -1; }else{ this.undoNumber = map.getUndoLimit().get(); } this.destinations = map.getDestinations(); this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); //throw new RuntimeException(String.valueOf(map.getMapLocation().size())); this.gameHistory.add(map.getMapLocation()); this.tempMove = new HashMap<Position, Entity>(gameHistory.peek()); //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1350": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "1351": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1352": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1353": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1354": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1355": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1356": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(position.x() >= maxWidth || position.y() >= maxHeight){ return null; }else{ return entities[position.y()][position.x()]; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1357": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(position.x() >= maxWidth || position.y() >= maxHeight){ return null; }else{ return entities[position.y()][position.x()]; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1358": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "1359": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "1360": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(position.x() >= maxWidth || position.y() >= maxHeight){ return null; }else{ return entities[position.y()][position.x()]; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1361": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(position.x() >= maxWidth || position.y() >= maxHeight){ return null; }else{ return entities[position.y()][position.x()]; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1362": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(position.x() >= maxWidth || position.y() >= maxHeight){ return null; }else{ return entities[position.y()][position.x()]; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1363": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(position.x() >= maxWidth || position.y() >= maxHeight){ return null; }else{ return entities[position.y()][position.x()]; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1364": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); Action action = switch (inputLine.toLowerCase()){ case \"w\" -> new Move.Up(0); case \"a\" -> new Move.Left(0); case \"s\" -> new Move.Down(0); case \"d\" -> new Move.Right(0); case \"k\" -> new Move.Up(1); case \"h\" -> new Move.Left(1); case \"j\" -> new Move.Down(1); case \"l\" -> new Move.Right(1); case \"u\" -> new Undo(0); case \"exit\" -> new Exit(0); case default -> new InvalidInput(0, \"error\"); }; // TODO return action; }",
        "label": "P"
    },
    "1365": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public void move(Position from, Position to) { // TODO var temp = this.entities[from.y()][from.x()]; this.entities[from.y()][from.x()] = this.entities[to.y()][to.x()]; this.entities[to.y()][to.x()] = temp; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1366": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public void move(Position from, Position to) { // TODO var temp = this.entities[from.y()][from.x()]; this.entities[from.y()][from.x()] = this.entities[to.y()][to.x()]; this.entities[to.y()][to.x()] = temp; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < this.maxHeight; i++){ for(int j = 0; j < this.maxWidth; j++){ var entry = this.entities[i][j]; if(entry instanceof Player player && player.getId() == id){ return Position.of(j, i); } } } return null; }",
        "label": "P"
    },
    "1367": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public void move(Position from, Position to) { // TODO var temp = this.entities[from.y()][from.x()]; this.entities[from.y()][from.x()] = this.entities[to.y()][to.x()]; this.entities[to.y()][to.x()] = temp; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < this.maxHeight; i++){ for(int j = 0; j < this.maxWidth; j++){ var entry = this.entities[i][j]; if(entry instanceof Player player && player.getId() == id){ return Position.of(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(position.x() >= maxWidth || position.y() >= maxHeight){ return null; }else{ return entities[position.y()][position.x()]; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1368": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public Optional<Integer> getUndoQuota() { // TODO if(undoLimit.get() == -1){ return Optional.empty(); } return this.undoLimit; }",
        "label": "P"
    },
    "1369": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> playersPosition = new HashSet<>(); for(int i = 0; i < this.maxHeight; i++){ for(int j = 0; j < this.maxWidth; j++){ var entry = this.entities[i][j]; if(entry instanceof Player player){ playersPosition.add(Position.of(j, i)); } } } return playersPosition; }",
        "label": "P"
    },
    "1370": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public void move(Position from, Position to) { // TODO var temp = this.entities[from.y()][from.x()]; this.entities[from.y()][from.x()] = this.entities[to.y()][to.x()]; this.entities[to.y()][to.x()] = temp; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO Entity[][] entities = new Entity[maxHeight][maxWidth]; for(int i = 0; i < this.maxHeight; i++){ for(int j = 0; j < this.maxWidth; j++){ var entry = this.entities[i][j]; entities[i][j] = entry; } } this.checkpointEntities.push(entities); } public void undo() { // TODO if(this.checkpointEntities.size() <= 1){ this.entities = this.checkpointEntities.pop(); this.checkpoint(); }else{ if(this.undoLimit.get() > 0) this.undoLimit = Optional.of(this.undoLimit.get() - 1); this.checkpointEntities.pop(); this.entities = this.checkpointEntities.pop(); this.checkpoint(); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < this.maxHeight; i++){ for(int j = 0; j < this.maxWidth; j++){ var entry = this.entities[i][j]; if(entry instanceof Player player && player.getId() == id){ return Position.of(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(position.x() >= maxWidth || position.y() >= maxHeight){ return null; }else{ return entities[position.y()][position.x()]; } } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if(undoLimit.get() == -1){ return Optional.empty(); } return this.undoLimit; }",
        "label": "P"
    },
    "1371": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players var playersCount = gameState.getAllPlayerPositions().size(); if(playersCount > 2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); this.renderingEngine.message(\"Sokoban game is ready.\"); this.renderingEngine.render(this.state); var undoQuota = state.getUndoQuota(); this.renderingEngine.message(\"Undo Quota: \" + (undoQuota.isPresent() ? undoQuota.get() : \"Unlimited\")); } public void run() { // TODO while(true){ var actionResult = this.processAction(inputEngine.fetchAction()); if(this.shouldStop()){ this.renderingEngine.render(this.state); this.renderingEngine.message(\"Game exits.\"); if(this.state.isWin()){ this.renderingEngine.message(\"You Win.\"); } return; } var undoQuota = state.getUndoQuota(); if(actionResult instanceof ActionResult.Failed f){ this.renderingEngine.message(f.getReason()); this.renderingEngine.render(this.state); this.renderingEngine.message(\"Undo Quota: \" + (undoQuota.isPresent() ? undoQuota.get() : \"Unlimited\")); continue; }else { this.renderingEngine.render(this.state); this.renderingEngine.message(\"Undo Quota: \" + (undoQuota.isPresent() ? undoQuota.get() : \"Unlimited\")); } } }",
        "label": "P"
    },
    "1372": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players var playersCount = gameState.getAllPlayerPositions().size(); if(playersCount > 2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); this.renderingEngine.message(\"Sokoban game is ready.\"); this.renderingEngine.render(this.state); var undoQuota = state.getUndoQuota(); this.renderingEngine.message(\"Undo Quota: \" + (undoQuota.isPresent() ? undoQuota.get() : \"Unlimited\")); }",
        "label": "P"
    },
    "1373": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1374": {
        "dataset": "COMP 3021",
        "project": "ttmiao",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO // this.map = map; this.maxHeight = map.getMaxHeight(); this.maxWidth = map.getMaxWidth(); this.entities = new Entity[maxHeight][maxWidth]; for (int y = 0; y < this.maxHeight; y++) { for (int x = 0; x < this.maxWidth; x++) { final var entity = map.getEntity(Position.of(x, y)); this.entities[y][x] = entity; } } this.playerIds = map.getPlayerIds(); this.undoLimit = map.getUndoLimit(); this.destinations = map.getDestinations(); this.checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1375": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return this.maxWidth; } public int getMaxHeight() { return this.maxHeight; } public Optional<Integer> getUndoLimit() { return this.undoLimit; }",
        "label": "P"
    },
    "1376": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1377": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1378": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1379": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1380": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1381": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return currentState.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1382": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return currentState.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1383": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return this.maxHeight; }",
        "label": "P"
    },
    "1384": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return this.maxWidth; }",
        "label": "P"
    },
    "1385": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return currentState.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return currentState.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1386": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return currentState.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1387": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return currentState.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1388": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return currentState.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1389": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine().toUpperCase(); switch (inputLine) { case \"A\": return new Move.Left(0); case \"D\": return new Move.Right(0); case \"W\": return new Move.Up(0); case \"S\": return new Move.Down(0); case \"H\": return new Move.Left(0); case \"L\": return new Move.Right(0); case \"K\": return new Move.Up(0); case \"J\": return new Move.Down(0); case \"U\": return new Undo(-1); case \"EXIT\": return new Exit(-1); default: return new InvalidInput(-1, \"\"); } }",
        "label": "P"
    },
    "1390": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public void move(Position from, Position to) { Entity fromEntity = currentState.getEntity(from); if (fromEntity instanceof Box) { currentState.changeBoxPosition(from, to, ((Box) fromEntity).getPlayerId()); } else if (fromEntity instanceof Player) { currentState.setPlayerPositionById(((Player) fromEntity).getId(), to); } currentState.putEntity(to, fromEntity); currentState.putEntity(from, currentState.getEntity(to)); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1391": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public void move(Position from, Position to) { Entity fromEntity = currentState.getEntity(from); if (fromEntity instanceof Box) { currentState.changeBoxPosition(from, to, ((Box) fromEntity).getPlayerId()); } else if (fromEntity instanceof Player) { currentState.setPlayerPositionById(((Player) fromEntity).getId(), to); } currentState.putEntity(to, fromEntity); currentState.putEntity(from, currentState.getEntity(to)); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return currentState.getPlayerPositionbyId(id); }",
        "label": "P"
    },
    "1392": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public void move(Position from, Position to) { Entity fromEntity = currentState.getEntity(from); if (fromEntity instanceof Box) { currentState.changeBoxPosition(from, to, ((Box) fromEntity).getPlayerId()); } else if (fromEntity instanceof Player) { currentState.setPlayerPositionById(((Player) fromEntity).getId(), to); } currentState.putEntity(to, fromEntity); currentState.putEntity(from, currentState.getEntity(to)); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return currentState.getPlayerPositionbyId(id); } public @Nullable Entity getEntity(@NotNull Position position) { return currentState.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1393": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public Optional<Integer> getUndoQuota() { return this.undoQuota; }",
        "label": "P"
    },
    "1394": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { return currentState.getAllPlayerPositions(); }",
        "label": "P"
    },
    "1395": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public void move(Position from, Position to) { Entity fromEntity = currentState.getEntity(from); if (fromEntity instanceof Box) { currentState.changeBoxPosition(from, to, ((Box) fromEntity).getPlayerId()); } else if (fromEntity instanceof Player) { currentState.setPlayerPositionById(((Player) fromEntity).getId(), to); } currentState.putEntity(to, fromEntity); currentState.putEntity(from, currentState.getEntity(to)); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { GameMap newState = new GameMap(currentState); checkpointStates.add(0, newState); } public void undo() { if (checkpointStates.isEmpty()) { currentState = new GameMap(gameMap); } else { checkpointStates.remove(0); if (checkpointStates.isEmpty()) { currentState = new GameMap(gameMap); } else { currentState = checkpointStates.remove(0); } } undoQuota = Optional.of(undoQuota.get() - 1); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { return currentState.getPlayerPositionbyId(id); } public @Nullable Entity getEntity(@NotNull Position position) { return currentState.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { return this.undoQuota; }",
        "label": "P"
    },
    "1396": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"There are more than two players in the map\"); } this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; } public void run() { // TODO renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(state); while (!super.shouldStop()) { Action action = inputEngine.fetchAction(); String undoQuota; if (state.getUndoQuota().isEmpty()) { undoQuota = StringResources.UNDO_QUOTA_UNLIMITED; } else { undoQuota = Integer.toString(state.getUndoQuota().get()); } renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, undoQuota)); ActionResult actionResult = super.processAction(action); if (actionResult instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) actionResult).getReason()); } else { if (state.isWin()) { renderingEngine.message(StringResources.WIN_MESSAGE); } } renderingEngine.render(state); } renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); }",
        "label": "P"
    },
    "1397": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"There are more than two players in the map\"); } this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; }",
        "label": "P"
    },
    "1398": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { outputSteam.println(content); }",
        "label": "P"
    },
    "1399": {
        "dataset": "COMP 3021",
        "project": "slmaaa",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.gameMap = map; this.undoQuota = map.getUndoLimit(); this.checkpointStates = new ArrayList<GameMap>(map.getUndoLimit().get()); this.currentState = new GameMap(map); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1400": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO if (false) { getPlayerIds(); putEntity(new Position(0, 0), new Wall()); } return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "1401": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1402": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1403": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1404": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1405": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1406": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char target = parsedString[position.y()].charAt(position.x()); if (target == '#') return new Wall(); else if (target == '.' || target == '@') return new Empty(); else if (target >= 'a' && target <= 'z') return new Box((int)(target - 'a')); else if (target >= 'A' && target <= 'Z') return new Player((int)(target - 'A')); else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1407": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char target = parsedString[position.y()].charAt(position.x()); if (target == '#') return new Wall(); else if (target == '.' || target == '@') return new Empty(); else if (target >= 'a' && target <= 'z') return new Box((int)(target - 'a')); else if (target >= 'A' && target <= 'Z') return new Player((int)(target - 'A')); else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1408": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "1409": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO if (false) { getPlayerIds(); putEntity(new Position(0, 0), new Wall()); } return this.maxWidth; }",
        "label": "P"
    },
    "1410": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char target = parsedString[position.y()].charAt(position.x()); if (target == '#') return new Wall(); else if (target == '.' || target == '@') return new Empty(); else if (target >= 'a' && target <= 'z') return new Box((int)(target - 'a')); else if (target >= 'A' && target <= 'Z') return new Player((int)(target - 'A')); else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1411": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char target = parsedString[position.y()].charAt(position.x()); if (target == '#') return new Wall(); else if (target == '.' || target == '@') return new Empty(); else if (target >= 'a' && target <= 'z') return new Box((int)(target - 'a')); else if (target >= 'A' && target <= 'Z') return new Player((int)(target - 'A')); else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1412": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char target = parsedString[position.y()].charAt(position.x()); if (target == '#') return new Wall(); else if (target == '.' || target == '@') return new Empty(); else if (target >= 'a' && target <= 'z') return new Box((int)(target - 'a')); else if (target >= 'A' && target <= 'Z') return new Player((int)(target - 'A')); else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1413": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char target = parsedString[position.y()].charAt(position.x()); if (target == '#') return new Wall(); else if (target == '.' || target == '@') return new Empty(); else if (target >= 'a' && target <= 'z') return new Box((int)(target - 'a')); else if (target >= 'A' && target <= 'Z') return new Player((int)(target - 'A')); else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1414": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO if (inputLine.equals(\"exit\")) { return new Exit(0); } else if (inputLine.equals(\"u\") || inputLine.equals(\"U\")) { return new Undo(0); } else if (inputLine.equals(\"a\") || inputLine.equals(\"A\")) { return new Move.Left(0); } else if ( inputLine.equals(\"h\") || inputLine.equals(\"H\")) { return new Move.Left(1); } else if (inputLine.equals(\"d\") || inputLine.equals(\"D\")) { return new Move.Right(0); } else if(inputLine.equals(\"l\") || inputLine.equals(\"L\")) { return new Move.Right(1); } else if (inputLine.equals(\"w\") || inputLine.equals(\"W\")) { return new Move.Up(0); } else if (inputLine.equals(\"k\") || inputLine.equals(\"K\")) { return new Move.Up(1); } else if (inputLine.equals(\"s\") || inputLine.equals(\"S\")) { return new Move.Down(0); } else if (inputLine.equals(\"j\") || inputLine.equals(\"J\")) { return new Move.Down(1); } else { return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "1415": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public void move(Position from, Position to) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char objectToBeMoved = parsedString[from.y()].charAt(from.x()); String newfromchar = \".\"; if (this.destinations.contains(from)) { newfromchar = \"@\"; } else { newfromchar = \".\"; } parsedString[from.y()] = parsedString[from.y()].substring(0, from.x()) + newfromchar + parsedString[from.y()].substring(from.x() + 1); parsedString[to.y()] = parsedString[to.y()].substring(0, to.x()) + objectToBeMoved + parsedString[to.y()].substring(to.x() + 1); String newMapInfo = null; for (int i=0; i<parsedString.length; i++) { if (newMapInfo == null) newMapInfo = parsedString[i]; else newMapInfo = newMapInfo + '\\n' + parsedString[i]; } this.mapInfo = newMapInfo; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1416": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public void move(Position from, Position to) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char objectToBeMoved = parsedString[from.y()].charAt(from.x()); String newfromchar = \".\"; if (this.destinations.contains(from)) { newfromchar = \"@\"; } else { newfromchar = \".\"; } parsedString[from.y()] = parsedString[from.y()].substring(0, from.x()) + newfromchar + parsedString[from.y()].substring(from.x() + 1); parsedString[to.y()] = parsedString[to.y()].substring(0, to.x()) + objectToBeMoved + parsedString[to.y()].substring(to.x() + 1); String newMapInfo = null; for (int i=0; i<parsedString.length; i++) { if (newMapInfo == null) newMapInfo = parsedString[i]; else newMapInfo = newMapInfo + '\\n' + parsedString[i]; } this.mapInfo = newMapInfo; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); for (int i=0; i<parsedString.length; i++) { for (int j=0; j<parsedString[i].length(); j++){ if ((int)(parsedString[i].charAt(j) - 'A') == id){ return new Position(j, i); } } } return new Position(0, 0); }",
        "label": "P"
    },
    "1417": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public void move(Position from, Position to) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char objectToBeMoved = parsedString[from.y()].charAt(from.x()); String newfromchar = \".\"; if (this.destinations.contains(from)) { newfromchar = \"@\"; } else { newfromchar = \".\"; } parsedString[from.y()] = parsedString[from.y()].substring(0, from.x()) + newfromchar + parsedString[from.y()].substring(from.x() + 1); parsedString[to.y()] = parsedString[to.y()].substring(0, to.x()) + objectToBeMoved + parsedString[to.y()].substring(to.x() + 1); String newMapInfo = null; for (int i=0; i<parsedString.length; i++) { if (newMapInfo == null) newMapInfo = parsedString[i]; else newMapInfo = newMapInfo + '\\n' + parsedString[i]; } this.mapInfo = newMapInfo; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); for (int i=0; i<parsedString.length; i++) { for (int j=0; j<parsedString[i].length(); j++){ if ((int)(parsedString[i].charAt(j) - 'A') == id){ return new Position(j, i); } } } return new Position(0, 0); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char target = parsedString[position.y()].charAt(position.x()); if (target == '#') return new Wall(); else if (target == '.' || target == '@') return new Empty(); else if (target >= 'a' && target <= 'z') return new Box((int)(target - 'a')); else if (target >= 'A' && target <= 'Z') return new Player((int)(target - 'A')); else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1418": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public Optional<Integer> getUndoQuota() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "1419": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> playsPosition = new HashSet<Position>(); String[] parsedString = mapInfo.split(\"\\n\"); for (int i=0; i<parsedString.length; i++) { for (int j=0; j<parsedString[i].length(); j++){ if (parsedString[i].charAt(j) >= 'A' && parsedString[i].charAt(j) <= 'Z'){ playsPosition.add(new Position(j, i)); } } } return playsPosition; }",
        "label": "P"
    },
    "1420": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public void move(Position from, Position to) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char objectToBeMoved = parsedString[from.y()].charAt(from.x()); String newfromchar = \".\"; if (this.destinations.contains(from)) { newfromchar = \"@\"; } else { newfromchar = \".\"; } parsedString[from.y()] = parsedString[from.y()].substring(0, from.x()) + newfromchar + parsedString[from.y()].substring(from.x() + 1); parsedString[to.y()] = parsedString[to.y()].substring(0, to.x()) + objectToBeMoved + parsedString[to.y()].substring(to.x() + 1); String newMapInfo = null; for (int i=0; i<parsedString.length; i++) { if (newMapInfo == null) newMapInfo = parsedString[i]; else newMapInfo = newMapInfo + '\\n' + parsedString[i]; } this.mapInfo = newMapInfo; } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO this.mapInfoSave.add(this.mapInfo); } public void undo() { // TODO if (this.undoLimit > 0 || this.undoLimit == -1) { if (this.mapInfoSave.isEmpty()) { this.mapInfo = this.initMapInfo; } else if (this.mapInfoSave.size() == 1) { this.mapInfo = this.initMapInfo; this.mapInfoSave.remove(this.mapInfoSave.size()-1); if (this.undoLimit > 0 ) this.undoLimit--; } else { this.mapInfo = this.mapInfoSave.get(this.mapInfoSave.size() - 2); this.mapInfoSave.remove(this.mapInfoSave.size()-1); if (this.undoLimit > 0 ) this.undoLimit--; } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); for (int i=0; i<parsedString.length; i++) { for (int j=0; j<parsedString[i].length(); j++){ if ((int)(parsedString[i].charAt(j) - 'A') == id){ return new Position(j, i); } } } return new Position(0, 0); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO String[] parsedString = mapInfo.split(\"\\n\"); char target = parsedString[position.y()].charAt(position.x()); if (target == '#') return new Wall(); else if (target == '.' || target == '@') return new Empty(); else if (target >= 'a' && target <= 'z') return new Box((int)(target - 'a')); else if (target >= 'A' && target <= 'Z') return new Player((int)(target - 'A')); else return null; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "1421": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players this.state1 = gameState; numberOfPlayers = gameState.getAllPlayerPositions().size(); if (numberOfPlayers > 2) { throw new IllegalArgumentException(); } } public void run() { // TODO this.renderingEngine.message(StringResources.GAME_READY_MESSAGE); System.out.println(StringResources.GAME_READY_MESSAGE); this.renderingEngine.render(this.state1); System.out.println(this.state1.mapInfo); var quota = this.state1.getUndoQuota(); if (quota.isPresent()) { if (quota.get() == -1) { this.renderingEngine.message(UNDO_QUOTA_UNLIMITED); System.out.println(UNDO_QUOTA_UNLIMITED); } else { this.renderingEngine.message(String.format(UNDO_QUOTA_TEMPLATE, quota.get())); System.out.println(String.format(UNDO_QUOTA_TEMPLATE, quota.get())); } } this.renderingEngine.message(\">>>\"); System.out.println(\">>>\"); while (true) { var action = this.inputEngine.fetchAction(); var actionresult = this.processAction(action); if (actionresult instanceof ActionResult.Failed) { this.renderingEngine.message(((ActionResult.Failed) actionresult).getReason()); System.out.println(((ActionResult.Failed) actionresult).getReason()); } this.renderingEngine.render(this.state1); System.out.println(this.state1.mapInfo); quota = this.state1.getUndoQuota(); if (quota.isPresent()) { if (quota.get() == -1) { this.renderingEngine.message(UNDO_QUOTA_UNLIMITED); System.out.println(UNDO_QUOTA_UNLIMITED); } else { this.renderingEngine.message(String.format(UNDO_QUOTA_TEMPLATE, quota.get())); System.out.println(String.format(UNDO_QUOTA_TEMPLATE, quota.get())); } } this.renderingEngine.message(\">>>\"); System.out.println(\">>>\"); if (this.shouldStop()) { this.renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); System.out.println(StringResources.GAME_EXIT_MESSAGE); if (this.state1.isWin()) { this.renderingEngine.message(StringResources.WIN_MESSAGE); System.out.println(StringResources.WIN_MESSAGE); } return; } } }",
        "label": "P"
    },
    "1422": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players this.state1 = gameState; numberOfPlayers = gameState.getAllPlayerPositions().size(); if (numberOfPlayers > 2) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "1423": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.print(content + System.lineSeparator()); }",
        "label": "P"
    },
    "1424": {
        "dataset": "COMP 3021",
        "project": "cywongci",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.maxWidth = map.maxWidth; this.maxHeight = map.maxHeight; this.destinations = map.destinations; this.undoLimit = map.undoLimit; this.mapInfo = map.mapInfo; this.initMapInfo = map.mapInfo; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1425": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return this.maxWidth; } public int getMaxHeight() { return this.maxHeight; } public Optional<Integer> getUndoLimit() { return this.undoLimit; }",
        "label": "P"
    },
    "1426": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1427": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1428": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1429": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1430": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1431": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.currentGameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1432": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.currentGameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1433": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return this.maxHeight; }",
        "label": "P"
    },
    "1434": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return this.maxWidth; }",
        "label": "P"
    },
    "1435": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return this.currentGameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return this.currentGameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1436": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.currentGameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1437": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.currentGameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1438": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return this.currentGameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1439": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { Pattern movesPattern = Pattern.compile(\"^(?<action>[ASWDaswdHJKLhjkl])$\"); String moveChars = \"ASWDaswdHJKLhjkl\"; Integer initiator = -1; final String inputLine = this.terminalScanner.nextLine(); if (inputLine.length() == StringResources.EXIT_COMMAND_TEXT.length() && inputLine.toLowerCase().contains(StringResources.EXIT_COMMAND_TEXT)){ return new Exit(initiator); } else if (inputLine.length() == 1 && Character.toLowerCase(inputLine.charAt(0)) == 'u'){ return new Undo(initiator); } else if (Pattern.matches(movesPattern.pattern(), inputLine)){ char c = inputLine.charAt(0); for (int i = 0; i < moveChars.length();++i){ initiator = i < moveChars.length()/2? 0: 1; if (moveChars.charAt(i) == c){ switch (i % 4) { case 0 -> { return new Move.Left(initiator); } case 1 -> { return new Move.Down(initiator); } case 2 -> { return new Move.Up(initiator); } case 3 -> { return new Move.Right(initiator); } default -> throw new ShouldNotReachException(); } } } } return new InvalidInput(initiator, INVALID_INPUT_MESSAGE); }",
        "label": "P"
    },
    "1440": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public void move(Position from, Position to) { this.currentGameMap.move(from, to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1441": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public void move(Position from, Position to) { this.currentGameMap.move(from, to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return this.currentGameMap.getPlayerPositionById(id); }",
        "label": "P"
    },
    "1442": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public void move(Position from, Position to) { this.currentGameMap.move(from, to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return this.currentGameMap.getPlayerPositionById(id); } public @Nullable Entity getEntity(@NotNull Position position) { return this.currentGameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1443": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public Optional<Integer> getUndoQuota() { return this.undoQuota; }",
        "label": "P"
    },
    "1444": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { return this.currentGameMap.getPlayerPositions(); }",
        "label": "P"
    },
    "1445": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public void move(Position from, Position to) { this.currentGameMap.move(from, to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { this.checkpoints.push(new GameMap(this.currentGameMap)); } public void undo() { if (this.isUndoQuota() && checkpoints.size() == 1){ this.currentGameMap = new GameMap(this.checkpoints.peek()); return; } else if (this.decrementUndoQuota()){ this.popCheckPoints(); this.currentGameMap = new GameMap(this.checkpoints.peek()); return; } throw new ShouldNotReachException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { return this.currentGameMap.getPlayerPositionById(id); } public @Nullable Entity getEntity(@NotNull Position position) { return this.currentGameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { return this.undoQuota; }",
        "label": "P"
    },
    "1446": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); if (gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(StringResources.MORE_THAN_2_PLAYERS); } this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; } public void run() { this.renderingEngine.message(StringResources.GAME_READY_MESSAGE); this.renderingEngine.render(this.state); this.renderingEngine.message(\"\"); while (!this.shouldStop()){ // 1. print remaining quota and input arrows String quotaString; if (this.state.getUndoQuota().isPresent() && this.state.getUndoQuota().get() != -1){ quotaString = String.format(StringResources.UNDO_QUOTA_TEMPLATE,this.state.getUndoQuota().get()); } else{ quotaString = StringResources.UNDO_QUOTA_UNLIMITED; } this.renderingEngine.message(quotaString); this.renderingEngine.message(StringResources.GET_INPUT_ARROWS); // 2. get action and process it Action action = this.inputEngine.fetchAction(); ActionResult actionResult = this.processAction(action); if (actionResult instanceof ActionResult.Failed actionFailed){ this.renderingEngine.message(actionFailed.getReason()); } // 3. print state this.renderingEngine.render(this.state); this.renderingEngine.message(\"\"); } this.renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (this.state.isWin()) { this.renderingEngine.message(StringResources.WIN_MESSAGE); } }",
        "label": "P"
    },
    "1447": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); if (gameState.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(StringResources.MORE_THAN_2_PLAYERS); } this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; }",
        "label": "P"
    },
    "1448": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputStream) { this.outputStream = outputStream; } public void message(@NotNull String content) { outputStream.print(content +System.lineSeparator()); }",
        "label": "P"
    },
    "1449": {
        "dataset": "COMP 3021",
        "project": "akuantay",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.currentGameMap = new GameMap(map); this.checkpoints.push(new GameMap(map)); this.undoQuota = map.getUndoLimit(); } public TerminalRenderingEngine(PrintStream outputStream) { this.outputStream = outputStream; } public TerminalRenderingEngine(PrintStream outputStream) { this.outputStream = outputStream; }",
        "label": "P"
    },
    "1450": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { if (undoLimit != -1) { return Optional.of(undoLimit); } return Optional.empty(); }",
        "label": "P"
    },
    "1451": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1452": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1453": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1454": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1455": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1456": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return curMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1457": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return curMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1458": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "1459": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "1460": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return originalMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return curMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1461": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return curMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1462": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return curMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1463": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return curMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1464": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine().toLowerCase(); return switch (inputLine) { case \"u\", \"U\" -> new Undo(0); case \"w\", \"W\" -> new Move.Up(0); case \"a\", \"A\" -> new Move.Left(0); case \"s\", \"S\" -> new Move.Down(0); case \"d\", \"D\" -> new Move.Right(0); case \"h\", \"H\" -> new Move.Left(1); case \"j\", \"J\" -> new Move.Down(1); case \"k\", \"K\" -> new Move.Up(1); case \"l\", \"L\" -> new Move.Right(1); case StringResources.EXIT_COMMAND_TEXT -> new Exit(0); default -> new InvalidInput(0, \"Invalid input!\"); }; }",
        "label": "P"
    },
    "1465": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public void move(Position from, Position to) { isUndoThisRound = false; isFirstTimeHitEmpty = false; prevMapBeforeOneMove = new HashMap<>(); prevMapBeforeOneMove.putAll(curMap); var temp = curMap.get(to); curMap.put(to, curMap.get(from)); curMap.put(from, temp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1466": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public void move(Position from, Position to) { isUndoThisRound = false; isFirstTimeHitEmpty = false; prevMapBeforeOneMove = new HashMap<>(); prevMapBeforeOneMove.putAll(curMap); var temp = curMap.get(to); curMap.put(to, curMap.get(from)); curMap.put(from, temp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { //Early return if the Player is NOT contained in the original map if (!originalMap.getPlayerIds().contains(id)) { return null; } //Loop thorugh the map for (Map.Entry<Position, Entity> entry : curMap.entrySet()) { if (entry.getValue() instanceof Player) { Player player = (Player) entry.getValue(); if (player.getId() == id) { return entry.getKey(); } } } return null; }",
        "label": "P"
    },
    "1467": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public void move(Position from, Position to) { isUndoThisRound = false; isFirstTimeHitEmpty = false; prevMapBeforeOneMove = new HashMap<>(); prevMapBeforeOneMove.putAll(curMap); var temp = curMap.get(to); curMap.put(to, curMap.get(from)); curMap.put(from, temp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { //Early return if the Player is NOT contained in the original map if (!originalMap.getPlayerIds().contains(id)) { return null; } //Loop thorugh the map for (Map.Entry<Position, Entity> entry : curMap.entrySet()) { if (entry.getValue() instanceof Player) { Player player = (Player) entry.getValue(); if (player.getId() == id) { return entry.getKey(); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return curMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1468": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public Optional<Integer> getUndoQuota() { return undoQuota; }",
        "label": "P"
    },
    "1469": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { Set<Position> pos = new HashSet<>(); Set<Integer> playerIds = originalMap.getPlayerIds(); for (var i : playerIds) { Position p = getPlayerPositionById(i); if (p != null) { pos.add(p); } } return pos; }",
        "label": "P"
    },
    "1470": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public void move(Position from, Position to) { isUndoThisRound = false; isFirstTimeHitEmpty = false; prevMapBeforeOneMove = new HashMap<>(); prevMapBeforeOneMove.putAll(curMap); var temp = curMap.get(to); curMap.put(to, curMap.get(from)); curMap.put(from, temp); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { var prevMap = new HashMap<Position, Entity>(); prevMap.putAll(curMap); prevMaps.add(prevMap); } public void undo() { if (prevMaps.empty()) { if (isUndoThisRound && !isFirstTimeHitEmpty) { if (undoQuota.isPresent()) { undoQuota = Optional.of(undoQuota.get()-1); } isFirstTimeHitEmpty = true; } curMap = new HashMap<>(); curMap.putAll(originalMap.getMap()); return; } if (!isUndoThisRound) { prevMaps.pop(); isUndoThisRound = true; } if (undoQuota.isPresent()) { undoQuota = Optional.of(undoQuota.get() - 1); } if (prevMaps.empty()) { curMap = new HashMap<>(); curMap.putAll(originalMap.getMap()); return; } curMap = new HashMap<Position, Entity>(); curMap.putAll(prevMaps.pop()); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { //Early return if the Player is NOT contained in the original map if (!originalMap.getPlayerIds().contains(id)) { return null; } //Loop thorugh the map for (Map.Entry<Position, Entity> entry : curMap.entrySet()) { if (entry.getValue() instanceof Player) { Player player = (Player) entry.getValue(); if (player.getId() == id) { return entry.getKey(); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return curMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { return undoQuota; }",
        "label": "P"
    },
    "1471": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"There are more than two players in the map!\"); } } public void run() { renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(state); while (!shouldStop()) { renderingEngine.message(StringResources.UNDO_QUOTA_TEMPLATE); if (state.getUndoQuota().isPresent()) { renderingEngine.message(state.getUndoQuota().get().toString()); } else { renderingEngine.message(StringResources.UNDO_QUOTA_UNLIMITED); } renderingEngine.message(\">>> \"); Action action = inputEngine.fetchAction(); curAction = action; ActionResult result = processAction(action); if (result instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) result).getReason()); } renderingEngine.render(state); } renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(StringResources.WIN_MESSAGE); } }",
        "label": "P"
    },
    "1472": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"There are more than two players in the map!\"); } }",
        "label": "P"
    },
    "1473": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { outputSteam.print(content + '\\n'); }",
        "label": "P"
    },
    "1474": {
        "dataset": "COMP 3021",
        "project": "nctse",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.originalMap = map; if (map.getUndoLimit().isPresent()) { this.undoQuota = Optional.of(map.getUndoLimit().get()); } else { this.undoQuota = Optional.empty(); } curMap = new HashMap<>(); curMap.putAll(map.getMap()); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1475": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return gameMap[0].length; } public int getMaxHeight() { // TODO return gameMap.length; } public Optional<Integer> getUndoLimit() { // TODO return undoLimit; }",
        "label": "P"
    },
    "1476": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1477": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1478": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1479": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1480": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1481": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1482": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1483": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return gameMap.length; }",
        "label": "P"
    },
    "1484": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return gameMap[0].length; }",
        "label": "P"
    },
    "1485": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1486": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1487": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1488": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1489": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine().toLowerCase(); // TODO switch (inputLine) { case \"exit\": return new Exit(-1); case \"u\": return new Undo(-1); case \"a\": return new Move.Left(0); case \"w\": return new Move.Up(0); case \"s\": return new Move.Down(0); case \"d\": return new Move.Right(0); case \"h\": return new Move.Left(1); case \"j\": return new Move.Down(1); case \"k\": return new Move.Up(1); case \"l\": return new Move.Right(1); default: return new InvalidInput(-1, INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "1490": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public void move(Position from, Position to) { // TODO Entity currEntity = gameMap.getEntity(from); Entity targetEntity = gameMap.getEntity(to); gameMap.putEntity(from, targetEntity); gameMap.putEntity(to, currEntity); if (currEntity instanceof Player) { playersPositions.replace(((Player) currEntity).getId(), to); } else if (currEntity instanceof Box) { boxesPositions.remove(from); boxesPositions.add(to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1491": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public void move(Position from, Position to) { // TODO Entity currEntity = gameMap.getEntity(from); Entity targetEntity = gameMap.getEntity(to); gameMap.putEntity(from, targetEntity); gameMap.putEntity(to, currEntity); if (currEntity instanceof Player) { playersPositions.replace(((Player) currEntity).getId(), to); } else if (currEntity instanceof Box) { boxesPositions.remove(from); boxesPositions.add(to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if (playersPositions.containsKey(id)) { return playersPositions.get(id); } else { return new Position(-1, -1); } }",
        "label": "P"
    },
    "1492": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public void move(Position from, Position to) { // TODO Entity currEntity = gameMap.getEntity(from); Entity targetEntity = gameMap.getEntity(to); gameMap.putEntity(from, targetEntity); gameMap.putEntity(to, currEntity); if (currEntity instanceof Player) { playersPositions.replace(((Player) currEntity).getId(), to); } else if (currEntity instanceof Box) { boxesPositions.remove(from); boxesPositions.add(to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if (playersPositions.containsKey(id)) { return playersPositions.get(id); } else { return new Position(-1, -1); } } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1493": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public Optional<Integer> getUndoQuota() { // TODO if (!undoQuotaLeft.equals(Optional.of(-1))) { return undoQuotaLeft; } return Optional.empty(); }",
        "label": "P"
    },
    "1494": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO return new HashSet<>(playersPositions.values()); }",
        "label": "P"
    },
    "1495": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public void move(Position from, Position to) { // TODO Entity currEntity = gameMap.getEntity(from); Entity targetEntity = gameMap.getEntity(to); gameMap.putEntity(from, targetEntity); gameMap.putEntity(to, currEntity); if (currEntity instanceof Player) { playersPositions.replace(((Player) currEntity).getId(), to); } else if (currEntity instanceof Box) { boxesPositions.remove(from); boxesPositions.add(to); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO GameMap clonedGameMap = gameMap.clone(gameMap); checkPoints.push(clonedGameMap); } public void undo() { // TODO // Check if gameMap now is the original setup boolean same = true; for (int y = 0; y < gameMap.getMaxHeight(); y++) { for (int x = 0; x < gameMap.getMaxWidth(); x++) { if (gameMap.gameMap[y][x] != checkPoints.firstElement().gameMap[y][x]) { same = false; break; } } } if (!same && undoQuotaLeft.isPresent()) { undoQuotaLeft = Optional.of(undoQuotaLeft.get() - 1); } // pop the move just now if (checkPoints.size() > 0) { gameMap = checkPoints.pop(); } // pop the move from previous step if (checkPoints.size() > 0) { gameMap = checkPoints.pop(); } int width = gameMap.getMaxWidth(); int height = gameMap.getMaxHeight(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = gameMap.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } if (checkPoints.size() == 0) { GameMap clonedGameMap = gameMap.clone(gameMap); checkPoints.push(clonedGameMap); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO if (playersPositions.containsKey(id)) { return playersPositions.get(id); } else { return new Position(-1, -1); } } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (!undoQuotaLeft.equals(Optional.of(-1))) { return undoQuotaLeft; } return Optional.empty(); }",
        "label": "P"
    },
    "1496": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"Too many players\"); } } public void run() { // TODO renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(state); String displayUndoQuota; if (state.getUndoQuota().isEmpty()) { // Unlimited displayUndoQuota = StringResources.UNDO_QUOTA_UNLIMITED; } else { // Limited String undoQuotaLeft = Integer.toString(state.getUndoQuota().get()); displayUndoQuota = String.format(StringResources.UNDO_QUOTA_TEMPLATE, undoQuotaLeft); } renderingEngine.message(displayUndoQuota); String displayUndoQuota2 = \"\"; while (!shouldStop()) { Action action = inputEngine.fetchAction(); ActionResult result = processAction(action); if (action instanceof Exit) { renderingEngine.render(state); break; } renderingEngine.render(state); if (state.getUndoQuota().isEmpty()) { // Unlimited displayUndoQuota2 = StringResources.UNDO_QUOTA_UNLIMITED; } else { // Limited String undoQuotaLeft2 = Integer.toString(state.getUndoQuota().get()); displayUndoQuota2 = String.format(StringResources.UNDO_QUOTA_TEMPLATE, undoQuotaLeft2); } renderingEngine.message(displayUndoQuota2); } renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(StringResources.WIN_MESSAGE); } }",
        "label": "P"
    },
    "1497": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"Too many players\"); } }",
        "label": "P"
    },
    "1498": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1499": {
        "dataset": "COMP 3021",
        "project": "olchui",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO undoQuotaLeft = map.getUndoLimit(); gameMap = map; int width = map.getMaxWidth(); int height = map.getMaxHeight(); playersPositions = new HashMap<>(); boxesPositions = new HashSet<>(); checkPoints = new Stack<>(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { Position position = new Position(x, y); Entity entity = map.getEntity(position); if (entity instanceof Player) { // is Player int playerId = ((Player) entity).getId(); playersPositions.put(playerId, position); } else if (entity instanceof Box) { // is Box boxesPositions.add(position); } } } checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1500": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO: done return maxWidth; } public int getMaxHeight() { // TODO: done return maxHeight; } public Optional<Integer> getUndoLimit() { // TODO: done if (undoLimit == -1){ return Optional.empty(); } else{ return Optional.of(undoLimit); } }",
        "label": "P"
    },
    "1501": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1502": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1503": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1504": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1505": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1506": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO: done return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1507": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO: done return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1508": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO: done return maxHeight; }",
        "label": "P"
    },
    "1509": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO: done return maxWidth; }",
        "label": "P"
    },
    "1510": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO: done return currentMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO: done return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1511": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO: done return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1512": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO: done return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1513": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO: done return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1514": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO: done //Action returnAction = null; if (inputLine.equalsIgnoreCase(\"A\")){ return new Move.Left(0); } if (inputLine.equalsIgnoreCase(\"S\")){ return new Move.Down(0); } if (inputLine.equalsIgnoreCase(\"W\")){ return new Move.Up(0); } if (inputLine.equalsIgnoreCase(\"D\")){ return new Move.Right(0); } if (inputLine.equalsIgnoreCase(\"H\")){ return new Move.Left(1); } if (inputLine.equalsIgnoreCase(\"J\")){ return new Move.Down(1); } if (inputLine.equalsIgnoreCase(\"K\")){ return new Move.Up(1); } if (inputLine.equalsIgnoreCase(\"L\")){ return new Move.Right(1); } if (inputLine.equalsIgnoreCase(\"U\")){ return new Undo(-1); } if (inputLine.equalsIgnoreCase(StringResources.EXIT_COMMAND_TEXT)){ return new Exit(-1); } else{ return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "1515": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public void move(Position from, Position to) { // TODO: done Entity origE = getEntity(from); // get the Entity in those positions // get a copy of Entity in new position, // so that it won't be affected by the coming changing reference Entity newE = getEntity(to).copy(); // switch Entity in those positions currentMap.putEntity(to, origE); // overwrite origE to new postion currentMap.putEntity(from, newE); // overwrite newE to old postion } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1516": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public void move(Position from, Position to) { // TODO: done Entity origE = getEntity(from); // get the Entity in those positions // get a copy of Entity in new position, // so that it won't be affected by the coming changing reference Entity newE = getEntity(to).copy(); // switch Entity in those positions currentMap.putEntity(to, origE); // overwrite origE to new postion currentMap.putEntity(from, newE); // overwrite newE to old postion } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO: done /*if (!currentMap.getPlayerIds().contains(id)){ //throw new IllegalArgumentException(\"PlayerID: \" + id + \"doesn't exist.\"); System.out.println(\"PlayerID: \" + id + \"doesn't exist.\"); } else{*/ Player target = new Player(id); for (int i = 0; i < currentMap.getMaxHeight(); i++){ for (int j = 0; j < currentMap.getMaxWidth(); j++){ if (currentMap.getEntity(Position.of(j, i)).equals(target)){ return Position.of(j, i); } } } System.out.println(\"PlayerID: \" + id + \"(\" + Character.toString((char)(id + 'A'))+ \") doesn't exist.\"); return Position.of(-1, -1); //throw new IllegalArgumentException(\"PlayerID: \" + id + \"can't be found.\"); }",
        "label": "P"
    },
    "1517": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public void move(Position from, Position to) { // TODO: done Entity origE = getEntity(from); // get the Entity in those positions // get a copy of Entity in new position, // so that it won't be affected by the coming changing reference Entity newE = getEntity(to).copy(); // switch Entity in those positions currentMap.putEntity(to, origE); // overwrite origE to new postion currentMap.putEntity(from, newE); // overwrite newE to old postion } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO: done /*if (!currentMap.getPlayerIds().contains(id)){ //throw new IllegalArgumentException(\"PlayerID: \" + id + \"doesn't exist.\"); System.out.println(\"PlayerID: \" + id + \"doesn't exist.\"); } else{*/ Player target = new Player(id); for (int i = 0; i < currentMap.getMaxHeight(); i++){ for (int j = 0; j < currentMap.getMaxWidth(); j++){ if (currentMap.getEntity(Position.of(j, i)).equals(target)){ return Position.of(j, i); } } } System.out.println(\"PlayerID: \" + id + \"(\" + Character.toString((char)(id + 'A'))+ \") doesn't exist.\"); return Position.of(-1, -1); //throw new IllegalArgumentException(\"PlayerID: \" + id + \"can't be found.\"); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO: done return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1518": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public Optional<Integer> getUndoQuota() { // TODO: done but not sure return undoQuotaLeft; }",
        "label": "P"
    },
    "1519": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO: done Set<Position> allPlayerPos = new HashSet<Position>(); for (Integer thisID: currentMap.getPlayerIds()){ allPlayerPos.add(getPlayerPositionById(thisID)); } return allPlayerPos; }",
        "label": "P"
    },
    "1520": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public void move(Position from, Position to) { // TODO: done Entity origE = getEntity(from); // get the Entity in those positions // get a copy of Entity in new position, // so that it won't be affected by the coming changing reference Entity newE = getEntity(to).copy(); // switch Entity in those positions currentMap.putEntity(to, origE); // overwrite origE to new postion currentMap.putEntity(from, newE); // overwrite newE to old postion } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO: done but not sure //checkpoints.add(new GameMap(currentMap)); //if (nextMaptoSave != initialMap) { // because initial map remains unchanged checkpoints.push(nextMaptoSave); //} nextMaptoSave = new GameMap(currentMap); int j = 0; for (GameMap i: checkpoints){ System.out.println(\"< Checkpoint \" + j + \" >\"); System.out.println(i.toString()); j++; } } public void undo() { // TODO: done if (checkpoints.empty()){ // If there is no checkpoint recorded System.out.println(\"There's no checkpoint recorded, revert to initial game state.\"); currentMap = new GameMap(initialMap); // update current map back to initial map nextMaptoSave = initialMap; // link last box map back to initial map } else{ //int lastIndex = checkpoints.size()-1; //currentMap = new GameMap(checkpoints.get(lastIndex)); //checkpoints.remove(lastIndex); currentMap = checkpoints.pop(); // update current map back to checkpoint nextMaptoSave = new GameMap(currentMap); // update nextMaptoSave if (undoQuotaLeft.isPresent()){ // if quota is limited, decrease by 1 int updatedQuota = undoQuotaLeft.get() - 1; undoQuotaLeft = Optional.of(updatedQuota); } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO: done /*if (!currentMap.getPlayerIds().contains(id)){ //throw new IllegalArgumentException(\"PlayerID: \" + id + \"doesn't exist.\"); System.out.println(\"PlayerID: \" + id + \"doesn't exist.\"); } else{*/ Player target = new Player(id); for (int i = 0; i < currentMap.getMaxHeight(); i++){ for (int j = 0; j < currentMap.getMaxWidth(); j++){ if (currentMap.getEntity(Position.of(j, i)).equals(target)){ return Position.of(j, i); } } } System.out.println(\"PlayerID: \" + id + \"(\" + Character.toString((char)(id + 'A'))+ \") doesn't exist.\"); return Position.of(-1, -1); //throw new IllegalArgumentException(\"PlayerID: \" + id + \"can't be found.\"); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO: done return currentMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO: done but not sure return undoQuotaLeft; }",
        "label": "P"
    },
    "1521": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO: done // Check the number of players if (this.state.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(\"There're more than 2 players in the map\"); } } public void run() { //System.out.println(\"Running\"); }",
        "label": "P"
    },
    "1522": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO: done // Check the number of players if (this.state.getAllPlayerPositions().size() > 2){ throw new IllegalArgumentException(\"There're more than 2 players in the map\"); } }",
        "label": "P"
    },
    "1523": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO: done but not sure outputSteam.append(content); // not sure outputSteam.append(System.lineSeparator()); // Hint: System.out is also a PrintStream. }",
        "label": "P"
    },
    "1524": {
        "dataset": "COMP 3021",
        "project": "hcloaf",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // when GameState is first created // TODO: done currentMap = new GameMap(map); // create an instance of GameMap undoQuotaLeft = currentMap.getUndoLimit(); initialMap = map; nextMaptoSave = initialMap; // ref link } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public String toString() { return Character.toString(this.getEmptyChar()); }",
        "label": "P"
    },
    "1525": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return board[0].length; } public int getMaxHeight() { return board.length; } CheckPoint createCheckPoint() { return new CheckPoint(new HashMap<>(playerPos), new HashMap<>(boxPos), undoLim); } boolean isEnded(){ return dests.stream().allMatch(d -> getEntity(d) instanceof Box); } public Optional<Integer> getUndoLimit() { return undoLim >= 0 ? Optional.of(undoLim) : Optional.empty(); }",
        "label": "P"
    },
    "1526": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static Move.Left moveLeft(int id){ if (Objects.isNull(MOVE_LEFT_OBJS[id])) MOVE_LEFT_OBJS[id] = new Move.Left(id); return MOVE_LEFT_OBJS[id]; } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public static Move.Left moveLeft(int id){ if (Objects.isNull(MOVE_LEFT_OBJS[id])) MOVE_LEFT_OBJS[id] = new Move.Left(id); return MOVE_LEFT_OBJS[id]; }",
        "label": "P"
    },
    "1527": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1528": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public static Move.Down moveDown(int id){ if (Objects.isNull(MOVE_DOWN_OBJS[id])) MOVE_DOWN_OBJS[id] = new Move.Down(id); return MOVE_DOWN_OBJS[id]; }",
        "label": "P"
    },
    "1529": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public static Move.Down moveDown(int id){ if (Objects.isNull(MOVE_DOWN_OBJS[id])) MOVE_DOWN_OBJS[id] = new Move.Down(id); return MOVE_DOWN_OBJS[id]; }",
        "label": "P"
    },
    "1530": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public static Move.Down moveDown(int id){ if (Objects.isNull(MOVE_DOWN_OBJS[id])) MOVE_DOWN_OBJS[id] = new Move.Down(id); return MOVE_DOWN_OBJS[id]; }",
        "label": "P"
    },
    "1531": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gmMp.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1532": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gmMp.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1533": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return board.length; } CheckPoint createCheckPoint() { return new CheckPoint(new HashMap<>(playerPos), new HashMap<>(boxPos), undoLim); } boolean isEnded(){ return dests.stream().allMatch(d -> getEntity(d) instanceof Box); }",
        "label": "P"
    },
    "1534": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return board[0].length; }",
        "label": "P"
    },
    "1535": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return gmMp.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return gmMp.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1536": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gmMp.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1537": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gmMp.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1538": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gmMp.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1539": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { return switch(terminalScanner.nextLine().toLowerCase()) { case \"a\" -> Move.moveLeft(0); case \"s\" -> Move.moveDown(0); case \"w\" -> Move.moveUp(0); case \"d\" -> Move.moveRight(0); case \"h\" -> Move.moveLeft(1); case \"j\" -> Move.moveDown(1); case \"k\" -> Move.moveUp(1); case \"l\" -> Move.moveRight(1); case \"u\" -> Undo.get(0); case String s && s.equals(StringResources.EXIT_COMMAND_TEXT) -> new Exit(0); default -> new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); }; }",
        "label": "P"
    },
    "1540": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public void move(Position from, Position to) { gmMp.performMove(from, to); } ActionResult movePlayer(Move playerMove) { var playerCrtPos = getPlayerPositionById(playerMove.getInitiator()); if (Objects.isNull(playerCrtPos)) return new ActionResult.Failed(playerMove, StringResources.PLAYER_NOT_FOUND); var targetPos = playerMove.nextPosition(playerCrtPos); assert (gmMp.isInBound(targetPos)); switch (getEntity(targetPos)) { case Empty __ -> { move(playerCrtPos, targetPos); return new ActionResult.Success(playerMove); } case Wall __ -> { return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_WALL); } case Player __ -> { return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_PLAYER); } case Box b -> { if (b.getPlayerId() != playerMove.getInitiator()) return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_OTHER_BOX); var boxTarget = playerMove.nextPosition(targetPos); // System.out.println(\"target pos: \" + boxTarget); if (!gmMp.isInBound(boxTarget) || !(getEntity(boxTarget) instanceof Empty)) { return new ActionResult.Failed(playerMove, StringResources.MOVE_BOX_FAILED); } move(targetPos, boxTarget); move(playerCrtPos, targetPos); checkpoint(); return new ActionResult.Success(playerMove); } } throw new ShouldNotReachException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1541": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public void move(Position from, Position to) { gmMp.performMove(from, to); } ActionResult movePlayer(Move playerMove) { var playerCrtPos = getPlayerPositionById(playerMove.getInitiator()); if (Objects.isNull(playerCrtPos)) return new ActionResult.Failed(playerMove, StringResources.PLAYER_NOT_FOUND); var targetPos = playerMove.nextPosition(playerCrtPos); assert (gmMp.isInBound(targetPos)); switch (getEntity(targetPos)) { case Empty __ -> { move(playerCrtPos, targetPos); return new ActionResult.Success(playerMove); } case Wall __ -> { return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_WALL); } case Player __ -> { return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_PLAYER); } case Box b -> { if (b.getPlayerId() != playerMove.getInitiator()) return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_OTHER_BOX); var boxTarget = playerMove.nextPosition(targetPos); // System.out.println(\"target pos: \" + boxTarget); if (!gmMp.isInBound(boxTarget) || !(getEntity(boxTarget) instanceof Empty)) { return new ActionResult.Failed(playerMove, StringResources.MOVE_BOX_FAILED); } move(targetPos, boxTarget); move(playerCrtPos, targetPos); checkpoint(); return new ActionResult.Success(playerMove); } } throw new ShouldNotReachException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return gmMp.getPlayerPosById(id); }",
        "label": "P"
    },
    "1542": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public void move(Position from, Position to) { gmMp.performMove(from, to); } ActionResult movePlayer(Move playerMove) { var playerCrtPos = getPlayerPositionById(playerMove.getInitiator()); if (Objects.isNull(playerCrtPos)) return new ActionResult.Failed(playerMove, StringResources.PLAYER_NOT_FOUND); var targetPos = playerMove.nextPosition(playerCrtPos); assert (gmMp.isInBound(targetPos)); switch (getEntity(targetPos)) { case Empty __ -> { move(playerCrtPos, targetPos); return new ActionResult.Success(playerMove); } case Wall __ -> { return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_WALL); } case Player __ -> { return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_PLAYER); } case Box b -> { if (b.getPlayerId() != playerMove.getInitiator()) return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_OTHER_BOX); var boxTarget = playerMove.nextPosition(targetPos); // System.out.println(\"target pos: \" + boxTarget); if (!gmMp.isInBound(boxTarget) || !(getEntity(boxTarget) instanceof Empty)) { return new ActionResult.Failed(playerMove, StringResources.MOVE_BOX_FAILED); } move(targetPos, boxTarget); move(playerCrtPos, targetPos); checkpoint(); return new ActionResult.Success(playerMove); } } throw new ShouldNotReachException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return gmMp.getPlayerPosById(id); } public @Nullable Entity getEntity(@NotNull Position position) { return gmMp.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1543": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public Optional<Integer> getUndoQuota() { return gmMp.getUndoLimit(); }",
        "label": "P"
    },
    "1544": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { return gmMp.getAllPlayerPos(); }",
        "label": "P"
    },
    "1545": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public void move(Position from, Position to) { gmMp.performMove(from, to); } ActionResult movePlayer(Move playerMove) { var playerCrtPos = getPlayerPositionById(playerMove.getInitiator()); if (Objects.isNull(playerCrtPos)) return new ActionResult.Failed(playerMove, StringResources.PLAYER_NOT_FOUND); var targetPos = playerMove.nextPosition(playerCrtPos); assert (gmMp.isInBound(targetPos)); switch (getEntity(targetPos)) { case Empty __ -> { move(playerCrtPos, targetPos); return new ActionResult.Success(playerMove); } case Wall __ -> { return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_WALL); } case Player __ -> { return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_PLAYER); } case Box b -> { if (b.getPlayerId() != playerMove.getInitiator()) return new ActionResult.Failed(playerMove, StringResources.MOVE_HIT_OTHER_BOX); var boxTarget = playerMove.nextPosition(targetPos); // System.out.println(\"target pos: \" + boxTarget); if (!gmMp.isInBound(boxTarget) || !(getEntity(boxTarget) instanceof Empty)) { return new ActionResult.Failed(playerMove, StringResources.MOVE_BOX_FAILED); } move(targetPos, boxTarget); move(playerCrtPos, targetPos); checkpoint(); return new ActionResult.Success(playerMove); } } throw new ShouldNotReachException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { var point = checkPoints.push(gmMp.createCheckPoint()); // System.out.printf(\"add check point: %h@%s\\n\", point.hashCode(), point.toString()); // System.out.println(\"stored checkpoints: \"); // checkPoints.forEach(cp -> System.out.printf(\"%h@%s\\n\", cp.hashCode(), cp.toString())); } public void undo() { // System.out.println(\"stored checkpoints: \"); // checkPoints.forEach(cp -> System.out.printf(\"%h@%s\\n\", cp.hashCode(), cp.toString())); if (checkPoints.size() == 1) { gmMp.revert(checkPoints.peek()); } else { checkPoints.pop(); gmMp.revert(checkPoints.peek()); gmMp.decreUndoLim(); } // System.out.println(\"rest checkpoints: \"); // checkPoints.forEach(cp -> System.out.printf(\"%h@%s\\n\", cp.hashCode(), cp.toString())); } ActionResult performUndo(Undo u) { if (gmMp.getUndoLimit().orElse(1) > 0) { undo(); return new ActionResult.Success(u); } else return new ActionResult.Failed(u, StringResources.UNDO_QUOTA_RUN_OUT); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { return gmMp.getPlayerPosById(id); } public @Nullable Entity getEntity(@NotNull Position position) { return gmMp.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { return gmMp.getUndoLimit(); }",
        "label": "P"
    },
    "1546": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(StringResources.PLAYER_EXCEED_LIMIT); } public void run() { renderingEngine.message(StringResources.GAME_READY_MESSAGE); // System.out.println(\"initial check point saved\"); for (; ; ) { // System.out.println(\"running\"); renderingEngine.render(state); if (state.isWin()) { renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); renderingEngine.message(StringResources.WIN_MESSAGE); break; } if (lastAction instanceof Exit) { renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); break; } renderingEngine.message( state.getUndoQuota().map( (Function<Integer, String>) i -> String.format(StringResources.UNDO_QUOTA_TEMPLATE, i) ).orElse(StringResources.UNDO_QUOTA_UNLIMITED) ); renderingEngine.message(StringResources.RENDER_DELIMINATER); if (processAction(inputEngine.fetchAction()) instanceof ActionResult.Failed f) renderingEngine.message(f.getReason()); } }",
        "label": "P"
    },
    "1547": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(StringResources.PLAYER_EXCEED_LIMIT); }",
        "label": "P"
    },
    "1548": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { outputSteam.println(content); }",
        "label": "P"
    },
    "1549": {
        "dataset": "COMP 3021",
        "project": "kyuanab",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { gmMp = map; checkpoint(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public static Player get(int id) { if (Objects.isNull(CACHE[id])) CACHE[id] = new Player(id); return CACHE[id]; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public String toString() { return \"Box_\" + playerId + \"@\" + this.hashCode(); }",
        "label": "P"
    },
    "1550": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; } public int getMaxHeight() { // TODO return height; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undoLimit); }",
        "label": "P"
    },
    "1551": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1552": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1553": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1554": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1555": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1556": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1557": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1558": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; }",
        "label": "P"
    },
    "1559": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; }",
        "label": "P"
    },
    "1560": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return stateMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1561": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1562": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1563": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1564": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); Action currAction = null; // TODO if(inputLine.toUpperCase().contentEquals(\"A\")) { currAction = new Move.Left(0); } else if(inputLine.toUpperCase().contentEquals(\"D\")) { currAction = new Move.Right(0); } else if(inputLine.toUpperCase().contentEquals(\"W\")) { currAction = new Move.Up(0); } else if(inputLine.toUpperCase().contentEquals(\"S\")) { currAction = new Move.Down(0); } else if (inputLine.toUpperCase().contentEquals(\"U\")) { currAction = new Undo(0); } else if (inputLine.contentEquals(StringResources.EXIT_COMMAND_TEXT)) { currAction = new Exit(0); } else if(TerminalSokobanGame.numOfPlayers == 2) { if(inputLine.toUpperCase().contentEquals(\"H\")) { currAction = new Move.Left(1); } else if(inputLine.toUpperCase().contentEquals(\"L\")) { currAction = new Move.Right(1); } else if(inputLine.toUpperCase().contentEquals(\"K\")) { currAction = new Move.Up(1); } else if(inputLine.toUpperCase().contentEquals(\"J\")) { currAction = new Move.Down(1); } else { currAction = new InvalidInput(0, \"Invalid Input\"); } } else { currAction = new InvalidInput(0, \"Invalid Input\"); } return currAction; }",
        "label": "P"
    },
    "1565": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public void move(Position from, Position to) { // TODO stateMap.putEntity(to, getEntity(from)); char c = stateMap.map.get(from.y()).mapLine.get(from.x()); stateMap.map.get(to.y()).setValue(c, to.x()); if(GameMap.parseState(allMapStr.get(0)).getChar(from) == '@'){ stateMap.map.get(from.y()).setValue('@', from.x()); } else{ stateMap.putEntity(from, new Empty()); stateMap.map.get(from.y()).setValue('.', from.x()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1566": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public void move(Position from, Position to) { // TODO stateMap.putEntity(to, getEntity(from)); char c = stateMap.map.get(from.y()).mapLine.get(from.x()); stateMap.map.get(to.y()).setValue(c, to.x()); if(GameMap.parseState(allMapStr.get(0)).getChar(from) == '@'){ stateMap.map.get(from.y()).setValue('@', from.x()); } else{ stateMap.putEntity(from, new Empty()); stateMap.map.get(from.y()).setValue('.', from.x()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < stateMap.height; i++){ for(int j = 0; j < stateMap.width; j++){ if(stateMap.map.get(i).mapLine.get(j) == stateMap.idToLetter(id, true)){ return new Position(j,i); } } } return null; }",
        "label": "P"
    },
    "1567": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public void move(Position from, Position to) { // TODO stateMap.putEntity(to, getEntity(from)); char c = stateMap.map.get(from.y()).mapLine.get(from.x()); stateMap.map.get(to.y()).setValue(c, to.x()); if(GameMap.parseState(allMapStr.get(0)).getChar(from) == '@'){ stateMap.map.get(from.y()).setValue('@', from.x()); } else{ stateMap.putEntity(from, new Empty()); stateMap.map.get(from.y()).setValue('.', from.x()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < stateMap.height; i++){ for(int j = 0; j < stateMap.width; j++){ if(stateMap.map.get(i).mapLine.get(j) == stateMap.idToLetter(id, true)){ return new Position(j,i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1568": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public Optional<Integer> getUndoQuota() { // TODO //System.out.print(stateMap.generateMapString()); //System.out.print(stateMap.getUndoLimit()); if(stateMap.undoLimit > -1){ return stateMap.getUndoLimit(); } return Optional.empty(); }",
        "label": "P"
    },
    "1569": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO playerPositions = new HashSet<>(); for(int i : stateMap.playerIDs){ playerPositions.add(getPlayerPositionById(i)); } return playerPositions; }",
        "label": "P"
    },
    "1570": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public void move(Position from, Position to) { // TODO stateMap.putEntity(to, getEntity(from)); char c = stateMap.map.get(from.y()).mapLine.get(from.x()); stateMap.map.get(to.y()).setValue(c, to.x()); if(GameMap.parseState(allMapStr.get(0)).getChar(from) == '@'){ stateMap.map.get(from.y()).setValue('@', from.x()); } else{ stateMap.putEntity(from, new Empty()); stateMap.map.get(from.y()).setValue('.', from.x()); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO /* allStates.add(this); allMapStates.add(stateMap); */ allMapStr.add(stateMap.generateMapString()); stateIndex = allMapStr.size() - 2; } public void undo() { // TODO if(allMapStr.size() == 1){ stateMap = GameMap.parseState(allMapStr.get(0)); } else{ stateMap = GameMap.parseState(allMapStr.get(stateIndex)); allMapStr.remove(allMapStr.size() - 1); //allMapStates.remove(stateIndex); stateIndex--; undoQuota--; } stateMap.undoLimit = undoQuota; } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < stateMap.height; i++){ for(int j = 0; j < stateMap.width; j++){ if(stateMap.map.get(i).mapLine.get(j) == stateMap.idToLetter(id, true)){ return new Position(j,i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return stateMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO //System.out.print(stateMap.generateMapString()); //System.out.print(stateMap.getUndoLimit()); if(stateMap.undoLimit > -1){ return stateMap.getUndoLimit(); } return Optional.empty(); }",
        "label": "P"
    },
    "1571": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players numOfPlayers = gameState.getAllPlayerPositions().size(); if(numOfPlayers > 2){ throw new IllegalArgumentException(); } } public void run() { // TODO Action currAction = null; /* renderingEngine.render(super.state); Action currAction = inputEngine.fetchAction(); renderingEngine.render(super.state); if(!super.shouldStop() && !(currAction instanceof Exit)) { while(!super.shouldStop() && !(currAction instanceof Exit)){ super.processAction(currAction); currAction = inputEngine.fetchAction(); renderingEngine.render(super.state); } } */ renderingEngine.message(StringResources.GAME_READY_MESSAGE); renderingEngine.render(state); renderingEngine.message(\"\"); if(!state.getUndoQuota().isEmpty()){ StringBuilder out = new StringBuilder(); out.append(\"Undo Quota : \"); out.append(state.getUndoQuota().get().toString()); renderingEngine.message(out.toString()); }else{ renderingEngine.message(\"Unlimited Undos\"); } while(!super.shouldStop() && !(currAction instanceof Exit)){ currAction = inputEngine.fetchAction(); ActionResult result = super.processAction(currAction); renderingEngine.render(state); if(result instanceof ActionResult.Failed){ renderingEngine.message(((ActionResult.Failed) result).getReason()); } else{ renderingEngine.message(\"\"); } if(!state.getUndoQuota().isEmpty()){ StringBuilder out = new StringBuilder(); out.append(\"Undo Quota : \"); out.append(state.getUndoQuota().get().toString()); renderingEngine.message(out.toString()); }else{ renderingEngine.message(\"Unlimited Undos\"); } if(shouldStop()) { renderingEngine.message(StringResources.WIN_MESSAGE); } if(currAction instanceof Exit) { renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); } } }",
        "label": "P"
    },
    "1572": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players numOfPlayers = gameState.getAllPlayerPositions().size(); if(numOfPlayers > 2){ throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "1573": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.print(content + System.lineSeparator()); }",
        "label": "P"
    },
    "1574": {
        "dataset": "COMP 3021",
        "project": "jlawrance",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO stateMap = GameMap.parse(map.generateMapString()); playerPositions = new HashSet<>(); for(Position pos : stateMap.playerLocs){ playerPositions.add(pos); } allMapStates.add(map); allMapStr.add(stateMap.generateMapString()); undoQuota = stateMap.undoLimit; //TestUndo = getUndoQuota(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public MapLevel(int width) { mapLine = new ArrayList<Character>(); entityMap = new ArrayList<Entity>(); for (int i = 0; i < width; i++) { mapLine.add(' '); entityMap.add(new Empty()); } }",
        "label": "P"
    },
    "1575": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; //throw new NotImplementedException(); } public int getMaxHeight() { // TODO return maxHeight; //throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undoLimit); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1576": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1577": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1578": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1579": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1580": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1581": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map[position.y()][position.x()]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; } }",
        "label": "P"
    },
    "1582": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map[position.y()][position.x()]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1583": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1584": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1585": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; //throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map[position.y()][position.x()]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1586": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map[position.y()][position.x()]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1587": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map[position.y()][position.x()]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1588": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map[position.y()][position.x()]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1589": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. var inputLine = terminalScanner.nextLine(); inputLine = inputLine.toUpperCase(); int initiator = 0; switch(inputLine){ case \"W\": return new Move.Up(initiator); case \"A\": return new Move.Left(initiator); case \"S\": return new Move.Down(initiator); case \"D\": return new Move.Right(initiator); case \"H\": initiator = 1; return new Move.Left(initiator); case \"J\": initiator = 1; return new Move.Down(initiator); case \"K\": initiator = 1; return new Move.Up(initiator); case \"L\": initiator = 1; return new Move.Right(initiator); case \"U\": return new Undo(initiator); case \"EXIT\": return new Exit(initiator); default: } // TODO return new InvalidInput(initiator, StringResources.INVALID_INPUT_MESSAGE); // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1590": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO int tempid; if(map[from.y()][from.x()] instanceof Player){ tempid = ((Player) map[from.y()][from.x()]).getId(); map[from.y()][from.x()] = new Empty(); map[to.y()][to.x()] = new Player(tempid); } else if(map[from.y()][from.x()] instanceof Box){ tempid = ((Box) map[from.y()][from.x()]).getPlayerId(); map[from.y()][from.x()] = new Empty(); map[to.y()][to.x()] = new Box(tempid); } /* for(int i = 0; i< map.length; i++){ for (int j = 0; j < map[i].length; j++){ if(map[i][j] instanceof Wall) System.out.print(\"#\"); if(map[i][j] instanceof Player) System.out.print(\"A\"); if(map[i][j] instanceof Empty) System.out.print(\".\"); if(map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1591": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO int tempid; if(map[from.y()][from.x()] instanceof Player){ tempid = ((Player) map[from.y()][from.x()]).getId(); map[from.y()][from.x()] = new Empty(); map[to.y()][to.x()] = new Player(tempid); } else if(map[from.y()][from.x()] instanceof Box){ tempid = ((Box) map[from.y()][from.x()]).getPlayerId(); map[from.y()][from.x()] = new Empty(); map[to.y()][to.x()] = new Box(tempid); } /* for(int i = 0; i< map.length; i++){ for (int j = 0; j < map[i].length; j++){ if(map[i][j] instanceof Wall) System.out.print(\"#\"); if(map[i][j] instanceof Player) System.out.print(\"A\"); if(map[i][j] instanceof Empty) System.out.print(\".\"); if(map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < maxHeight; i++){ for(int j = 0; j < maxWidth; j++){ if(map[i][j] instanceof Player){ if(((Player) map[i][j]).getId() == id) return new Position(j,i); } } } throw new NotImplementedException(); }",
        "label": "P"
    },
    "1592": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO int tempid; if(map[from.y()][from.x()] instanceof Player){ tempid = ((Player) map[from.y()][from.x()]).getId(); map[from.y()][from.x()] = new Empty(); map[to.y()][to.x()] = new Player(tempid); } else if(map[from.y()][from.x()] instanceof Box){ tempid = ((Box) map[from.y()][from.x()]).getPlayerId(); map[from.y()][from.x()] = new Empty(); map[to.y()][to.x()] = new Box(tempid); } /* for(int i = 0; i< map.length; i++){ for (int j = 0; j < map[i].length; j++){ if(map[i][j] instanceof Wall) System.out.print(\"#\"); if(map[i][j] instanceof Player) System.out.print(\"A\"); if(map[i][j] instanceof Empty) System.out.print(\".\"); if(map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < maxHeight; i++){ for(int j = 0; j < maxWidth; j++){ if(map[i][j] instanceof Player){ if(((Player) map[i][j]).getId() == id) return new Position(j,i); } } } throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map[position.y()][position.x()]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1593": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO return Optional.of(this.undoquota); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1594": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> allplayer = new HashSet<Position>(); for(int i = 0; i < maxHeight; i++){ for(int j = 0; j < maxWidth; j++){ if(map[i][j] instanceof Player){ allplayer.add(new Position(j,i)); } } } return allplayer; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1595": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO int tempid; if(map[from.y()][from.x()] instanceof Player){ tempid = ((Player) map[from.y()][from.x()]).getId(); map[from.y()][from.x()] = new Empty(); map[to.y()][to.x()] = new Player(tempid); } else if(map[from.y()][from.x()] instanceof Box){ tempid = ((Box) map[from.y()][from.x()]).getPlayerId(); map[from.y()][from.x()] = new Empty(); map[to.y()][to.x()] = new Box(tempid); } /* for(int i = 0; i< map.length; i++){ for (int j = 0; j < map[i].length; j++){ if(map[i][j] instanceof Wall) System.out.print(\"#\"); if(map[i][j] instanceof Player) System.out.print(\"A\"); if(map[i][j] instanceof Empty) System.out.print(\".\"); if(map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO record.add(getnewmap()); /* for(int i = 0; i< record.get(0).length; i++){ for (int j = 0; j < record.get(0)[i].length; j++){ if(record.get(0)[i][j] instanceof Wall) System.out.print(\"#\"); if(record.get(0)[i][j] instanceof Player) System.out.print(\"A\"); if(record.get(0)[i][j] instanceof Empty) System.out.print(\".\"); if(record.get(0)[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); }*/ // throw new NotImplementedException(); } public void undo() { // TODO int checkpointnumber = record.size(); if(checkpointnumber > 1){ if(undoquota > 0){ record.remove(checkpointnumber-1); this.map = getnewmap(record.get(checkpointnumber-2)); undoquota--; } if(undoquota == -1){ record.remove(checkpointnumber-1); this.map = getnewmap(record.get(checkpointnumber-2)); } } else return; } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for(int i = 0; i < maxHeight; i++){ for(int j = 0; j < maxWidth; j++){ if(map[i][j] instanceof Player){ if(((Player) map[i][j]).getId() == id) return new Position(j,i); } } } throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return map[position.y()][position.x()]; //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return Optional.of(this.undoquota); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1596": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); //throw new NotImplementedException(); } public void run() { // TODO renderingEngine.message(StringResources.GAME_READY_MESSAGE); // int countloop = 0; boolean youwin = true; boolean gameexit = true; while(true){ renderingEngine.render(super.state); if(!gameexit){ renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if(!youwin) renderingEngine.message(StringResources.WIN_MESSAGE); break; } if(super.state.getUndoQuota().isPresent()) renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,String.valueOf(state.getUndoQuota().get()))); // System.out.printf(StringResources.UNDO_QUOTA_TEMPLATE,StringResources.UNDO_QUOTA_UNLIMITED); else if(super.state.getUndoQuota().isPresent() && super.state.getUndoQuota().get() == -1) renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,StringResources.UNDO_QUOTA_UNLIMITED)); Action action = inputEngine.fetchAction(); //System.out.print(countloop + \"\\n\"); if(action instanceof InvalidInput){ // System.out.print(countloop + \"invalidinput\\n\"); renderingEngine.message(StringResources.INVALID_INPUT_MESSAGE); }else if(action instanceof Exit){ // System.out.print(countloop + \"exit\\n\"); gameexit = false; } else{ // System.out.print(countloop + \"move or undo\\n\"); ActionResult result = super.processAction(action); if(result instanceof ActionResult.Success){ if(super.shouldStop()){ renderingEngine.message(StringResources.WIN_MESSAGE); youwin = false; gameexit = false; } }else if (result instanceof ActionResult.Failed){ renderingEngine.message(((ActionResult.Failed) result).getReason()); } } //countloop++; } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1597": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1598": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO outputSteam.print(content + System.lineSeparator()); // Hint: System.out is also a PrintStream. // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1599": {
        "dataset": "COMP 3021",
        "project": "kfchanay",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.undoquota = map.undoLimit; this.maxHeight = map.maxHeight; this.maxWidth = map.maxWidth; this.destinations = map.destinations; this.map = map.map; this.id = map.id; checkpoint(); /* for(int i = 0; i< this.map.length; i++){ for (int j = 0; j < this.map[i].length; j++){ if(this.map[i][j] instanceof Wall) System.out.print(\"#\"); if(this.map[i][j] instanceof Player) System.out.print(\"A\"); if(this.map[i][j] instanceof Empty) System.out.print(\".\"); if(this.map[i][j] instanceof Box) System.out.print(\"a\"); } System.out.print(\"\\n\"); } System.out.print(\"\\n\"); */ //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1600": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; } public int getMaxHeight() { // TODO return maxHeight; } public Optional<Integer> getUndoLimit() { return undoLimit; } } /** * A snapspot of Previous game state. * This will be used in {@link GameState#undo()}. */ class GameSnapshot { final Entity[][] entities; GameSnapshot(int maxHeight, int maxWidth, Entity[][] entities) { this.entities = new Entity[maxHeight][maxWidth]; for (int i = 0; i < maxHeight; i++) { for (int c = 0; c < maxWidth; c++) { this.entities[i][c] = entities[i][c]; } } }",
        "label": "P"
    },
    "1601": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1602": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1603": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1604": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1605": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1606": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return snapshots.get(snapshots.size() - 1).entities[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1607": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return snapshots.get(snapshots.size() - 1).entities[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1608": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; }",
        "label": "P"
    },
    "1609": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; }",
        "label": "P"
    },
    "1610": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return snapshots.get(snapshots.size() - 1).entities[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1611": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return snapshots.get(snapshots.size() - 1).entities[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1612": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return snapshots.get(snapshots.size() - 1).entities[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1613": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return snapshots.get(snapshots.size() - 1).entities[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1614": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine().toLowerCase(); // TODO if (inputLine.equals(\"w\")) return new Move.Up(0); else if (inputLine.equals(\"a\")) return new Move.Left(0); else if (inputLine.equals(\"s\")) return new Move.Down(0); else if (inputLine.equals(\"d\")) return new Move.Right(0); else if (inputLine.equals(\"k\")) return new Move.Up(1); else if (inputLine.equals(\"h\")) return new Move.Left(1); else if (inputLine.equals(\"j\")) return new Move.Down(1); else if (inputLine.equals(\"l\")) return new Move.Right(1); else if (inputLine.equals(\"u\")) return new Undo(-1); else if (inputLine.equals(StringResources.EXIT_COMMAND_TEXT)) return new Exit(-1); else return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); }",
        "label": "P"
    },
    "1615": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public void move(Position from, Position to) { // TODO var entity = getEntity(from); snapshots.get(snapshots.size() - 1).entities[to.y()][to.x()] = entity; snapshots.get(snapshots.size() - 1).entities[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1616": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public void move(Position from, Position to) { // TODO var entity = getEntity(from); snapshots.get(snapshots.size() - 1).entities[to.y()][to.x()] = entity; snapshots.get(snapshots.size() - 1).entities[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int c = 0; c < getMapMaxWidth(); c++) { for (int i = 0; i < getMapMaxHeight(); i++) { Position position = Position.of(c,i); var entity = getEntity(position); if (entity instanceof Player && ((Player) entity).getId() == id) { return position; } } } return null; }",
        "label": "P"
    },
    "1617": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public void move(Position from, Position to) { // TODO var entity = getEntity(from); snapshots.get(snapshots.size() - 1).entities[to.y()][to.x()] = entity; snapshots.get(snapshots.size() - 1).entities[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (int c = 0; c < getMapMaxWidth(); c++) { for (int i = 0; i < getMapMaxHeight(); i++) { Position position = Position.of(c,i); var entity = getEntity(position); if (entity instanceof Player && ((Player) entity).getId() == id) { return position; } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return snapshots.get(snapshots.size() - 1).entities[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1618": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public Optional<Integer> getUndoQuota() { // TODO return undoLimit; }",
        "label": "P"
    },
    "1619": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO var playerPositions = new HashSet<Position>(); for (int playerID : map.getPlayerIds()) { playerPositions.add(getPlayerPositionById(playerID)); } return playerPositions; }",
        "label": "P"
    },
    "1620": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public void move(Position from, Position to) { // TODO var entity = getEntity(from); snapshots.get(snapshots.size() - 1).entities[to.y()][to.x()] = entity; snapshots.get(snapshots.size() - 1).entities[from.y()][from.x()] = new Empty(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO snapshots.add(new GameSnapshot(getMapMaxHeight(), getMapMaxWidth(), snapshots.get(snapshots.size() - 1).entities)); } public void undo() { // TODO if (undoLimit.isPresent()) { if (snapshots.size() > 2) { undoLimit = Optional.of(undoLimit.get() - 1); snapshots.remove(snapshots.size() - 1); snapshots.remove(snapshots.size() - 1); snapshots.add(new GameSnapshot(getMapMaxHeight(), getMapMaxWidth(), snapshots.get(snapshots.size() - 1).entities)); } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (int c = 0; c < getMapMaxWidth(); c++) { for (int i = 0; i < getMapMaxHeight(); i++) { Position position = Position.of(c,i); var entity = getEntity(position); if (entity instanceof Player && ((Player) entity).getId() == id) { return position; } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return snapshots.get(snapshots.size() - 1).entities[position.y()][position.x()]; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return undoLimit; }",
        "label": "P"
    },
    "1621": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } } public void run() { // TODO renderingEngine.message(StringResources.GAME_READY_MESSAGE); while (true) { renderingEngine.render(state); if (shouldStop()) break; /** Print undoLimit */ String undoLimit; if (state.getUndoQuota().isPresent()) { undoLimit = String.format(StringResources.UNDO_QUOTA_TEMPLATE, state.getUndoQuota()); } else { undoLimit = StringResources.UNDO_QUOTA_UNLIMITED; } renderingEngine.message(undoLimit + \">>>\"); /** Process Action */ var action = inputEngine.fetchAction(); var actionResult = processAction(action); if (actionResult instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) actionResult).getReason()); } } /** Exit game */ renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(StringResources.WIN_MESSAGE); } }",
        "label": "P"
    },
    "1622": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } }",
        "label": "P"
    },
    "1623": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1624": {
        "dataset": "COMP 3021",
        "project": "kyloao",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoLimit = map.getUndoLimit(); final Entity[][] entities = new Entity[map.getMaxHeight()][map.getMaxWidth()]; for (int i = 0; i < map.getMaxHeight(); i++) { for (int c = 0; c < map.getMaxWidth(); c++) { entities[i][c] = map.getEntity(Position.of(c,i)); } } this.snapshots = new ArrayList<>(); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); this.snapshots.add(new GameSnapshot(map.getMaxHeight(), map.getMaxWidth(), entities)); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1625": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "1626": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1627": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1628": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1629": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1630": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1631": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.stateEntityMatrix[position.y()][position.x()]; } public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1632": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.stateEntityMatrix[position.y()][position.x()]; } public int getId() { return id; }",
        "label": "P"
    },
    "1633": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "1634": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "1635": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.stateEntityMatrix[position.y()][position.x()]; }",
        "label": "P"
    },
    "1636": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.stateEntityMatrix[position.y()][position.x()]; }",
        "label": "P"
    },
    "1637": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.stateEntityMatrix[position.y()][position.x()]; }",
        "label": "P"
    },
    "1638": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.stateEntityMatrix[position.y()][position.x()]; }",
        "label": "P"
    },
    "1639": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); System.out.println(\"INPUT :\"+inputLine); // TODO //Key A,S,W,D and H,J,K,L are used to move //Player with ID 0 and 1 to Left,Down,Up,Right direction by 1 step, respectively /* All Possible input values are (A, S, W, D, H, J, K, L, U, EXIT) and they should be the first character of the input line Input values are case insensitive (e.g. eXiT is also valid) All other values are invalid input, including whitespaces (e.g. \"\\n\" and \" A\" are both invalid) On the case of invalid input, TerminalInputEngine.fetchAction should return InvalidInput */ Action fetchedAction=null; switch (inputLine.toUpperCase()){ case \"W\": fetchedAction=new Move.Up(0); break; case \"K\": fetchedAction=new Move.Up(1); break; case \"S\": fetchedAction=new Move.Down(0); break; case \"J\": fetchedAction=new Move.Down(1); break; case \"A\": fetchedAction=new Move.Left(0); break; case \"H\": fetchedAction=new Move.Left(1); break; case \"D\": fetchedAction=new Move.Right(0); break; case \"L\": fetchedAction=new Move.Right(1); break; case \"U\": fetchedAction=new Undo(-1); break; case \"EXIT\": fetchedAction=new Exit(-1);break; default: //all other values fetchedAction=new InvalidInput(-1,StringResources.INVALID_INPUT_MESSAGE); } return fetchedAction; }",
        "label": "P"
    },
    "1640": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public void move(Position from, Position to) { // TODO /* * Step1: determine entity type of [from](entityFrom) & [to](entityTo) * Step2: for Set<Position> entityFrom: remove [from], add [to] * for Set<Position> entityTo: remove [to], add [from] * Step3: adjust stateEntityMatrix: * */ //Step1: determine entity type of [from](entityFrom) & [to](entityTo) String typeFrom=this.checkEntityType(from); String typeTo=this.checkEntityType(to); Entity tempHolderFrom=this.getEntity(from); Entity tempHolderTo=this.getEntity(to); //debug //System.out.println(\"type of [from] :\"+typeFrom); switch (typeFrom){ case \"Player\": //\u63a8Player: \u53ea\u80fd\u5c06player\u63a8\u5230empty\u4e0a\uff0cfrom\u7684\u4f4d\u7f6e\u6307\u5411empty // update recordPlayers({Position : Player}) this.recordPlayers.put(to,(Player)tempHolderFrom); this.recordPlayers.remove(from); //update empties (Set<Position>) this.empties.remove(to); this.empties.add(from); // update 2d map: swap references this.stateEntityMatrix[to.y()][to.x()]=(Player)tempHolderFrom; this.stateEntityMatrix[from.y()][from.x()]=(Empty)tempHolderTo; // case: // ...B@. -> // ....B. -> \u6b63\u89e3\uff1aB\u539f\u5148\u7684\u4f4d\u5b50\u4e0d\u4f1a\u51fa\u73b0@ // ....@B ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(false); //\u5047\u5982from\u672c\u6765\u662fdestination\uff0c@\u7b26\u53f7\u88ab\u538b\u4f4f\uff0c\u5c31\u8981\u8ba9\u5b83\u91cd\u89c1\u5929\u65e5 for(Position pos:this.destinations){ if(pos.x()==from.x() && pos.y()==from.y()){ ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(true); } } break; case \"Box\": //Box: \u53ea\u80fd\u5c06box\u63a8\u5230empty\u4e0a\uff0cfrom\u7684\u4f4d\u7f6e\u6307\u5411empty // update recordBox({Position : Box}) this.recordBoxes.put(to,(Box)tempHolderFrom); this.recordBoxes.remove(from); //update empties (Set<Position>) this.empties.remove(to); this.empties.add(from); // update 2d map: swap references this.stateEntityMatrix[to.y()][to.x()]=(Box)tempHolderFrom; this.stateEntityMatrix[from.y()][from.x()]=(Empty)tempHolderTo; //\u4f46\u5047\u5982 to \u662fdestination\uff0c\u5c31\u4e0d\u5e94\u8be5\u628a\"@\"\u6807\u5fd7\u8ddf\u7740\u88abswap\u8d70\uff0c\u800c\u662f\u8981\u8ba9\u4ed6\u88ab\u76d6\u4f4f ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(false); break; default: break; } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1641": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public void move(Position from, Position to) { // TODO /* * Step1: determine entity type of [from](entityFrom) & [to](entityTo) * Step2: for Set<Position> entityFrom: remove [from], add [to] * for Set<Position> entityTo: remove [to], add [from] * Step3: adjust stateEntityMatrix: * */ //Step1: determine entity type of [from](entityFrom) & [to](entityTo) String typeFrom=this.checkEntityType(from); String typeTo=this.checkEntityType(to); Entity tempHolderFrom=this.getEntity(from); Entity tempHolderTo=this.getEntity(to); //debug //System.out.println(\"type of [from] :\"+typeFrom); switch (typeFrom){ case \"Player\": //\u63a8Player: \u53ea\u80fd\u5c06player\u63a8\u5230empty\u4e0a\uff0cfrom\u7684\u4f4d\u7f6e\u6307\u5411empty // update recordPlayers({Position : Player}) this.recordPlayers.put(to,(Player)tempHolderFrom); this.recordPlayers.remove(from); //update empties (Set<Position>) this.empties.remove(to); this.empties.add(from); // update 2d map: swap references this.stateEntityMatrix[to.y()][to.x()]=(Player)tempHolderFrom; this.stateEntityMatrix[from.y()][from.x()]=(Empty)tempHolderTo; // case: // ...B@. -> // ....B. -> \u6b63\u89e3\uff1aB\u539f\u5148\u7684\u4f4d\u5b50\u4e0d\u4f1a\u51fa\u73b0@ // ....@B ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(false); //\u5047\u5982from\u672c\u6765\u662fdestination\uff0c@\u7b26\u53f7\u88ab\u538b\u4f4f\uff0c\u5c31\u8981\u8ba9\u5b83\u91cd\u89c1\u5929\u65e5 for(Position pos:this.destinations){ if(pos.x()==from.x() && pos.y()==from.y()){ ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(true); } } break; case \"Box\": //Box: \u53ea\u80fd\u5c06box\u63a8\u5230empty\u4e0a\uff0cfrom\u7684\u4f4d\u7f6e\u6307\u5411empty // update recordBox({Position : Box}) this.recordBoxes.put(to,(Box)tempHolderFrom); this.recordBoxes.remove(from); //update empties (Set<Position>) this.empties.remove(to); this.empties.add(from); // update 2d map: swap references this.stateEntityMatrix[to.y()][to.x()]=(Box)tempHolderFrom; this.stateEntityMatrix[from.y()][from.x()]=(Empty)tempHolderTo; //\u4f46\u5047\u5982 to \u662fdestination\uff0c\u5c31\u4e0d\u5e94\u8be5\u628a\"@\"\u6807\u5fd7\u8ddf\u7740\u88abswap\u8d70\uff0c\u800c\u662f\u8981\u8ba9\u4ed6\u88ab\u76d6\u4f4f ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(false); break; default: break; } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(Position pos:recordPlayers.keySet()){ if (recordPlayers.get(pos).getId()==id){ return pos; } } return null; }",
        "label": "P"
    },
    "1642": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public void move(Position from, Position to) { // TODO /* * Step1: determine entity type of [from](entityFrom) & [to](entityTo) * Step2: for Set<Position> entityFrom: remove [from], add [to] * for Set<Position> entityTo: remove [to], add [from] * Step3: adjust stateEntityMatrix: * */ //Step1: determine entity type of [from](entityFrom) & [to](entityTo) String typeFrom=this.checkEntityType(from); String typeTo=this.checkEntityType(to); Entity tempHolderFrom=this.getEntity(from); Entity tempHolderTo=this.getEntity(to); //debug //System.out.println(\"type of [from] :\"+typeFrom); switch (typeFrom){ case \"Player\": //\u63a8Player: \u53ea\u80fd\u5c06player\u63a8\u5230empty\u4e0a\uff0cfrom\u7684\u4f4d\u7f6e\u6307\u5411empty // update recordPlayers({Position : Player}) this.recordPlayers.put(to,(Player)tempHolderFrom); this.recordPlayers.remove(from); //update empties (Set<Position>) this.empties.remove(to); this.empties.add(from); // update 2d map: swap references this.stateEntityMatrix[to.y()][to.x()]=(Player)tempHolderFrom; this.stateEntityMatrix[from.y()][from.x()]=(Empty)tempHolderTo; // case: // ...B@. -> // ....B. -> \u6b63\u89e3\uff1aB\u539f\u5148\u7684\u4f4d\u5b50\u4e0d\u4f1a\u51fa\u73b0@ // ....@B ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(false); //\u5047\u5982from\u672c\u6765\u662fdestination\uff0c@\u7b26\u53f7\u88ab\u538b\u4f4f\uff0c\u5c31\u8981\u8ba9\u5b83\u91cd\u89c1\u5929\u65e5 for(Position pos:this.destinations){ if(pos.x()==from.x() && pos.y()==from.y()){ ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(true); } } break; case \"Box\": //Box: \u53ea\u80fd\u5c06box\u63a8\u5230empty\u4e0a\uff0cfrom\u7684\u4f4d\u7f6e\u6307\u5411empty // update recordBox({Position : Box}) this.recordBoxes.put(to,(Box)tempHolderFrom); this.recordBoxes.remove(from); //update empties (Set<Position>) this.empties.remove(to); this.empties.add(from); // update 2d map: swap references this.stateEntityMatrix[to.y()][to.x()]=(Box)tempHolderFrom; this.stateEntityMatrix[from.y()][from.x()]=(Empty)tempHolderTo; //\u4f46\u5047\u5982 to \u662fdestination\uff0c\u5c31\u4e0d\u5e94\u8be5\u628a\"@\"\u6807\u5fd7\u8ddf\u7740\u88abswap\u8d70\uff0c\u800c\u662f\u8981\u8ba9\u4ed6\u88ab\u76d6\u4f4f ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(false); break; default: break; } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(Position pos:recordPlayers.keySet()){ if (recordPlayers.get(pos).getId()==id){ return pos; } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.stateEntityMatrix[position.y()][position.x()]; }",
        "label": "P"
    },
    "1643": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public Optional<Integer> getUndoQuota() { // TODO if (this.undoLimit!=-1) return Optional.of(this.undoLimit); else return Optional.empty(); }",
        "label": "P"
    },
    "1644": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO return recordPlayers.keySet(); }",
        "label": "P"
    },
    "1645": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public void move(Position from, Position to) { // TODO /* * Step1: determine entity type of [from](entityFrom) & [to](entityTo) * Step2: for Set<Position> entityFrom: remove [from], add [to] * for Set<Position> entityTo: remove [to], add [from] * Step3: adjust stateEntityMatrix: * */ //Step1: determine entity type of [from](entityFrom) & [to](entityTo) String typeFrom=this.checkEntityType(from); String typeTo=this.checkEntityType(to); Entity tempHolderFrom=this.getEntity(from); Entity tempHolderTo=this.getEntity(to); //debug //System.out.println(\"type of [from] :\"+typeFrom); switch (typeFrom){ case \"Player\": //\u63a8Player: \u53ea\u80fd\u5c06player\u63a8\u5230empty\u4e0a\uff0cfrom\u7684\u4f4d\u7f6e\u6307\u5411empty // update recordPlayers({Position : Player}) this.recordPlayers.put(to,(Player)tempHolderFrom); this.recordPlayers.remove(from); //update empties (Set<Position>) this.empties.remove(to); this.empties.add(from); // update 2d map: swap references this.stateEntityMatrix[to.y()][to.x()]=(Player)tempHolderFrom; this.stateEntityMatrix[from.y()][from.x()]=(Empty)tempHolderTo; // case: // ...B@. -> // ....B. -> \u6b63\u89e3\uff1aB\u539f\u5148\u7684\u4f4d\u5b50\u4e0d\u4f1a\u51fa\u73b0@ // ....@B ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(false); //\u5047\u5982from\u672c\u6765\u662fdestination\uff0c@\u7b26\u53f7\u88ab\u538b\u4f4f\uff0c\u5c31\u8981\u8ba9\u5b83\u91cd\u89c1\u5929\u65e5 for(Position pos:this.destinations){ if(pos.x()==from.x() && pos.y()==from.y()){ ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(true); } } break; case \"Box\": //Box: \u53ea\u80fd\u5c06box\u63a8\u5230empty\u4e0a\uff0cfrom\u7684\u4f4d\u7f6e\u6307\u5411empty // update recordBox({Position : Box}) this.recordBoxes.put(to,(Box)tempHolderFrom); this.recordBoxes.remove(from); //update empties (Set<Position>) this.empties.remove(to); this.empties.add(from); // update 2d map: swap references this.stateEntityMatrix[to.y()][to.x()]=(Box)tempHolderFrom; this.stateEntityMatrix[from.y()][from.x()]=(Empty)tempHolderTo; //\u4f46\u5047\u5982 to \u662fdestination\uff0c\u5c31\u4e0d\u5e94\u8be5\u628a\"@\"\u6807\u5fd7\u8ddf\u7740\u88abswap\u8d70\uff0c\u800c\u662f\u8981\u8ba9\u4ed6\u88ab\u76d6\u4f4f ((Empty)this.stateEntityMatrix[from.y()][from.x()]).setDestination(false); break; default: break; } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO // hard-copy the current entity matrix, store it in recordEntityMatrix // [ Entity[][] mat1, Entity[][] mat2, ...] int row=this.stateEntityMatrix.length; int col=this.stateEntityMatrix[0].length; Entity[][] newRecord=new Entity[row][col]; for (int i=0;i<row;i++){ newRecord[i]=new Entity[col]; for(int j=0;j<col;j++){ // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.stateEntityMatrix[i][j]==null) continue; switch(this.stateEntityMatrix[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.stateEntityMatrix[i][j]).getPlayerId()); newRecord[i][j]=newbox; break; case \"Player\": Player newplayer=new Player(((Player)this.stateEntityMatrix[i][j]).getId()); newRecord[i][j]=newplayer; break; case \"Wall\": newRecord[i][j]=new Wall(); break; case \"Empty\": newRecord[i][j]=new Empty(); ((Empty)newRecord[i][j]).setDestination(((Empty)this.stateEntityMatrix[i][j]).checkDestination()); break; default: break; } } } this.recordEntityMatrix.add(newRecord); } public void undo() { // TODO //retrieve the LAST record from recordEntityMatrix //copy related instance variables from this record this.empties.clear(); this.walls.clear(); this.recordPlayers.clear(); this.recordBoxes.clear(); Entity[][] lastRecord=null; if(this.recordEntityMatrix.size()>1){ lastRecord=this.recordEntityMatrix.get(recordEntityMatrix.size()-2); if(!this.getUndoQuota().isEmpty()) this.undoLimit--; } else { lastRecord = this.initialState; /* Undo quota is only deducted when a checkpoint is reverted. So if there are no checkpoints, undo quota will not be deducted. * */ if(this.recordEntityMatrix.size()==1 && !this.getUndoQuota().isEmpty()) this.undoLimit--; } int row=lastRecord.length; int col=lastRecord[0].length; this.stateEntityMatrix=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; for(int j=0;j<col;j++){ // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(lastRecord[i][j]==null) continue; switch(lastRecord[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)lastRecord[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)lastRecord[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); this.walls.add(Position.of(j,i)); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); this.empties.add(Position.of(j,i)); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)lastRecord[i][j]).checkDestination()); break; default: break; } } } //remove latest record of Entity[][] if(!this.recordEntityMatrix.isEmpty()){ this.recordEntityMatrix.remove(recordEntityMatrix.size()-1); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for(Position pos:recordPlayers.keySet()){ if (recordPlayers.get(pos).getId()==id){ return pos; } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.stateEntityMatrix[position.y()][position.x()]; } public Optional<Integer> getUndoQuota() { // TODO if (this.undoLimit!=-1) return Optional.of(this.undoLimit); else return Optional.empty(); }",
        "label": "P"
    },
    "1646": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(); } public void run() { // TODO int currentPlayerID=0; // to rotate around players; //first call: print welcome message this.renderingEngine.message(StringResources.GAME_READY_MESSAGE); this.renderingEngine.render(state); while(!this.shouldStop()){ //game body //read input //process action Action fetchedAction=this.inputEngine.fetchAction(); ActionResult processedAction=this.processAction(fetchedAction); //if fail:print message while(processedAction instanceof Failed failed){ this.renderingEngine.message(((Failed)processedAction).getReason()); this.renderingEngine.render(this.state); //print undo quota if(this.state.getUndoQuota().isEmpty()){ this.renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,-1)); }else if (this.state.getUndoQuota().get().intValue()==-1){ this.renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,StringResources.UNDO_QUOTA_UNLIMITED)); }else{ this.renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,state.getUndoQuota().get().intValue())); } processedAction=this.processAction(this.inputEngine.fetchAction()); } this.renderingEngine.render(this.state); //exit: if (this.hasExit||this.state.isWin()){ this.renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if(this.state.isWin()){ this.renderingEngine.message(StringResources.WIN_MESSAGE); } break; } //print undo quota if(this.state.getUndoQuota().isEmpty()){ this.renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,-1)); }else{ this.renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE,this.state.getUndoQuota().get().intValue())); } } }",
        "label": "P"
    },
    "1647": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size()>2) throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "1648": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. this.outputSteam.print(content+System.lineSeparator()); }",
        "label": "P"
    },
    "1649": {
        "dataset": "COMP 3021",
        "project": "yxiaoaz",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map=map; this.undoLimit=this.map.undoLimit; this.recordEntityMatrix=new ArrayList<Entity[][]>(); //deep copy the Set<Position> records this.recordBoxes = new HashMap<Position, Box>(); this.recordPlayers = new HashMap<Position, Player>(); this.walls = new HashSet<Position>(); this.empties = new HashSet<Position>(); this.destinations = new HashSet<Position>(); for (Position pos : this.map.walls) { this.walls.add(pos); } for (Position pos : this.map.empties) { this.empties.add(pos); } for (Position pos : this.map.destinations) { this.destinations.add(pos); } for (Position pos : this.map.walls) { this.walls.add(pos); } // deep copy a Entity[][] database int row=this.map.entityMatrixStorage.length; int col=this.map.entityMatrixStorage[0].length; this.stateEntityMatrix=new Entity[row][col]; this.initialState=new Entity[row][col]; for (int i=0;i<row;i++){ stateEntityMatrix[i]=new Entity[col]; initialState[i]=new Entity[col]; for(int j=0;j<col;j++){ //System.out.println(\"i: \"+i+\" j: \"+j+\" ->\"+map.entityMatrixStorage[i][j]); // \u5899\u5916\u6ca1entity\u7684block\uff0c\u662fnull if(this.map.entityMatrixStorage[i][j]==null) continue; switch(this.map.entityMatrixStorage[i][j].getClass().getSimpleName()){ case \"Box\": // getPlayerId() only in Box, needs to downcast Entity to Box Box newbox=new Box(((Box)this.map.entityMatrixStorage[i][j]).getPlayerId()); stateEntityMatrix[i][j]=newbox; initialState[i][j]=newbox; recordBoxes.put(Position.of(j,i),newbox); break; case \"Player\": Player newplayer=new Player(((Player)this.map.entityMatrixStorage[i][j]).getId()); stateEntityMatrix[i][j]=newplayer; initialState[i][j]=newplayer; recordPlayers.put(Position.of(j,i),newplayer); break; case \"Wall\": stateEntityMatrix[i][j]=new Wall(); initialState[i][j]=new Wall(); break; case \"Empty\": stateEntityMatrix[i][j]=new Empty(); ((Empty)stateEntityMatrix[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); initialState[i][j]=new Empty(); ((Empty)initialState[i][j]).setDestination(((Empty)this.map.entityMatrixStorage[i][j]).checkDestination()); break; default: break; } } } } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { final var builder = new StringBuilder(); for (int y = 0; y < state.getMapMaxHeight(); y++) { for (int x = 0; x < state.getMapMaxWidth(); x++) { if(state.getEntity(Position.of(x, y))!=null && state.getEntity(Position.of(x, y)) instanceof Empty emp && (emp.checkDestination())) { builder.append('@'); continue; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1650": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return width; } public int getMaxHeight() { // TODO return height; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(undoLimit); }",
        "label": "P"
    },
    "1651": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1652": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1653": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1654": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1655": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1656": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entityPositions.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1657": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entityPositions.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1658": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return height; }",
        "label": "P"
    },
    "1659": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return width; }",
        "label": "P"
    },
    "1660": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entityPositions.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1661": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entityPositions.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1662": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entityPositions.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1663": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entityPositions.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1664": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO switch (inputLine.toLowerCase()) { case \"a\": return new Move.Left(0); case \"s\": return new Move.Down(0); case \"w\": return new Move.Up(0); case \"d\": return new Move.Right(0); case \"h\": return new Move.Left(1); case \"j\": return new Move.Down(1); case \"k\": return new Move.Up(1); case \"l\": return new Move.Right(1); case \"u\": return new Undo(-1); case \"exit\": return new Exit(-1); default: return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "1665": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public void move(Position from, Position to) { // TODO Entity fromEntity = getEntity(from); Entity toEntity = getEntity(to); entityPositions.replace(from, toEntity); entityPositions.replace(to, fromEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1666": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public void move(Position from, Position to) { // TODO Entity fromEntity = getEntity(from); Entity toEntity = getEntity(to); entityPositions.replace(from, toEntity); entityPositions.replace(to, fromEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Entity> e : entityPositions.entrySet()) { if (e.getValue().getClass() == Player.class) { if (((Player) e.getValue()).getId() == id) { return e.getKey(); } } } return null; // return null if not found }",
        "label": "P"
    },
    "1667": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public void move(Position from, Position to) { // TODO Entity fromEntity = getEntity(from); Entity toEntity = getEntity(to); entityPositions.replace(from, toEntity); entityPositions.replace(to, fromEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Entity> e : entityPositions.entrySet()) { if (e.getValue().getClass() == Player.class) { if (((Player) e.getValue()).getId() == id) { return e.getKey(); } } } return null; // return null if not found } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entityPositions.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1668": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public Optional<Integer> getUndoQuota() { // TODO if (undoQuota == -1) { return Optional.empty(); } else { return Optional.of(undoQuota); } }",
        "label": "P"
    },
    "1669": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> playerPositions = new HashSet<>(); for (Map.Entry<Position, Entity> e : entityPositions.entrySet()) { if (e.getValue().getClass() == Player.class) { playerPositions.add(e.getKey()); } } return playerPositions; }",
        "label": "P"
    },
    "1670": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public void move(Position from, Position to) { // TODO Entity fromEntity = getEntity(from); Entity toEntity = getEntity(to); entityPositions.replace(from, toEntity); entityPositions.replace(to, fromEntity); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO history.add(new Checkpoint(undoQuota, new HashMap<>(entityPositions))); } public void undo() { // TODO if (history.size() >= 1) { if (undoQuota != -1) { undoQuota -= 1; } history.remove(history.size()-1); //remove last checkpoint } if (history.size() == 0) { entityPositions = new HashMap<>(map.positionEntityMap); } else { entityPositions = new HashMap<>(history.get(history.size()-1).positionEntityMap); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (Map.Entry<Position, Entity> e : entityPositions.entrySet()) { if (e.getValue().getClass() == Player.class) { if (((Player) e.getValue()).getId() == id) { return e.getKey(); } } } return null; // return null if not found } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return entityPositions.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (undoQuota == -1) { return Optional.empty(); } else { return Optional.of(undoQuota); } }",
        "label": "P"
    },
    "1671": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } } public void run() { // TODO renderingEngine.message(StringResources.GAME_READY_MESSAGE); // Sokoban game is ready while (!shouldStop()) { renderingEngine.render(state); // print game map renderingEngine.message(\"\"); // skip a line String undoLimit; if (state.getUndoQuota().isPresent()) { // creating undo quota String undoLimit = String.format(StringResources.UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get()); } else { undoLimit = String.format(StringResources.UNDO_QUOTA_TEMPLATE, StringResources.UNDO_QUOTA_UNLIMITED); } renderingEngine.message(String.format(undoLimit)); // print undo quota renderingEngine.message(\">>>\"); ActionResult result = processAction(inputEngine.fetchAction()); // fetch user input if (result.getClass() == ActionResult.Failed.class) { renderingEngine.message(((ActionResult.Failed) result).getReason()); } } renderingEngine.render(state); renderingEngine.message(\"\"); renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(StringResources.WIN_MESSAGE); } return; }",
        "label": "P"
    },
    "1672": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "1673": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1674": {
        "dataset": "COMP 3021",
        "project": "ltgu",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; undoQuota = map.undoLimit; entityPositions = new HashMap<>(map.positionEntityMap); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1675": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; } public int getMaxHeight() { // TODO return maxHeight; } public Optional<Integer> getUndoLimit() { // TODO if (undoLimit != -1){ return Optional.of(undoLimit); } return Optional.empty(); }",
        "label": "P"
    },
    "1676": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1677": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1678": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1679": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1680": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1681": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1682": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1683": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; }",
        "label": "P"
    },
    "1684": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; }",
        "label": "P"
    },
    "1685": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1686": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1687": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1688": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1689": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO switch(inputLine){ case \"exit\": return new Exit(0); case \"a\": return new Move.Left(0); case \"s\": return new Move.Down(0); case \"w\": return new Move.Up(0); case \"d\": return new Move.Right(0); case \"h\": return new Move.Left(1); case \"j\": return new Move.Down(1); case \"k\": return new Move.Up(1); case \"l\": return new Move.Right(1); case \"u\": return new Undo(0); default: return new InvalidInput(0, StringResources.INVALID_INPUT_MESSAGE); } }",
        "label": "P"
    },
    "1690": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public void move(Position from, Position to) { // TODO switch(this.getEntity(from)){ case Player o -> { playersLoc.put(o.getId(), to); this.map.get(to.y()).set(to.x(), o); this.map.get(from.y()).set(from.x(), new Empty()); } case Box o -> { int index = boxesLoc.get(o.getPlayerId()).indexOf(from); boxesLoc.get(o.getPlayerId()).set(index, to); this.map.get(to.y()).set(to.x(), o); this.map.get(from.y()).set(from.x(), new Empty()); } case Object o -> {} } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1691": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public void move(Position from, Position to) { // TODO switch(this.getEntity(from)){ case Player o -> { playersLoc.put(o.getId(), to); this.map.get(to.y()).set(to.x(), o); this.map.get(from.y()).set(from.x(), new Empty()); } case Box o -> { int index = boxesLoc.get(o.getPlayerId()).indexOf(from); boxesLoc.get(o.getPlayerId()).set(index, to); this.map.get(to.y()).set(to.x(), o); this.map.get(from.y()).set(from.x(), new Empty()); } case Object o -> {} } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.playersLoc.get(id); }",
        "label": "P"
    },
    "1692": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public void move(Position from, Position to) { // TODO switch(this.getEntity(from)){ case Player o -> { playersLoc.put(o.getId(), to); this.map.get(to.y()).set(to.x(), o); this.map.get(from.y()).set(from.x(), new Empty()); } case Box o -> { int index = boxesLoc.get(o.getPlayerId()).indexOf(from); boxesLoc.get(o.getPlayerId()).set(index, to); this.map.get(to.y()).set(to.x(), o); this.map.get(from.y()).set(from.x(), new Empty()); } case Object o -> {} } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.playersLoc.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1693": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota; }",
        "label": "P"
    },
    "1694": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> allPlayers = new HashSet<Position>(); for (int i : playersLoc.keySet()){ allPlayers.add(playersLoc.get(i)); } return allPlayers; }",
        "label": "P"
    },
    "1695": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public void move(Position from, Position to) { // TODO switch(this.getEntity(from)){ case Player o -> { playersLoc.put(o.getId(), to); this.map.get(to.y()).set(to.x(), o); this.map.get(from.y()).set(from.x(), new Empty()); } case Box o -> { int index = boxesLoc.get(o.getPlayerId()).indexOf(from); boxesLoc.get(o.getPlayerId()).set(index, to); this.map.get(to.y()).set(to.x(), o); this.map.get(from.y()).set(from.x(), new Empty()); } case Object o -> {} } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (ArrayList<Entity> row : this.map){ ArrayList<Entity> newRow = new ArrayList<Entity>(); for (Entity e : row){ switch(e){ case Player o -> newRow.add(new Player(o.getId())); case Box o -> newRow.add(new Box(o.getPlayerId())); case Wall o -> newRow.add(new Wall()); case Empty o -> newRow.add(new Empty()); case null -> newRow.add(null); case Object o -> throw new IllegalArgumentException(); } } newMap.add(newRow); } this.checkpointMap.add(newMap); this.checkpointPlayers.add(this.playersLoc); this.checkpointBoxes.add(this.boxesLoc); } public void undo() { // TODO // if no checkpoint int index = 0; int end = 1; if (checkpointMap.size() >= 2){ int size = checkpointMap.size(); index = size - 2; end = size - 1; } ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (ArrayList<Entity> row : this.checkpointMap.get(index)){ ArrayList<Entity> newRow = new ArrayList<Entity>(); for (Entity e : row){ switch(e){ case Player o -> newRow.add(new Player(o.getId())); case Box o -> newRow.add(new Box(o.getPlayerId())); case Wall o -> newRow.add(new Wall()); case Empty o -> newRow.add(new Empty()); case null -> newRow.add(null); case Object o -> throw new IllegalArgumentException(); } } newMap.add(newRow); } this.map = newMap; HashMap<Integer, Position> temp = new HashMap<Integer, Position>(); for (int key : this.checkpointPlayers.get(index).keySet()){ temp.put(key, this.checkpointPlayers.get(index).get(key)); } this.playersLoc = temp; HashMap<Integer, ArrayList<Position>> temp2 = new HashMap<Integer, ArrayList<Position>>(); for (int key : this.checkpointBoxes.get(index).keySet()){ ArrayList<Position> temp3 = new ArrayList<Position>(); for (int j = 0; j < this.checkpointBoxes.get(index).get(key).size(); j++){ temp3.add(this.checkpointBoxes.get(index).get(key).get(j)); } temp2.put(key, temp3); } this.boxesLoc = temp2; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(this.checkpointMap.subList(0, end)); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(this.checkpointPlayers.subList(0, end)); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(this.checkpointBoxes.subList(0, end)); if (this.undoQuota.isPresent()){ int newQuota = this.undoQuota.get() - 1; this.undoQuota = Optional.of(newQuota); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO return this.playersLoc.get(id); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.map.get(position.y()).get(position.x()); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota; }",
        "label": "P"
    },
    "1696": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players int numPlayers = gameState.getAllPlayerPositions().size(); if (numPlayers > 2) { throw new IllegalArgumentException(); } } public void run() { // TODO Optional<Integer> quota = this.state.getUndoQuota(); this.renderingEngine.message(StringResources.GAME_READY_MESSAGE); while (!this.shouldStop()) { quota = this.state.getUndoQuota(); this.renderingEngine.render(this.state); if (quota.isEmpty()){ this.renderingEngine.message(StringResources.UNDO_QUOTA_UNLIMITED); } else { this.renderingEngine.message(String.format(StringResources.UNDO_QUOTA_TEMPLATE, Integer.toString(quota.get()))); } this.renderingEngine.message(\">>>\"); Action inputAction = this.inputEngine.fetchAction(); ActionResult result = this.processAction(inputAction); if (result instanceof ActionResult.Failed){ if (result.getAction() instanceof Exit) { this.renderingEngine.render(this.state); break; } this.renderingEngine.message(((ActionResult.Failed) result).getReason()); } } this.renderingEngine.render(this.state); this.renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (this.state.isWin()){ this.renderingEngine.message(StringResources.WIN_MESSAGE); } }",
        "label": "F"
    },
    "1697": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players int numPlayers = gameState.getAllPlayerPositions().size(); if (numPlayers > 2) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "1698": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO outputSteam.println(content); // Hint: System.out is also a PrintStream. }",
        "label": "P"
    },
    "1699": {
        "dataset": "COMP 3021",
        "project": "fslok",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.originalMap = map; this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoQuota = map.getUndoLimit(); this.playersLoc = new HashMap<Integer, Position>(); HashMap<Integer, Position> players = new HashMap<Integer, Position>(); this.boxesLoc = new HashMap<Integer, ArrayList<Position>>(); HashMap<Integer, ArrayList<Position>> boxes = new HashMap<Integer, ArrayList<Position>>(); ArrayList<ArrayList<Entity>> newMap = new ArrayList<ArrayList<Entity>>(); for (int i = 0; i < map.getMap().size(); i++) { ArrayList<Entity> row = new ArrayList<Entity>(); for (int j = 0; j < map.getMap().get(i).size(); j++) { Object item = map.getMap().get(i).get(j); if (item instanceof Player){ row.add((Player) item); players.put(((Player) item).getId(), new Position(j, i)); this.playersLoc.put(((Player) item).getId(), new Position(j, i)); } else if (item instanceof Box){ Box box = (Box) item; row.add((Box) item); if (boxes.containsKey(box.getPlayerId())) { boxes.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); boxes.put(box.getPlayerId(), boxesLoc); } if (this.boxesLoc.containsKey(box.getPlayerId())) { this.boxesLoc.get(box.getPlayerId()).add(new Position(j, i)); } else { ArrayList<Position> boxesLoc = new ArrayList<Position>(); boxesLoc.add(new Position(j, i)); this.boxesLoc.put(box.getPlayerId(), boxesLoc); } } else if (item instanceof Wall){ row.add((Wall) item); } else { row.add((Empty) item); } } newMap.add(row); } this.map = newMap; this.checkpointMap = new ArrayList<ArrayList<ArrayList<Entity>>>(); this.checkpointMap.add(map.getMap()); this.checkpointPlayers = new ArrayList<HashMap<Integer, Position>>(); this.checkpointPlayers.add(players); this.checkpointBoxes = new ArrayList<HashMap<Integer, ArrayList<Position>>>(); this.checkpointBoxes.add(boxes); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { final var builder = new StringBuilder(); for (int y = 0; y < state.getMapMaxHeight(); y++) { for (int x = 0; x < state.getMapMaxWidth(); x++) { var charToPrint = ' '; if (x > state.getMap().get(y).size() - 1){ charToPrint = ' '; } else { if (state.getDestinations().contains(new Position(x, y))) { if (state.getEntity(Position.of(x, y)) instanceof Box){ Box box = (Box) state.getEntity(Position.of(x, y)); charToPrint = (char) ('a' + box.getPlayerId()); }else if (state.getEntity(Position.of(x, y)) instanceof Player){ Player player = (Player) state.getEntity(Position.of(x, y)); charToPrint = (char) ('A' + player.getId()); } else{ charToPrint = '@'; } } else { final var entity = state.getEntity(Position.of(x, y)); charToPrint = switch (entity) { // TODO case Wall ignored -> '#'; case Box b -> (char) ('a' + b.getPlayerId()); case Player p -> (char) ('A' + p.getId()); case Empty ignored -> '.'; case null -> ' '; }; } } builder.append(charToPrint); } builder.append('\\n'); } outputSteam.print(builder); }",
        "label": "P"
    },
    "1700": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; //throw new NotImplementedException(); } public int getMaxHeight() { // TODO return maxHeight; //throw new NotImplementedException(); } public Optional<Integer> getUndoLimit() { // TODO if(undolimit >= 0)return Optional.of(undolimit); return Optional.empty(); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1701": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1702": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1703": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1704": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1705": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1706": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(map.nullplace.contains(position)) return null; if(position.x() < 0 || position.x() >= getMapMaxWidth()) return null; if(position.y() < 0 || position.y() >= getMapMaxHeight()) return null; if(map.walls.contains(position)) return new Wall(); for(int i = 0; i < 26; i++) if(boxLocation[i].contains(position)) return new Box(i); for(int i = 0; i < 26; i++) if(playerLocation[i] != null && playerLocation[i].equals(position)) return new Player(i); return new Empty(); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1707": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(map.nullplace.contains(position)) return null; if(position.x() < 0 || position.x() >= getMapMaxWidth()) return null; if(position.y() < 0 || position.y() >= getMapMaxHeight()) return null; if(map.walls.contains(position)) return new Wall(); for(int i = 0; i < 26; i++) if(boxLocation[i].contains(position)) return new Box(i); for(int i = 0; i < 26; i++) if(playerLocation[i] != null && playerLocation[i].equals(position)) return new Player(i); return new Empty(); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1708": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1709": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1710": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.destinations; //throw new NotImplementedException(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(map.nullplace.contains(position)) return null; if(position.x() < 0 || position.x() >= getMapMaxWidth()) return null; if(position.y() < 0 || position.y() >= getMapMaxHeight()) return null; if(map.walls.contains(position)) return new Wall(); for(int i = 0; i < 26; i++) if(boxLocation[i].contains(position)) return new Box(i); for(int i = 0; i < 26; i++) if(playerLocation[i] != null && playerLocation[i].equals(position)) return new Player(i); return new Empty(); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1711": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(map.nullplace.contains(position)) return null; if(position.x() < 0 || position.x() >= getMapMaxWidth()) return null; if(position.y() < 0 || position.y() >= getMapMaxHeight()) return null; if(map.walls.contains(position)) return new Wall(); for(int i = 0; i < 26; i++) if(boxLocation[i].contains(position)) return new Box(i); for(int i = 0; i < 26; i++) if(playerLocation[i] != null && playerLocation[i].equals(position)) return new Player(i); return new Empty(); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1712": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(map.nullplace.contains(position)) return null; if(position.x() < 0 || position.x() >= getMapMaxWidth()) return null; if(position.y() < 0 || position.y() >= getMapMaxHeight()) return null; if(map.walls.contains(position)) return new Wall(); for(int i = 0; i < 26; i++) if(boxLocation[i].contains(position)) return new Box(i); for(int i = 0; i < 26; i++) if(playerLocation[i] != null && playerLocation[i].equals(position)) return new Player(i); return new Empty(); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1713": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(map.nullplace.contains(position)) return null; if(position.x() < 0 || position.x() >= getMapMaxWidth()) return null; if(position.y() < 0 || position.y() >= getMapMaxHeight()) return null; if(map.walls.contains(position)) return new Wall(); for(int i = 0; i < 26; i++) if(boxLocation[i].contains(position)) return new Box(i); for(int i = 0; i < 26; i++) if(playerLocation[i] != null && playerLocation[i].equals(position)) return new Player(i); return new Empty(); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1714": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); //System.out.println(inputLine); // TODO Action action = switch (inputLine.toUpperCase()) { case \"A\"-> new Move.Left(0); case \"S\"-> new Move.Down(0); case \"W\"-> new Move.Up(0); case \"D\"-> new Move.Right(0); case \"H\"-> new Move.Left(1); case \"J\"-> new Move.Down(1); case \"K\"-> new Move.Up(1); case \"L\"-> new Move.Right(1); case \"U\"-> new Undo(-1); case \"EXIT\" ->new Exit(-1); default -> new InvalidInput(-1,INVALID_INPUT_MESSAGE); }; //System.out.println(action.getClass()); return action; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1715": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity entity = getEntity(from); if(entity.getClass() == Box.class){ boxLocation[((Box) entity).getPlayerId()].remove(from); boxLocation[((Box) entity).getPlayerId()].add(to); } if(entity.getClass() == Player.class) { playerLocation[((Player) entity).getId()] = to; } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1716": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity entity = getEntity(from); if(entity.getClass() == Box.class){ boxLocation[((Box) entity).getPlayerId()].remove(from); boxLocation[((Box) entity).getPlayerId()].add(to); } if(entity.getClass() == Player.class) { playerLocation[((Player) entity).getId()] = to; } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if(id < 0 || id > 25) return null; return playerLocation[id]; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1717": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity entity = getEntity(from); if(entity.getClass() == Box.class){ boxLocation[((Box) entity).getPlayerId()].remove(from); boxLocation[((Box) entity).getPlayerId()].add(to); } if(entity.getClass() == Player.class) { playerLocation[((Player) entity).getId()] = to; } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO if(id < 0 || id > 25) return null; return playerLocation[id]; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(map.nullplace.contains(position)) return null; if(position.x() < 0 || position.x() >= getMapMaxWidth()) return null; if(position.y() < 0 || position.y() >= getMapMaxHeight()) return null; if(map.walls.contains(position)) return new Wall(); for(int i = 0; i < 26; i++) if(boxLocation[i].contains(position)) return new Box(i); for(int i = 0; i < 26; i++) if(playerLocation[i] != null && playerLocation[i].equals(position)) return new Player(i); return new Empty(); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1718": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public Optional<Integer> getUndoQuota() { // TODO if(undoQuota>=0)return Optional.of(undoQuota); return Optional.empty(); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1719": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> locations = new HashSet<Position>(); for(int i = 0; i < 26; i++) if(playerLocation[i] != null) locations.add(playerLocation[i]); return locations; //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1720": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public void move(Position from, Position to) { // TODO Entity entity = getEntity(from); if(entity.getClass() == Box.class){ boxLocation[((Box) entity).getPlayerId()].remove(from); boxLocation[((Box) entity).getPlayerId()].add(to); } if(entity.getClass() == Player.class) { playerLocation[((Player) entity).getId()] = to; } //throw new NotImplementedException(); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO checkPoints.push(new CheckPoint(playerLocation,boxLocation)); //System.out.println(playerLocation[0]); //System.out.println(checkPoints.get(0).playerLocation[0]); //throw new NotImplementedException(); } public void undo() { // TODO //System.out.println(\"stacksize:\"+checkPoints.size()); if(undoQuota != -1) undoQuota--; if(checkPoints.isEmpty()){ for(int i = 0; i < 26; i++) { if(map.players[i] != null) playerLocation[i] = new Position(map.players[i].x(),map.players[i].y()); else playerLocation[i] = null; } for(int i = 0; i < 26; i++) { boxLocation[i].clear(); for (int j = 0; j < map.boxes[i].size(); j++) { boxLocation[i] = new ArrayList<Position>(); boxLocation[i] = (ArrayList<Position>) ((ArrayList) (map.boxes[i])).clone(); } } return; } checkPoints.pop(); if(checkPoints.isEmpty()){ for(int i = 0; i < 26; i++) { if(map.players[i] != null) playerLocation[i] = new Position(map.players[i].x(),map.players[i].y()); else playerLocation[i] = null; } for(int i = 0; i < 26; i++) { boxLocation[i].clear(); for (int j = 0; j < map.boxes[i].size(); j++){ boxLocation[i] = new ArrayList<Position>(); boxLocation[i] = (ArrayList<Position>) ((ArrayList) (map.boxes[i])).clone(); } } return; } CheckPoint cp = checkPoints.pop(); for(int i = 0; i < 26; i++) { if(cp.playerLocation[i] != null) playerLocation[i] = new Position(cp.playerLocation[i].x(),cp.playerLocation[i].y()); else playerLocation[i] = null; } for(int i = 0; i < 26; i++) { boxLocation[i].clear(); for (int j = 0; j < cp.boxLocation[i].size(); j++){ boxLocation[i] = new ArrayList<Position>(); boxLocation[i] = (ArrayList<Position>) ((ArrayList) (cp.boxLocation[i])).clone(); } } return; //throw new NotImplementedException(); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO if(id < 0 || id > 25) return null; return playerLocation[id]; //throw new NotImplementedException(); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO if(map.nullplace.contains(position)) return null; if(position.x() < 0 || position.x() >= getMapMaxWidth()) return null; if(position.y() < 0 || position.y() >= getMapMaxHeight()) return null; if(map.walls.contains(position)) return new Wall(); for(int i = 0; i < 26; i++) if(boxLocation[i].contains(position)) return new Box(i); for(int i = 0; i < 26; i++) if(playerLocation[i] != null && playerLocation[i].equals(position)) return new Player(i); return new Empty(); //throw new NotImplementedException(); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if(undoQuota>=0)return Optional.of(undoQuota); return Optional.empty(); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1721": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players int numOfPlayer = gameState.getAllPlayerPositions().size(); if(numOfPlayer > 2) throw new IllegalArgumentException(); //throw new NotImplementedException(); } public void run() { // TODO // Set<Integer> playerIds = state.map.getPlayerIds(); // for(int i : playerIds){ // if(i != 0 && i != 1){ // renderingEngine.message(INVALID_INPUT_MESSAGE); // return; // } // } if(state.getUndoQuota().isPresent() && state.getUndoQuota().get() < 0 && state.getUndoQuota().get() != -1) { renderingEngine.message(INVALID_INPUT_MESSAGE); return; } renderingEngine.message(GAME_READY_MESSAGE); Action action; ActionResult result; while(true) { if(state.getUndoQuota().isPresent()) renderingEngine.message(UNDO_QUOTA_TEMPLATE.formatted(state.getUndoQuota().get().toString())); else renderingEngine.message(UNDO_QUOTA_UNLIMITED); renderingEngine.render(state); action = inputEngine.fetchAction(); if(action instanceof Exit){ renderingEngine.message(GAME_EXIT_MESSAGE); break; } result = processAction(action); //System.out.println(action.getClass()); if(result instanceof ActionResult.Failed) renderingEngine.message((((ActionResult.Failed)result).getReason())); if(state.isWin()) { renderingEngine.message(WIN_MESSAGE); break; } } renderingEngine.render(state); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1722": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players int numOfPlayer = gameState.getAllPlayerPositions().size(); if(numOfPlayer > 2) throw new IllegalArgumentException(); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1723": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO outputSteam.println(content); // Hint: System.out is also a PrintStream. //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1724": {
        "dataset": "COMP 3021",
        "project": "mlinam",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; playerLocation = map.players.clone(); for(int i = 0; i < 26; i++) for(int j = 0; j < map.boxes[i].size();j++) boxLocation[i].add(map.boxes[i].get(j)); undoQuota = map.undolimit; //throw new NotImplementedException(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1725": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { Optional<Integer> opt = Optional.ofNullable(undoLimit); return opt; }",
        "label": "P"
    },
    "1726": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1727": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1728": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1729": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1730": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1731": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1732": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1733": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "1734": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "1735": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1736": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1737": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1738": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1739": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); switch(inputLine.toUpperCase(Locale.ROOT)){ //Player 1 case \"W\": return new Move.Up(0); case \"A\": return new Move.Left(0); case \"S\": return new Move.Down(0); case \"D\": return new Move.Right(0); //Player 2 case \"I\": return new Move.Up(1); case \"J\": return new Move.Left(1); case \"K\": return new Move.Down(1); case \"L\": return new Move.Right(1); case \"EXIT\": return new Exit(0); case \"U\": return new Undo(0); default: return new InvalidInput(0, \".\"); } }",
        "label": "P"
    },
    "1740": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public void move(Position from, Position to) { Entity entity = map.getEntity(from); map.putEntity(to, entity); map.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1741": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public void move(Position from, Position to) { Entity entity = map.getEntity(from); map.putEntity(to, entity); map.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for(int i = 0 ; i < map.getMaxWidth() ; i++){ for(int j = 0 ; j < map.getMaxHeight() ; j++){ Entity entity = this.getEntity(Position.of(i, j)); if(entity instanceof Player){ Player player = ((Player) entity); if(player.getId() == id){ return Position.of(i, j); } } } } return null; }",
        "label": "P"
    },
    "1742": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public void move(Position from, Position to) { Entity entity = map.getEntity(from); map.putEntity(to, entity); map.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for(int i = 0 ; i < map.getMaxWidth() ; i++){ for(int j = 0 ; j < map.getMaxHeight() ; j++){ Entity entity = this.getEntity(Position.of(i, j)); if(entity instanceof Player){ Player player = ((Player) entity); if(player.getId() == id){ return Position.of(i, j); } } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1743": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public Optional<Integer> getUndoQuota() { return map.getUndoLimit(); }",
        "label": "P"
    },
    "1744": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { Set<Position> result = new HashSet<Position>(); for(int i = 0 ; i < map.getMaxWidth() ; i++){ for(int j = 0 ; j < map.getMaxHeight() ; j++){ Entity entity = this.getEntity(Position.of(i, j)); if(entity instanceof Player){ Position position = Position.of(i, j); result.add(position); } } } return result; }",
        "label": "P"
    },
    "1745": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public void move(Position from, Position to) { Entity entity = map.getEntity(from); map.putEntity(to, entity); map.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { checkPoints.add(this.map.clone()); } public void undo() { if(getUndoQuota().isEmpty()) { System.err.println(\"getUndoQuota().isEmpty()\"); return; } int quota = getUndoQuota().get(); if(quota > 0) { if (checkPoints.size() <= 1) { //Do nothing System.out.println(\"do nothing because not enough check point\"); } else { map = checkPoints.get(checkPoints.size() - 2); //set current map to latest recorded map checkPoints.remove(checkPoints.size() - 1); //remove latest recorded map map.undoLimit = quota-1; } }else{ System.out.println(\"You have run out of your undo quota.\"); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { for(int i = 0 ; i < map.getMaxWidth() ; i++){ for(int j = 0 ; j < map.getMaxHeight() ; j++){ Entity entity = this.getEntity(Position.of(i, j)); if(entity instanceof Player){ Player player = ((Player) entity); if(player.getId() == id){ return Position.of(i, j); } } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { return map.getUndoLimit(); }",
        "label": "P"
    },
    "1746": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; } public void run() { renderingEngine.render(state); renderingEngine.message(\"Undo quota: \"+(state.getUndoQuota().isEmpty()?0:state.getUndoQuota().get())); if(shouldStop()){ //System.exit(0); return; } Action action = inputEngine.fetchAction(); processAction(action); run(); }",
        "label": "P"
    },
    "1747": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; }",
        "label": "P"
    },
    "1748": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // Hint: System.out is also a PrintStream. System.setOut(outputSteam); System.out.println(content); }",
        "label": "P"
    },
    "1749": {
        "dataset": "COMP 3021",
        "project": "yhchoiaa",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; checkpoint(); //set first checkpoint to initial form of map } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void render(@NotNull GameState state) { final var builder = new StringBuilder(); for (int y = 0; y < state.getMapMaxHeight(); y++) { for (int x = 0; x < state.getMapMaxWidth(); x++) { Position position = Position.of(x, y); char charToPrint = ' '; //Render final var entity = state.getEntity(position); if(entity instanceof Wall){ charToPrint = '#'; }else if(entity instanceof Box){ Box box = (Box)entity; charToPrint = (char)('a'+box.getPlayerId()); }else if(entity instanceof Player){ Player player = (Player)entity; charToPrint = (char)('A'+player.getId()); }else if(state.getDestinations().contains(position)){ charToPrint = '@'; }else if(entity instanceof Empty){ charToPrint = '.'; }else if(entity == null){ charToPrint = ' '; } builder.append(charToPrint); } builder.append('\\n'); } outputSteam.print(builder); }",
        "label": "P"
    },
    "1750": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { return undoLimit >= 0 ? Optional.of(undoLimit) : Optional.empty(); }",
        "label": "P"
    },
    "1751": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1752": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1753": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1754": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1755": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1756": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1757": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1758": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "1759": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "1760": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return gameMap.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1761": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1762": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1763": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1764": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine().toLowerCase(); if (inputLine.length() == 1) { char c = inputLine.charAt(0); if (c == 'a') return new Move.Left(0); else if (c == 's') return new Move.Down(0); else if (c == 'w') return new Move.Up(0); else if (c == 'd') return new Move.Right(0); else if (c == 'h') return new Move.Left(1); else if (c == 'j') return new Move.Down(1); else if (c == 'k') return new Move.Up(1); else if (c == 'l') return new Move.Right(1); else if (c == 'u') return new Undo(-1); else return new InvalidInput(-1, INVALID_INPUT_MESSAGE); } else if (inputLine.equals(EXIT_COMMAND_TEXT)) return new Exit(-1); else return new InvalidInput(-1, INVALID_INPUT_MESSAGE); }",
        "label": "P"
    },
    "1765": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public void move(Position from, Position to) { gameMap.move(from, to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1766": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public void move(Position from, Position to) { gameMap.move(from, to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return gameMap.getPlayerPositionById(id); }",
        "label": "P"
    },
    "1767": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public void move(Position from, Position to) { gameMap.move(from, to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { return gameMap.getPlayerPositionById(id); } public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1768": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public Optional<Integer> getUndoQuota() { return undoQuota >= 0 ? Optional.of(undoQuota) : Optional.empty(); }",
        "label": "P"
    },
    "1769": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { return gameMap.getAllPlayerPositions(); }",
        "label": "P"
    },
    "1770": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public void move(Position from, Position to) { gameMap.move(from, to); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { checkpoints.push(new GameMap(currMap)); currMap = new GameMap(gameMap); } public void undo() { gameMap = new GameMap(checkpoints.peek()); currMap = new GameMap(checkpoints.peek()); if (checkpoints.size() > 1) { checkpoints.pop(); if (undoQuota > 0) undoQuota--; } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { return gameMap.getPlayerPositionById(id); } public @Nullable Entity getEntity(@NotNull Position position) { return gameMap.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { return undoQuota >= 0 ? Optional.of(undoQuota) : Optional.empty(); }",
        "label": "P"
    },
    "1771": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } public void run() { renderingEngine.message(GAME_READY_MESSAGE); while (!shouldStop()) { renderingEngine.render(state); renderingEngine.message(String.format(UNDO_QUOTA_TEMPLATE, state.getUndoQuota().isPresent() ? state.getUndoQuota().get() : UNDO_QUOTA_UNLIMITED)); renderingEngine.message(\">>>\"); Action a = inputEngine.fetchAction(); ActionResult r = processAction(a); switch (r) { case ActionResult.Success ignored -> { } case ActionResult.Failed f -> renderingEngine.message(f.getReason()); } } renderingEngine.render(state); renderingEngine.message(GAME_EXIT_MESSAGE); if (state.isWin()) renderingEngine.message(WIN_MESSAGE); }",
        "label": "P"
    },
    "1772": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); }",
        "label": "P"
    },
    "1773": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1774": {
        "dataset": "COMP 3021",
        "project": "zrenah",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { gameMap = new GameMap(map); currMap = new GameMap(map); checkpoints = new Stack<GameMap>(); checkpoints.push(new GameMap(map)); if (gameMap.getUndoLimit().isPresent()) { undoQuota = gameMap.getUndoLimit().get(); } else { undoQuota = -1; } } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1775": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { return Optional.of(undoLimit); }",
        "label": "P"
    },
    "1776": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1777": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1778": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1779": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1780": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1781": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxes.containsKey(position)) return boxes.get(position); if (players.containsKey(position)) return players.get(position); var entity = map.getEntity(position); if (entity instanceof Box || entity instanceof Player) return new Empty(); return entity; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1782": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxes.containsKey(position)) return boxes.get(position); if (players.containsKey(position)) return players.get(position); var entity = map.getEntity(position); if (entity instanceof Box || entity instanceof Player) return new Empty(); return entity; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1783": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "1784": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "1785": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { if (boxes.containsKey(position)) return boxes.get(position); if (players.containsKey(position)) return players.get(position); var entity = map.getEntity(position); if (entity instanceof Box || entity instanceof Player) return new Empty(); return entity; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1786": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxes.containsKey(position)) return boxes.get(position); if (players.containsKey(position)) return players.get(position); var entity = map.getEntity(position); if (entity instanceof Box || entity instanceof Player) return new Empty(); return entity; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1787": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxes.containsKey(position)) return boxes.get(position); if (players.containsKey(position)) return players.get(position); var entity = map.getEntity(position); if (entity instanceof Box || entity instanceof Player) return new Empty(); return entity; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1788": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { if (boxes.containsKey(position)) return boxes.get(position); if (players.containsKey(position)) return players.get(position); var entity = map.getEntity(position); if (entity instanceof Box || entity instanceof Player) return new Empty(); return entity; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1789": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); if (inputLine.toLowerCase().equals(\"w\")) return new Move.Up(0); if (inputLine.toLowerCase().equals(\"a\")) return new Move.Left(0); if (inputLine.toLowerCase().equals(\"s\")) return new Move.Down(0); if (inputLine.toLowerCase().equals(\"d\")) return new Move.Right(0); if (inputLine.toLowerCase().equals(\"h\")) return new Move.Left(1); if (inputLine.toLowerCase().equals(\"j\")) return new Move.Down(1); if (inputLine.toLowerCase().equals(\"k\")) return new Move.Up(1); if (inputLine.toLowerCase().equals(\"l\")) return new Move.Right(1); if (inputLine.toLowerCase().equals(\"u\")) return new Undo(0); if (inputLine.toLowerCase().equals(\"exit\")) return new Exit(0); return new InvalidInput(0, \"Invalid Input.\"); }",
        "label": "P"
    },
    "1790": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public void move(Position from, Position to) { if (boxes.containsKey(from)) { boxes.put(to, boxes.get(from)); boxes.remove(from); } else if (players.containsKey(from)) { players.put(to, players.get(from)); players.remove(from); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1791": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public void move(Position from, Position to) { if (boxes.containsKey(from)) { boxes.put(to, boxes.get(from)); boxes.remove(from); } else if (players.containsKey(from)) { players.put(to, players.get(from)); players.remove(from); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (var key: players.keySet()) { if (players.get(key).getId() == id) return key; } return null; }",
        "label": "P"
    },
    "1792": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public void move(Position from, Position to) { if (boxes.containsKey(from)) { boxes.put(to, boxes.get(from)); boxes.remove(from); } else if (players.containsKey(from)) { players.put(to, players.get(from)); players.remove(from); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (var key: players.keySet()) { if (players.get(key).getId() == id) return key; } return null; } public @Nullable Entity getEntity(@NotNull Position position) { if (boxes.containsKey(position)) return boxes.get(position); if (players.containsKey(position)) return players.get(position); var entity = map.getEntity(position); if (entity instanceof Box || entity instanceof Player) return new Empty(); return entity; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1793": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public Optional<Integer> getUndoQuota() { if (undoQuota == -1) return Optional.empty(); else return Optional.of(undoQuota); }",
        "label": "P"
    },
    "1794": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { return players.keySet(); }",
        "label": "P"
    },
    "1795": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public void move(Position from, Position to) { if (boxes.containsKey(from)) { boxes.put(to, boxes.get(from)); boxes.remove(from); } else if (players.containsKey(from)) { players.put(to, players.get(from)); players.remove(from); } } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public void undo() { if (historyBoxes.size() == 1 && historyPlayers.size() == 1) { if (!boxes.equals(historyBoxes.get(0))) { boxes = new HashMap<>(historyBoxes.get(0)); players = new HashMap<>(historyPlayers.get(0)); if (undoQuota > 0) undoQuota--; } } else { if (!boxes.equals(historyBoxes.get(historyBoxes.size() - 2))) { boxes = new HashMap<>(historyBoxes.get(historyBoxes.size() - 2)); players = new HashMap<>(historyPlayers.get(historyPlayers.size() - 2)); historyBoxes.remove(historyBoxes.size() - 1); historyPlayers.remove(historyPlayers.size() - 1); if (undoQuota > 0) undoQuota--; } } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { for (var key: players.keySet()) { if (players.get(key).getId() == id) return key; } return null; } public @Nullable Entity getEntity(@NotNull Position position) { if (boxes.containsKey(position)) return boxes.get(position); if (players.containsKey(position)) return players.get(position); var entity = map.getEntity(position); if (entity instanceof Box || entity instanceof Player) return new Empty(); return entity; } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { if (undoQuota == -1) return Optional.empty(); else return Optional.of(undoQuota); }",
        "label": "P"
    },
    "1796": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); } public void run() { renderingEngine.render(state); while (!this.shouldStop()) { if (state.getUndoQuota().isPresent()) renderingEngine.message(\"Undo Quota: \" + state.getUndoQuota().get().toString()); else renderingEngine.message(\"Unlimited\"); renderingEngine.message(\">>>\"); var action = inputEngine.fetchAction(); var actionResult = processAction(action); if (actionResult instanceof ActionResult.Failed) renderingEngine.message(((ActionResult.Failed) actionResult).getReason()); renderingEngine.render(state); if (actionResult.getAction() instanceof Exit) break; } renderingEngine.message(\"Game exits.\"); if (this.shouldStop()) renderingEngine.message(\"You win.\"); }",
        "label": "P"
    },
    "1797": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) throw new IllegalArgumentException(); }",
        "label": "P"
    },
    "1798": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1799": {
        "dataset": "COMP 3021",
        "project": "mlinap",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.map = map; boxes = new HashMap<>(); historyBoxes = new ArrayList<>(); historyPlayers = new ArrayList<>(); players = new HashMap<>(); undoQuota = map.getUndoLimit().get(); for (int y = 0; y < map.getMaxHeight(); y++) { for (int x = 0; x < map.getMaxWidth(); x++) { var entity = map.getEntity(Position.of(x, y)); if (entity instanceof Box) boxes.put(Position.of(x, y), (Box) entity); else if (entity instanceof Player) players.put(Position.of(x, y), (Player) entity); } } historyBoxes.add(new HashMap<>(boxes)); historyPlayers.add(new HashMap<>(players)); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1800": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // DONE return maxWidth; } public int getMaxHeight() { // DONE return maxHeight; } public Optional<Integer> getUndoLimit() { // DONE return undoLimit >= 0 ? Optional.of(undoLimit) : Optional.empty(); }",
        "label": "P"
    },
    "1801": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1802": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1803": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1804": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1805": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1806": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return entities[position.y()][position.x()]; } public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1807": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return entities[position.y()][position.x()]; } public int getId() { return id; }",
        "label": "P"
    },
    "1808": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // DONE return maxHeight; }",
        "label": "P"
    },
    "1809": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // DONE return maxWidth; }",
        "label": "P"
    },
    "1810": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // DONE return map.getDestinations(); } public @Nullable Entity getEntity(@NotNull Position position) { // DONE return entities[position.y()][position.x()]; }",
        "label": "P"
    },
    "1811": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return entities[position.y()][position.x()]; }",
        "label": "P"
    },
    "1812": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return entities[position.y()][position.x()]; }",
        "label": "P"
    },
    "1813": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // DONE return entities[position.y()][position.x()]; }",
        "label": "P"
    },
    "1814": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } /** * Fetch an action from user in terminal to process. * <li>All possible input values are (A, S, W, D, H, J, K, L, U, EXIT) and they should be the 1st char of the input line.</li> * <li>Input values are case insensitive (e.g. eXiT is also valid)</li> * <li>All other values are invalid input, including whitespaces (e.g. \"\\n\" and \" A\" are both invalid)</li> * * @return the user action. Returns {@link InvalidInput} public @NotNull Action fetchAction() { // Input values are case insentitive final var inputLine = terminalScanner.nextLine().toLowerCase(); // DONE return switch (inputLine) { case \"w\" -> new Move.Up(0); case \"a\" -> new Move.Left(0); case \"s\" -> new Move.Down(0); case \"d\" -> new Move.Right(0); case \"k\" -> new Move.Up(1); case \"h\" -> new Move.Left(1); case \"j\" -> new Move.Down(1); case \"l\" -> new Move.Right(1); case \"u\" -> new Undo(-1); case StringResources.EXIT_COMMAND_TEXT -> new Exit(-1); default -> new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); }; }",
        "label": "P"
    },
    "1815": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public void move(Position from, Position to) { // DONE var moveTarget = getEntity(from); putEntity(to, moveTarget); putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1816": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public void move(Position from, Position to) { // DONE var moveTarget = getEntity(from); putEntity(to, moveTarget); putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // DONE for (int y = 0; y < getMapMaxHeight(); ++y) { for (int x = 0; x < getMapMaxWidth(); ++x) { var position = Position.of(x, y); var entity = getEntity(position); if (entity instanceof Player && ((Player) entity).getId() == id) { return position; } } } return null; }",
        "label": "P"
    },
    "1817": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public void move(Position from, Position to) { // DONE var moveTarget = getEntity(from); putEntity(to, moveTarget); putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // DONE for (int y = 0; y < getMapMaxHeight(); ++y) { for (int x = 0; x < getMapMaxWidth(); ++x) { var position = Position.of(x, y); var entity = getEntity(position); if (entity instanceof Player && ((Player) entity).getId() == id) { return position; } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // DONE return entities[position.y()][position.x()]; }",
        "label": "P"
    },
    "1818": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public Optional<Integer> getUndoQuota() { // DONE return undoLeft; }",
        "label": "P"
    },
    "1819": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // DONE var positions = new HashSet<Position>(); for (int id : map.getPlayerIds()) { positions.add(getPlayerPositionById(id)); } return positions; }",
        "label": "P"
    },
    "1820": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public void move(Position from, Position to) { // DONE var moveTarget = getEntity(from); putEntity(to, moveTarget); putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // DONE checkpoints.add(new GameCheckpoint(entities)); } public void undo() { // DONE // Decrease undo quota by one. Do not decrease if a box is never moved. if (undoLeft.isPresent() && !checkpoints.isEmpty()) { undoLeft = Optional.of(undoLeft.get() - 1); } // Revert to checkpoint. Suppose `cp1` and `cp2` are recorded. Perform `undo` will revert game state to `cp1`. if (!checkpoints.isEmpty()) { checkpoints.remove(checkpoints.size() - 1); } var checkpoint = checkpoints.isEmpty() ? initialState : checkpoints.get(checkpoints.size() - 1); putEntities(checkpoint.entities); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // DONE for (int y = 0; y < getMapMaxHeight(); ++y) { for (int x = 0; x < getMapMaxWidth(); ++x) { var position = Position.of(x, y); var entity = getEntity(position); if (entity instanceof Player && ((Player) entity).getId() == id) { return position; } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // DONE return entities[position.y()][position.x()]; } public Optional<Integer> getUndoQuota() { // DONE return undoLeft; }",
        "label": "P"
    },
    "1821": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // DONE if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } } public void run() { // DONE renderingEngine.message(StringResources.GAME_READY_MESSAGE); while (true) { // Render the game renderingEngine.render(state); if (shouldStop()) break; renderingEngine.message(getUndoQuotaString()); renderingEngine.message(\">>>\"); // Process action var action = inputEngine.fetchAction(); var actionResult = processAction(action); if (actionResult instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed) actionResult).getReason()); } } // Exit message renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(StringResources.WIN_MESSAGE); } }",
        "label": "P"
    },
    "1822": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // DONE if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"TerminalSokobanGame only support at most two players.\"); } }",
        "label": "P"
    },
    "1823": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // DONE // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1824": {
        "dataset": "COMP 3021",
        "project": "khheung",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // DONE this.map = map; this.entities = map.getShallowCopyOfEntities(); this.undoLeft = map.getUndoLimit(); this.checkpoints = new ArrayList<>(); this.initialState = new GameCheckpoint(this.entities); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1825": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return MaxWidth; } public int getMaxHeight() { // TODO return Maxheight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.ofNullable(Undolimit); }",
        "label": "P"
    },
    "1826": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1827": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1828": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1829": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1830": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1831": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return Map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1832": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return Map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1833": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return Maxheight; }",
        "label": "P"
    },
    "1834": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return MaxWidth; }",
        "label": "P"
    },
    "1835": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations(){ // TODO //System.out.println(Destinations.size()); return Destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return Map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1836": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return Map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1837": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return Map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1838": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return Map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1839": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO if (inputLine.equals(\"A\") || inputLine.equals(\"a\")) { return new Move.Left(0); } else if (inputLine.equals(\"S\") || inputLine.equals(\"s\")) { return new Move.Down(0); } else if (inputLine.equals(\"W\") || inputLine.equals(\"w\")) { return new Move.Up(0); } else if (inputLine.equals(\"D\") || inputLine.equals(\"d\")) { return new Move.Right(0); } else if (inputLine.equals(\"H\") || inputLine.equals(\"h\")) { return new Move.Left(1); } else if (inputLine.equals(\"J\") || inputLine.equals(\"j\")) { return new Move.Down(1); } else if (inputLine.equals(\"K\") || inputLine.equals(\"k\")) { return new Move.Up(1); } else if (inputLine.equals(\"L\") || inputLine.equals(\"l\")) { return new Move.Right(1); } else if (inputLine.equals(\"U\") || inputLine.equals(\"u\")) { return new Undo(1); } // debug for different upper and lowercase alphabets else if (inputLine.equals(\"exit\") || (inputLine.equals(\"Exit\"))) { return new Exit(1); } else{ return new InvalidInput(1, \"invalid input\"); } }",
        "label": "P"
    },
    "1840": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public void move(Position from, Position to) { // TODO Map.putEntity(new Position(to.x(), to.y()),Map.getEntity(new Position(from.x(), from.y()))); Map.putEntity(new Position(from.x(), from.y()), new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1841": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public void move(Position from, Position to) { // TODO Map.putEntity(new Position(to.x(), to.y()),Map.getEntity(new Position(from.x(), from.y()))); Map.putEntity(new Position(from.x(), from.y()), new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO String[] stxt = Map.gettingMap().clone(); for(int i = 0; i < stxt.length; i++){ for(int j = 0; j < stxt[i].length(); j++){ if(stxt[i].charAt(j) == (char)(id + 'A')){ return new Position(j, i); } } } return null; }",
        "label": "P"
    },
    "1842": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public void move(Position from, Position to) { // TODO Map.putEntity(new Position(to.x(), to.y()),Map.getEntity(new Position(from.x(), from.y()))); Map.putEntity(new Position(from.x(), from.y()), new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO String[] stxt = Map.gettingMap().clone(); for(int i = 0; i < stxt.length; i++){ for(int j = 0; j < stxt[i].length(); j++){ if(stxt[i].charAt(j) == (char)(id + 'A')){ return new Position(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return Map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1843": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public Optional<Integer> getUndoQuota() { // TODO if (Undolimit.equals(-1) == true){ return Optional.empty(); } if (Undolimit.get() > 0) { return Optional.ofNullable(Undolimit.get()); } // need to debug here return null; }",
        "label": "P"
    },
    "1844": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> result = new HashSet<Position>(); for(int i = 0; i < stext.length; i++){ for(int j = 0; j < stext[i].length(); j++){ char ch = stext[i].charAt(j); if (ch >= 'A' && ch <= 'Z') { if (result.contains(ch) == false){ result.add(new Position(j, i)); } } } } return result; }",
        "label": "P"
    },
    "1845": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public void move(Position from, Position to) { // TODO Map.putEntity(new Position(to.x(), to.y()),Map.getEntity(new Position(from.x(), from.y()))); Map.putEntity(new Position(from.x(), from.y()), new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO checkpointcount++; } public void undo() { // TODO int undoQuota = getUndoQuota().get(); if (checkpointcount > 0) { if (getUndoQuota().isEmpty()) { stext = checkpoint.get(checkpoint.size()-1); checkpoint.remove(checkpoint.size()); checkpointcount--; } if (undoQuota > 0) { stext = checkpoint.get(checkpoint.size() - 1); checkpoint.remove(checkpoint.size()); checkpointcount--; undoQuota--; } } Map.settingMap(stext); Undolimit = Optional.ofNullable(undoQuota); } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO String[] stxt = Map.gettingMap().clone(); for(int i = 0; i < stxt.length; i++){ for(int j = 0; j < stxt[i].length(); j++){ if(stxt[i].charAt(j) == (char)(id + 'A')){ return new Position(j, i); } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return Map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO if (Undolimit.equals(-1) == true){ return Optional.empty(); } if (Undolimit.get() > 0) { return Optional.ofNullable(Undolimit.get()); } // need to debug here return null; }",
        "label": "P"
    },
    "1846": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO this.renderingEngine.render(state); int targetquota = 0; // when there are more than two players in the map if(gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } if(state.getUndoQuota().isPresent() == true){ targetquota = state.getUndoQuota().get(); } else{ targetquota = 0; } renderingEngine.message(\"Undo Quota: \"+ targetquota); } public void run() { // TODO // keep checking the status of the game while(shouldStop() == false) { int targetquota = 0; if(state.getUndoQuota().isPresent() == true){ targetquota = state.getUndoQuota().get(); } else{ targetquota = 0; } renderingEngine.message(\"Undo Quota:\" + targetquota); renderingEngine.render(state); } renderingEngine.message(\"Game exits.\"); }",
        "label": "F"
    },
    "1847": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO this.renderingEngine.render(state); int targetquota = 0; // when there are more than two players in the map if(gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } if(state.getUndoQuota().isPresent() == true){ targetquota = state.getUndoQuota().get(); } else{ targetquota = 0; } renderingEngine.message(\"Undo Quota: \"+ targetquota); }",
        "label": "P"
    },
    "1848": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1849": {
        "dataset": "COMP 3021",
        "project": "chlibf",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO Map = map; Destinations = map.getDestinations(); MaxWidth = map.getMaxWidth(); MaxHeight = map.getMaxHeight(); Undolimit = map.getUndoLimit(); stext = map.gettingMap().clone(); checkpoint.put(0, stext.clone()); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1850": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return maxWidth; } public int getMaxHeight() { // TODO return maxHeight; } public Optional<Integer> getUndoLimit() { // TODO if (undoLimit == -1) { return Optional.empty(); }else { return Optional.of(undoLimit); } }",
        "label": "P"
    },
    "1851": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1852": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1853": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1854": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1855": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1856": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameInfo.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1857": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameInfo.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1858": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return maxHeight; }",
        "label": "P"
    },
    "1859": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return maxWidth; }",
        "label": "P"
    },
    "1860": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameInfo.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1861": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameInfo.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1862": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameInfo.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1863": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameInfo.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1864": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO Action action = switch (inputLine.toLowerCase()) { case \"a\" -> new Move.Left(0); case \"w\" -> new Move.Up(0); case \"d\" -> new Move.Right(0); case \"s\" -> new Move.Down(0); case \"h\" -> new Move.Left(1); case \"k\" -> new Move.Up(1); case \"l\" -> new Move.Right(1); case \"j\" -> new Move.Down(1); case \"u\" -> new Undo(2); case EXIT_COMMAND_TEXT -> new Exit(2); default -> new InvalidInput(2, INVALID_INPUT_MESSAGE); }; return action; }",
        "label": "P"
    },
    "1865": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public void move(Position from, Position to) { // TODO this.gameInfo.replace(to, gameInfo.get(from)); this.gameInfo.replace(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1866": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public void move(Position from, Position to) { // TODO this.gameInfo.replace(to, gameInfo.get(from)); this.gameInfo.replace(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (var position : gameInfo.keySet()) { if (gameInfo.get(position) instanceof Player p && p.getId() == id) { return position; } } return null; }",
        "label": "P"
    },
    "1867": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public void move(Position from, Position to) { // TODO this.gameInfo.replace(to, gameInfo.get(from)); this.gameInfo.replace(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for (var position : gameInfo.keySet()) { if (gameInfo.get(position) instanceof Player p && p.getId() == id) { return position; } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameInfo.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1868": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public Optional<Integer> getUndoQuota() { // TODO return quotaLeft; }",
        "label": "P"
    },
    "1869": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO Set<Position> positions = new HashSet<>(); for (var position : gameInfo.keySet()) { if (gameInfo.get(position) instanceof Player) { positions.add(position); } } return positions; }",
        "label": "P"
    },
    "1870": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public void move(Position from, Position to) { // TODO this.gameInfo.replace(to, gameInfo.get(from)); this.gameInfo.replace(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO checkpoints.add(new HashMap<>(gameInfo)); } public void undo() { // TODO if (checkpoints.size() == 1) { gameInfo = checkpoints.get(0); return; } gameInfo = new HashMap<>(checkpoints.get(checkpoints.size() - 2)); checkpoints.remove(checkpoints.size() - 1); if (!quotaLeft.isEmpty()) { quotaLeft = Optional.of(quotaLeft.get() - 1); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO for (var position : gameInfo.keySet()) { if (gameInfo.get(position) instanceof Player p && p.getId() == id) { return position; } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return gameInfo.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return quotaLeft; }",
        "label": "P"
    },
    "1871": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"There are more than two players in the map\"); } } public void run() { // TODO renderingEngine.message(GAME_READY_MESSAGE); renderingEngine.render(this.state); while (!this.shouldStop()) { if (!state.getUndoQuota().isEmpty()) { renderingEngine.message(String.format(UNDO_QUOTA_TEMPLATE, this.state.getUndoQuota().get())); } else { renderingEngine.message(\"Undo Quota: \" + UNDO_QUOTA_UNLIMITED); } renderingEngine.message(\">>>\"); Action action = inputEngine.fetchAction(); ActionResult result = this.processAction(action); if (result instanceof ActionResult.Failed f) { renderingEngine.message(f.getReason()); } renderingEngine.render(this.state); } renderingEngine.message(GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(WIN_MESSAGE); } }",
        "label": "P"
    },
    "1872": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(\"There are more than two players in the map\"); } }",
        "label": "P"
    },
    "1873": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. outputSteam.println(content); }",
        "label": "P"
    },
    "1874": {
        "dataset": "COMP 3021",
        "project": "nchristanto",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO quotaLeft = map.getUndoLimit(); this.map = map; gameInfo = new HashMap<Position, Entity>(map.getGameInfo()); checkpoints.add(new HashMap<>(gameInfo)); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public String toString() { return \"x: \" + String.valueOf(x) + \", y: \" + String.valueOf(y); }",
        "label": "P"
    },
    "1875": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.maxWidth; } public int getMaxHeight() { // TODO return this.maxHeight; } public Optional<Integer> getUndoLimit() { // TODO return Optional.of(this.undoLimit); }",
        "label": "P"
    },
    "1876": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1877": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1878": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1879": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1880": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1881": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return runningMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1882": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return runningMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1883": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.maxHeight; }",
        "label": "P"
    },
    "1884": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.maxWidth; }",
        "label": "P"
    },
    "1885": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO // throw new NotImplementedException(); return this.destinations; } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return runningMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1886": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return runningMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1887": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return runningMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1888": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return runningMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1889": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO // if(inputLine.toLowerCase().equals('a') || inputLine.toLowerCase().equals('J') ) // System.out.println(\"what is the most important thing =\" ); System.out.println((new Exit(0)).equals(new Exit(0))); if(inputLine.toLowerCase().equals(\"exit\")){ return new Exit(0); } else if(inputLine.length()==1 && inputLine.matches(\"[AaSsDdWwHhJjKkLlUu]\") ) { String command = inputLine.toLowerCase(); switch(command){ case \"a\" -> new Move.Left(0); case \"h\" -> new Move.Left(1); case \"s\" -> new Move.Down(0); case \"j\" -> new Move.Down(1); case \"w\" -> new Move.Up(0); case \"k\" -> new Move.Up(1); case \"d\" -> new Move.Right(0); case \"l\" -> new Move.Down(1); case \"u\" -> new Undo(0); default -> new InvalidInput(0,\"Invalid Input\"); } } return new InvalidInput( 0,\"Invalid Input\"); }",
        "label": "P"
    },
    "1890": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public void move(Position from, Position to) { // TODO // throw new NotImplementedException(); if(runningMap.get(from) instanceof Box) { checkpoint(); checkPoints.add(new GameState(this.maxWidth, this.maxHeight, this.destinations, this.undoLimit, this.runningMap)); } runningMap.put(to,runningMap.get(from)); runningMap.remove(from); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1891": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public void move(Position from, Position to) { // TODO // throw new NotImplementedException(); if(runningMap.get(from) instanceof Box) { checkpoint(); checkPoints.add(new GameState(this.maxWidth, this.maxHeight, this.destinations, this.undoLimit, this.runningMap)); } runningMap.put(to,runningMap.get(from)); runningMap.remove(from); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(Map.Entry<Position, Entity> entry : runningMap.entrySet()) { Position key = entry.getKey(); Entity value = entry.getValue(); if (value instanceof Player) { Player player = (Player) value; if (player.getId() == id) return key; } } return null; }",
        "label": "P"
    },
    "1892": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public void move(Position from, Position to) { // TODO // throw new NotImplementedException(); if(runningMap.get(from) instanceof Box) { checkpoint(); checkPoints.add(new GameState(this.maxWidth, this.maxHeight, this.destinations, this.undoLimit, this.runningMap)); } runningMap.put(to,runningMap.get(from)); runningMap.remove(from); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(Map.Entry<Position, Entity> entry : runningMap.entrySet()) { Position key = entry.getKey(); Entity value = entry.getValue(); if (value instanceof Player) { Player player = (Player) value; if (player.getId() == id) return key; } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return runningMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1893": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public Optional<Integer> getUndoQuota() { // TODO // throw new NotImplementedException(); if(this.undoLimit == -1) return Optional.empty(); else { return Optional.of(this.undoLimit); } }",
        "label": "P"
    },
    "1894": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO // throw new NotImplementedException(); Set<Position> playerPositons = new HashSet<Position>(); // Iterator it = playerList.iterator(); for(Map.Entry<Position, Entity> entry : runningMap.entrySet()) { Position key = entry.getKey(); Entity value = entry.getValue(); if (value instanceof Player) { playerPositons.add(key); } } // while(it.hasNext()) // { // // if(it.next() instanceof Player ) { // Player tmp = (Player) it.next(); // // playerPositons.add(getPlayerPositionById(tmp.getId())); // } // } return playerPositons; }",
        "label": "P"
    },
    "1895": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public void move(Position from, Position to) { // TODO // throw new NotImplementedException(); if(runningMap.get(from) instanceof Box) { checkpoint(); checkPoints.add(new GameState(this.maxWidth, this.maxHeight, this.destinations, this.undoLimit, this.runningMap)); } runningMap.put(to,runningMap.get(from)); runningMap.remove(from); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO // throw new NotImplementedException(); } public GameState(int maxWidth,int maxHeight, Set<Position> destinations, int undoLimit, Map<Position,Entity> map) { this.maxHeight = maxHeight; this.maxWidth = maxWidth; this.destinations = destinations; this.undoLimit = undoLimit; runningMap.putAll(map); } public @Nullable Position getPlayerPositionById(int id) { // TODO for(Map.Entry<Position, Entity> entry : runningMap.entrySet()) { Position key = entry.getKey(); Entity value = entry.getValue(); if (value instanceof Player) { Player player = (Player) value; if (player.getId() == id) return key; } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { // TODO // throw new NotImplementedException(); return runningMap.get(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO // throw new NotImplementedException(); if(this.undoLimit == -1) return Optional.empty(); else { return Optional.of(this.undoLimit); } }",
        "label": "P"
    },
    "1896": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new NotImplementedException(); } public void run() { // TODO TerminalSokobanGame terminalSokobanGame = new TerminalSokobanGame(this.state, (TerminalInputEngine) this.inputEngine, (TerminalRenderingEngine) this.renderingEngine); // terminalSokobanGame.renderingEngine.render(state); while(!shouldStop()){ Action tmp = inputEngine.fetchAction(); terminalSokobanGame.processAction(tmp); terminalSokobanGame.renderingEngine.render(terminalSokobanGame.state); System.out.println(tmp.getClass()); if(tmp instanceof Exit) { break; } } }",
        "label": "F"
    },
    "1897": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if(gameState.getAllPlayerPositions().size()>2) throw new NotImplementedException(); }",
        "label": "P"
    },
    "1898": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO String tmp = content+System.lineSeparator(); outputSteam.append(tmp); // Hint: System.out is also a PrintStream. // throw new NotImplementedException(); }",
        "label": "P"
    },
    "1899": {
        "dataset": "COMP 3021",
        "project": "cttongac",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO map.getMap().entrySet().forEach(entry -> { System.out.println(entry.getKey() + \" \" + entry.getValue()); }); checkPoints.add(new GameState(this.maxWidth,this.maxHeight,this.destinations,this.undoLimit,this.runningMap)); runningMap.putAll(map.getMap()); this.maxWidth = map.getMaxWidth(); this.maxHeight = map.getMaxHeight(); this.destinations = map.getDestinations(); this.undoLimit = map.getUndoLimit().get(); this.playerList = map.getPlayerList(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1900": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { return maxWidth; } public int getMaxHeight() { return maxHeight; } public Optional<Integer> getUndoLimit() { return Optional.of(undoLimit); }",
        "label": "P"
    },
    "1901": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1902": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1903": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1904": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1905": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1906": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1907": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1908": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { return maxHeight; }",
        "label": "P"
    },
    "1909": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { return maxWidth; }",
        "label": "P"
    },
    "1910": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { return map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1911": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1912": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1913": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1914": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); String lowerString = inputLine.toLowerCase(); switch (lowerString) { case (EXIT_COMMAND_TEXT) -> { return new Exit(-1); } case (\"u\") -> { return new Undo(-1); } case (\"a\") -> { return new Move.Left(0); } case (\"s\") -> { return new Move.Down(0); } case (\"w\") -> { return new Move.Up(0); } case (\"d\") -> { return new Move.Right(0); } case (\"h\") -> { return new Move.Left(1); } case (\"j\") -> { return new Move.Down(1); } case (\"k\") -> { return new Move.Up(1); } case (\"l\") -> { return new Move.Right(1); } default -> { return new InvalidInput(-1, INVALID_INPUT_MESSAGE); } } }",
        "label": "P"
    },
    "1915": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public void move(Position from, Position to) { Entity fromObj = map.getEntity(from); map.putEntity(from, new Empty()); map.putEntity(to, fromObj); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1916": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public void move(Position from, Position to) { Entity fromObj = map.getEntity(from); map.putEntity(from, new Empty()); map.putEntity(to, fromObj); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (int i = 0; i < map.getMaxHeight(); i ++) { for (int j = 0; j < map.getMaxWidth(); j ++) { var currEntity = map.getEntity(new Position(j, i)); if (currEntity instanceof Player) { if (((Player) currEntity).getId() == id) { return new Position(j, i); } } } } return null; }",
        "label": "P"
    },
    "1917": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public void move(Position from, Position to) { Entity fromObj = map.getEntity(from); map.putEntity(from, new Empty()); map.putEntity(to, fromObj); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { for (int i = 0; i < map.getMaxHeight(); i ++) { for (int j = 0; j < map.getMaxWidth(); j ++) { var currEntity = map.getEntity(new Position(j, i)); if (currEntity instanceof Player) { if (((Player) currEntity).getId() == id) { return new Position(j, i); } } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1918": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public Optional<Integer> getUndoQuota() { if (undoQuota.get() == -1) { return Optional.empty(); } else { return undoQuota; } }",
        "label": "P"
    },
    "1919": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { Set<Position> posSet = new HashSet<>(); for (int i = 0; i < map.getMaxHeight(); i ++) { for (int j = 0; j < map.getMaxWidth(); j ++) { var currEntity = map.getEntity(new Position(j, i)); if (currEntity instanceof Player) { posSet.add(new Position(j, i)); } } } return posSet; }",
        "label": "P"
    },
    "1920": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public void move(Position from, Position to) { Entity fromObj = map.getEntity(from); map.putEntity(from, new Empty()); map.putEntity(to, fromObj); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { historyMapStack.push(new GameMap(map)); } public void undo() { if (historyMapStack.size() > 0 && undoQuota.get() > 0) { undoQuota = Optional.of(undoQuota.get()-1); } if (historyMapStack.size() > 0) { historyMapStack.pop(); } if (historyMapStack.size() > 0) { map = new GameMap(historyMapStack.peek()); } else { map = new GameMap(initMap); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { for (int i = 0; i < map.getMaxHeight(); i ++) { for (int j = 0; j < map.getMaxWidth(); j ++) { var currEntity = map.getEntity(new Position(j, i)); if (currEntity instanceof Player) { if (((Player) currEntity).getId() == id) { return new Position(j, i); } } } } return null; } public @Nullable Entity getEntity(@NotNull Position position) { return map.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { if (undoQuota.get() == -1) { return Optional.empty(); } else { return undoQuota; } }",
        "label": "P"
    },
    "1921": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } } public void run() { renderingEngine.message(GAME_READY_MESSAGE); while (!shouldStop()) { renderingEngine.render(state); String quotaStr; if (state.getUndoQuota().isPresent()) { quotaStr = String.format(UNDO_QUOTA_TEMPLATE, state.getUndoQuota().get()); } else { quotaStr = UNDO_QUOTA_UNLIMITED; } renderingEngine.message(quotaStr); Action newAct = inputEngine.fetchAction(); ActionResult res = processAction(newAct); if (res instanceof ActionResult.Failed) { renderingEngine.message(((ActionResult.Failed)(res)).getReason()); } } renderingEngine.render(state); renderingEngine.message(GAME_EXIT_MESSAGE); if (state.isWin()) { renderingEngine.message(WIN_MESSAGE); } }",
        "label": "P"
    },
    "1922": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } }",
        "label": "P"
    },
    "1923": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { outputSteam.print(content + System.lineSeparator()); }",
        "label": "P"
    },
    "1924": {
        "dataset": "COMP 3021",
        "project": "yyubv",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { this.map = new GameMap(map); this.initMap = new GameMap(map); this.undoQuota = map.getUndoLimit(); this.historyMapStack = new Stack<>(); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    },
    "1925": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "0",
        "T": "void testLoadFromFile() throws IOException { final var mapFile = tempDir.resolve(\"tempMap.map\"); String rectangularMap = \"\"\" 233 ###### #A..@# #...@# #....# #.a..# #..a.# ###### \"\"\"; Files.writeString(mapFile, rectangularMap); final var gameMap = SokobanGameFactory.loadGameMap(mapFile); assertEquals(6, gameMap.getMaxWidth()); assertEquals(7, gameMap.getMaxHeight()); assertEquals(233, gameMap.getUndoLimit().orElse(null)); }",
        "C": "public static @NotNull GameMap loadGameMap(@NotNull Path mapFile) throws IOException { final var fileContent = Files.readString(mapFile); return GameMap.parse(fileContent); } public int getMaxWidth() { // TODO return this.width; } public int getMaxHeight() { // TODO return this.height; } public Optional<Integer> getUndoLimit() { // TODO return this.undoLimit; }",
        "label": "P"
    },
    "1926": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "1",
        "T": "void moveLeft() { assertEquals( Position.of(232, 233), new Move.Left(-1).nextPosition(pos) ); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public Left(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1927": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "2",
        "T": "void testShouldStopWhenWin() { final var gameState = mock(GameState.class); when(gameState.isWin()).thenReturn(true); final var game = new SokobanGameForTesting(gameState); assertTrue(game.shouldStop()); }",
        "C": "",
        "label": "P"
    },
    "1928": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "3",
        "T": "void testMove() { String mapText = \"\"\" 233 ###### #A..@# #....# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(1)).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1929": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "4",
        "T": "void testPushBox() { String mapText = \"\"\" 233 ###### #A..@# #a...# #....# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Success); verify(gameState, times(2)).move(any(), any()); verify(gameState, times(1)).checkpoint(); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1930": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "5",
        "T": "void testHitWall() { String mapText = \"\"\" 233 ###### #A..@# ##...# #a...# ###### \"\"\"; final var testMap = TestHelper.parseGameMap(mapText); final var gameState = spy(new GameState(testMap)); final var game = new SokobanGameForTesting(gameState); final var result = game.feedActionForProcessing(new Move.Down(0)); assertTrue(result instanceof ActionResult.Failed); verify(gameState, never()).move(any(), any()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public Down(int initiator) { super(initiator); }",
        "label": "P"
    },
    "1931": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "6",
        "T": "void testBoxParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var box = assertInstanceOf(Box.class, gameMap.getEntity(Position.of(2, 4))); assertNotNull(box); assertEquals(0, box.getPlayerId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.state.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getPlayerId() { return playerId; }",
        "label": "P"
    },
    "1932": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "7",
        "T": "void testPlayerParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var player = assertInstanceOf(Player.class, gameMap.getEntity(Position.of(1, 1))); assertNotNull(player); assertEquals(0, player.getId()); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.state.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public int getId() { return id; }",
        "label": "P"
    },
    "1933": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "8",
        "T": "void testHeightForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(7, gameMap.getMaxHeight()); }",
        "C": "public int getMaxHeight() { // TODO return this.height; }",
        "label": "P"
    },
    "1934": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "9",
        "T": "void testWidthForRectangularMap() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(6, gameMap.getMaxWidth()); }",
        "C": "public int getMaxWidth() { // TODO return this.width; }",
        "label": "P"
    },
    "1935": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "10",
        "T": "void testGetDestinations() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertEquals(2, gameMap.getDestinations().size()); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(4, 1))); }",
        "C": "public @NotNull @Unmodifiable Set<Position> getDestinations() { // TODO return this.map.getDestinations(); } /** * Get the undo quota currently left, i.e., the maximum number of undo actions that can be performed from now on. * If undo is unlimited, * * @return the undo quota left (using {@link Optional#of(Object)}) if the game has an undo limit; * {@link Optional#empty()} public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.state.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1936": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "11",
        "T": "void testWallParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Wall.class, gameMap.getEntity(Position.of(0, 0))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.state.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1937": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "12",
        "T": "void testGetEntity() { final var gameMap = TestHelper.parseGameMap(rectangularMap); final var entity = gameMap.getEntity(Position.of(0, 0)); assertTrue(entity instanceof Wall); } private static final String nonRectangularMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\";",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.state.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1938": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "13",
        "T": "void testEmptyCellParsing() { final var gameMap = TestHelper.parseGameMap(rectangularMap); assertInstanceOf(Empty.class, gameMap.getEntity(Position.of(2, 1))); }",
        "C": "public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.state.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1939": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "14",
        "T": "void testExit() { final var inputStream = fixValueStream(\"exit\"); final var inputEngine = new TerminalInputEngine(inputStream); final var action = inputEngine.fetchAction(); assertTrue(action instanceof Exit); }",
        "C": "public TerminalInputEngine(InputStream terminalStream) { this.terminalScanner = new Scanner(terminalStream); } public @NotNull Action fetchAction() { // This is an example showing how to read a line from the Scanner class. // Feel free to change it if you do not like it. final var inputLine = terminalScanner.nextLine(); // TODO var inputUpper = inputLine.toUpperCase(); switch (inputUpper) { case \"A\": return new Move.Left(0); case \"S\": return new Move.Down(0); case \"W\": return new Move.Up(0); case \"D\": return new Move.Right(0); case \"H\": return new Move.Left(1); case \"J\": return new Move.Down(1); case \"K\": return new Move.Up(1); case \"L\": return new Move.Right(1); case \"U\": return new Undo(-1); case \"EXIT\": return new Exit(-1); default: return new InvalidInput(-1, StringResources.INVALID_INPUT_MESSAGE); } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1940": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "15",
        "T": "void testWin() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\"); final var gameState = new GameState(testMap); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(3, 2), Position.of(4, 2)); assertTrue(gameState.isWin()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public void move(Position from, Position to) { // TODO if (this.state.getEntity(from) instanceof Player p) { this.state.getPlayerPosition().put((char)(p.getId() + 'A'), to); } this.state.putEntity(to, this.state.getEntity(from)); this.state.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); }",
        "label": "P"
    },
    "1941": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "16",
        "T": "void testMove() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #A.a@# #..a@# ###### \"\"\" )); gameState.move(Position.of(1, 1), Position.of(2, 1)); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public void move(Position from, Position to) { // TODO if (this.state.getEntity(from) instanceof Player p) { this.state.getPlayerPosition().put((char)(p.getId() + 'A'), to); } this.state.putEntity(to, this.state.getEntity(from)); this.state.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.state.getPlayerPosition().get((char)('A'+id)); }",
        "label": "P"
    },
    "1942": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "17",
        "T": "void testPushBox() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); assertEquals(Position.of(3, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(4, 1))); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public void move(Position from, Position to) { // TODO if (this.state.getEntity(from) instanceof Player p) { this.state.getPlayerPosition().put((char)(p.getId() + 'A'), to); } this.state.putEntity(to, this.state.getEntity(from)); this.state.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @Nullable Position getPlayerPositionById(int id) { // TODO return this.state.getPlayerPosition().get((char)('A'+id)); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.state.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap}",
        "label": "P"
    },
    "1943": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "18",
        "T": "void testGetUndoLimit() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); assertEquals(233, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota; }",
        "label": "P"
    },
    "1944": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "19",
        "T": "void testAllPlayerIds() { final var testMap = TestHelper.parseGameMap(\"\"\" 233 ###### #APp@# #xXa@@# ###### \"\"\"); final var gameState = new GameState(testMap); assertEquals(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(2, 1), Position.of(2, 2))), gameState.getAllPlayerPositions()); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public static @NotNull Position of(int x, int y) { return new Position(x, y); } public @NotNull Set<Position> getAllPlayerPositions() { // TODO return new HashSet<Position>(this.state.getPlayerPosition().values()); }",
        "label": "P"
    },
    "1945": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "20",
        "T": "void testUndoWhenThereIsCheckpoint() { final var gameState = new GameState(TestHelper.parseGameMap(\"\"\" 233 ###### #.Aa@# #..a@# ###### \"\"\" )); gameState.move(Position.of(3, 1), Position.of(4, 1)); gameState.move(Position.of(2, 1), Position.of(3, 1)); gameState.checkpoint(); gameState.undo(); assertEquals(Position.of(2, 1), gameState.getPlayerPositionById(0)); assertInstanceOf(Box.class, gameState.getEntity(Position.of(3, 1))); assertInstanceOf(Empty.class, gameState.getEntity(Position.of(4, 1))); assertEquals(232, gameState.getUndoQuota().orElse(null)); }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public void move(Position from, Position to) { // TODO if (this.state.getEntity(from) instanceof Player p) { this.state.getPlayerPosition().put((char)(p.getId() + 'A'), to); } this.state.putEntity(to, this.state.getEntity(from)); this.state.putEntity(from, new Empty()); } /** * Record a checkpoint of the game state, including: * <li>All current positions of entities in the game map.</li> * <li>Current undo quota</li> * <p> * Checkpoint is used in {@link GameState#undo()} public static @NotNull Position of(int x, int y) { return new Position(x, y); } public void checkpoint() { // TODO var newState = new GameState(new GameMap(this.state)); newState.checkpoint = this.checkpoint; this.checkpoint = newState; this.checkpoint.undoQuota = this.undoQuota; } public void undo() { // TODO if (this.checkpoint == null) { this.state = new GameMap(this.map); } else { var currentBoxPositions = this.state.getBoxPositions(); //var checkpointBoxPositions = this.checkpoint.state.getBoxPositions(); for (var entry : currentBoxPositions) { if (!(this.checkpoint.state.getEntity(entry) instanceof Box)) { this.state = new GameMap(this.checkpoint.map); if (this.undoQuota.isPresent()) { if (this.undoQuota.get() >= 1) { this.undoQuota = Optional.of(this.undoQuota.get()-1); } } this.checkpoint = this.checkpoint.checkpoint; return; } } //System.out.println(\"recursive\"); this.checkpoint = this.checkpoint.checkpoint; if (this.undoQuota.isPresent()) { if (this.undoQuota.get() >= 1) { this.undoQuota = Optional.of(this.undoQuota.get()-1); } } undo(); } } /** * Get the maximum width of the game map. * This should be the same as that in {@link GameMap} public @Nullable Position getPlayerPositionById(int id) { // TODO return this.state.getPlayerPosition().get((char)('A'+id)); } public @Nullable Entity getEntity(@NotNull Position position) { // TODO return this.state.getEntity(position); } /** * Get all box destination positions as a set in the game map. * This should be the same as that in {@link GameMap} public Optional<Integer> getUndoQuota() { // TODO return this.undoQuota; }",
        "label": "P"
    },
    "1946": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "21",
        "T": "void testGameLoop() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.isWin()).thenReturn(false); when(inputEngine.fetchAction()) .thenReturn(new InvalidInput(0, \"\")) .thenReturn(new Exit(0)); final var game = new TerminalSokobanGame(gameState, inputEngine, renderingEngine); game.run(); final var inOrder = inOrder(inputEngine, renderingEngine); // Before loop inOrder.verify(renderingEngine).render(eq(gameState)); // First round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); // Second round inOrder.verify(inputEngine).fetchAction(); inOrder.verify(renderingEngine).render(eq(gameState)); verify(gameState, atLeastOnce()).getUndoQuota(); verify(gameState, atLeast(0)).isWin(); verify(renderingEngine, atLeastOnce()).message(any()); }",
        "C": "public InvalidInput(int initiator, @NotNull String message) { super(initiator); this.message = message; } public Exit(int initiator) { super(initiator); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } //throw new NotImplementedException(); } public void run() { // TODO this.renderingEngine.message(StringResources.GAME_READY_MESSAGE); this.printMap(); while (!this.shouldStop()) { var act = this.inputEngine.fetchAction(); if (act instanceof Exit) { this.requestExit = true; } var actResult = this.processAction(act); if (actResult instanceof ActionResult.Failed) { this.renderingEngine.message(((ActionResult.Failed) actResult).getReason()); } this.printMap(); } this.renderingEngine.message(StringResources.GAME_EXIT_MESSAGE); if (this.state.isWin()) { this.renderingEngine.message(StringResources.WIN_MESSAGE); } //System.exit(0); }",
        "label": "P"
    },
    "1947": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "22",
        "T": "void testTwoPlayers() { final var gameState = mock(GameState.class); final var inputEngine = mock(TerminalInputEngine.class); final var renderingEngine = mock(TerminalRenderingEngine.class); when(gameState.getAllPlayerPositions()).thenReturn(new HashSet<>(Arrays.asList(Position.of(1, 1), Position.of(1, 2)))); assertDoesNotThrow(() -> new TerminalSokobanGame(gameState, inputEngine, renderingEngine)); }",
        "C": "public static @NotNull Position of(int x, int y) { return new Position(x, y); } public TerminalSokobanGame(GameState gameState, TerminalInputEngine inputEngine, TerminalRenderingEngine renderingEngine) { super(gameState); this.inputEngine = inputEngine; this.renderingEngine = renderingEngine; // TODO // Check the number of players if (gameState.getAllPlayerPositions().size() > 2) { throw new IllegalArgumentException(); } //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1948": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "23",
        "T": "void testMessage() { final var stream = new CapturingStream(); final var randomString = String.valueOf(this.hashCode()); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.message(randomString); assertEquals(randomString + System.lineSeparator(), stream.getContent()); }",
        "C": "public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public void message(@NotNull String content) { // TODO // Hint: System.out is also a PrintStream. this.outputSteam.println(content); //throw new NotImplementedException(); }",
        "label": "P"
    },
    "1949": {
        "dataset": "COMP 3021",
        "project": "ttleeab",
        "bug_id": "24",
        "T": "void testRender() { String testMap = \"\"\" 233 ###### #A..@# #...@### #a....@## #.a.....# #..a.#### ###### \"\"\"; final var gameState = new GameState(TestHelper.parseGameMap(testMap)); final var stream = new CapturingStream(); final var renderingEngine = new TerminalRenderingEngine(stream); renderingEngine.render(gameState); final var renderedContent = stream.getContent(); assertEquals(7, renderedContent.lines().count()); assertTrue(renderedContent.lines().allMatch(it -> it.length() >= 9 && it.length() <= 10)); // On Windows there may be \\n\\r final var lines = renderedContent.lines().toList(); assertEquals('#', lines.get(0).charAt(0)); assertEquals(' ', lines.get(0).charAt(8)); assertEquals('a', lines.get(3).charAt(1)); } static class CapturingStream extends PrintStream { public CapturingStream() { super(new ByteArrayOutputStream()); } public String getContent() { return ((ByteArrayOutputStream) this.out).toString(StandardCharsets.UTF_8); } }",
        "C": "public GameState(@NotNull GameMap map) { // TODO this.map = map; this.undoQuota = map.getUndoLimit(); this.state = new GameMap(map); } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; } public TerminalRenderingEngine(PrintStream outputSteam) { this.outputSteam = outputSteam; }",
        "label": "P"
    }
}